//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)
//{{LSL_DECLARATION

(*!
<Class
	Name               = "_FileSys"
	Revision           = "1.19"
	GUID               = "{0AE62524-FC75-494D-830D-A06ECAF5AFFE}"
	RealtimeTask       = "false"
	CyclicTask         = "false"
	BackgroundTask     = "false"
	Sigmatek           = "true"
	OSInterface        = "true"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	SharedCommandTable = "true"
	Objectsize         = "(284,120)"
	Comment            = "System File Functions. &#10;&#10;LasalOS File Error Return Codes:&#10;*  0  NO_ERROR                        * -1  ERROR_RESERVED &#10;* -2  PARAM_ERROR                 * -3  INVALID_FILENAME &#10;* -4  DRIVE_NOT_FOUND          * -5  TOO_MANY_FILES &#10;* -6  NO_MORE_FILES               * -7  WRONG_MEDIA &#10;* -8  INVALID_FILE_SYSTEM      * -9  FILE_NOT_FOUND &#10;* -10  INVALID_FILE_HANDLE    * -11  UNSUPPORTED_DEVICE &#10;* -12  UNSUPPORTED_DRIVER_FUNCTION      * -13  CORRUPTED_PARTITION_TABLE &#10;* -14  TOO_MANY_DRIVES         * -15  INVALID_FILE_POS &#10;* -16  ACCESS_DENIED              * -17  STRING_BUFFER_TOO_SMALL &#10;* -18  GENERAL_FAILURE           * -19  PATH_NOT_FOUND &#10;* -20  FAT_ALLOC_ERROR         * -21  ROOT_DIR_FULL &#10;* -22  DISK_FULL                        * -23  TIMEOUT &#10;* -24  BAD_SECTOR                    * -25  DATA_ERROR &#10;* -26  MEDIA_CHANGED             * -27  SECTOR_NOT_FOUND &#10;* -28  ADDRESS_MARK_NOT_FOUND       * -29  DRIVE_NOT_READY &#10;* -30  WRITE_PROTECTION        * -31  DMA_OVERRUN &#10;* -32  CRC_ERROR                      * -33  DEVICE_RESOURCE_ERROR &#10;* -34  INVALID_SECTOR_SIZE     * -35  OUT_OF_BUFFERS &#10;* -36  FILE_EXISTS                       * -37  LONG_FILE_POS &#10;* -38  FILE_TOO_LARGE &#10;&#10;For more details please read the OS Interface (-&gt; _FileSys class -&gt;Appendix B) documentation!">
	<Channels>
		<Server Name="Server0" GUID="{AB100214-5128-40EF-99B0-054DA012446E}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false"/>
	</Channels>
	<Dependencies>
		<Files>
			<File Path=".\Source\code\OsiBaseNew.st"/>
			<File Path=".\Source\code\OsiBaseNew.h" Include="false"/>
			<File Path=".\File_IOTypes.h" Include="false"/>
		</Files>
	</Dependencies>
	<RevDoku>
		<Owner Company="Sigmatek GmbH &amp; Co KG" Author="strgue"/>
		<Dokumentation Revision="1.19" Date="2017-03-15" Author="schsas" Company="Sigmatek GmbH &amp; Co KG" Description="Check function RemoveDirectory_Full and RemoveDirectory_Full_A on NULL"/>
		<Dokumentation Revision="1.18" Date="2015-10-21" Author="strgue" Company="Sigmatek GmbH &amp; Co KG" Description="Added functions RemoveDirectory_Full and RemoveDirectory_Full_A for OS version starting with 09.01.190 and 09.03.010"/>
		<Dokumentation Revision="1.17" Date="2015-02-17" Author="plechr" Company="Sigmatek GmbH &amp; Co KG" Description="Changed OS-platform check for new _FileSys-methods"/>
		<Dokumentation Revision="1.16" Date="2015-02-12" Author="plechr" Company="Sigmatek GmbH &amp; Co KG" Description="Added OS-Version and platform check for new _FileSys-methods "/>
		<Dokumentation Revision="1.15" Date="2014-12-09" Author="plechr" Company="Sigmatek GmbH &amp; Co KG" Description="Added methods: RemoveDirectory_Full and RemoveDirectory_Full_A&#13;&#10;"/>
		<Dokumentation Revision="1.14" Date="2013-01-16" Author="kiltob" Company="Sigmatek GmbH &amp; Co KG" Description="Changed name SplitNameExtensionToNameAndExtension to SplitNameExtension"/>
		<Dokumentation Revision="1.13" Date="2012-11-16" Author="kiltob" Company="Sigmatek GmbH &amp; Co KG" Description="Added method SplitNameExtensionToNameAndExtension"/>
		<Dokumentation Revision="1.12" Date="2012-06-28" Author="kiltob" Company="Sigmatek GmbH &amp; Co KG" Description="Added methods: FileCreate, FileCreateA"/>
	</RevDoku>
</Class>
*)
_FileSys : CLASS
	TYPE
	  OS_FILE : STRUCT
	    FileRead : pVoid;
	    FileWrite : pVoid;
	    FileOpen : pVoid;
	    FileClose : pVoid;
	    FileDel : pVoid;
	    Filelseek : pVoid;
	    FileTell : pVoid;
	    FileLength : pVoid;
	    CreateDir : pVoid;
	    RemoveDir : pVoid;
	    FindFirst : pVoid;
	    FindNext : pVoid;
	    FindClose : pVoid;
	    CloseAllOpenFiles : pVoid;
	    Rename : pVoid;
	    FileOpenX : pVoid;
	    FileWriteX : pVoid;
	    SetTell : pVoid;
	    GetDriveListShort : pVoid;
	    SetDriverList : pVoid;
	    GetDriverList : pVoid;
	    Extend : pVoid;
	    lAppDefOpenFlags : DINT;
	    SetDefaultOpenFlags : pVoid;
	    FileRead_A : pVoid;
	    FileWrite_A : pVoid;
	    FileOpen_A : pVoid;
	    FileClose_A : pVoid;
	    FileDel_A : pVoid;
	    Filelseek_A : pVoid;
	    FileTell_A : pVoid;
	    FileLength_A : pVoid;
	    CreateDir_A : pVoid;
	    RemoveDir_A : pVoid;
	    FindFirst_A : pVoid;
	    FindNext_A : pVoid;
	    FindClose_A : pVoid;
	    CloseAllOpenFiles_A : pVoid;
	    Rename_A : pVoid;
	    GetAsyncState : pVoid;
	    Truncate : pVoid;
	    Truncate_A : pVoid;
	    FindFirstEx : pVoid;
	    FindNextEx : pVoid;
	    FindFirstEx_A : pVoid;
	    FindNextEx_A : pVoid;
	    FileCopy : pVoid;
	    GetAttributes : pVoid;
	    SetAttributes : pVoid;
	    GetDiskSpace : pVoid;
	    FileReadV1 : pVoid;
	    FileRead_AV1 : pVoid;
	    FileWrite_AV1 : pVoid;
	    CreateRAMDisk : pVoid;
	    DestroyRAMDisk : pVoid;
	    FileCopy_A : pVoid;
	    Format : pVoid;
	    FormatProgressInfo : pVoid;
	    GetDiskSpace_A : pVoid;
	    GetDriveListShort_A : pVoid;
	    GetDriveListShortEx : pVoid;
	    GetDriveListShortEx_A : pVoid;
	    CheckDisk : pVoid;
	    CheckDisk_A : pVoid;
	    SRam_Load : pVoid;
	    SRamSave : pVoid;
	    FormatDrive : pVoid;
	    SetVolumeLabel : pVoid;
	    GetVolumeLabel : pVoid;
	    GetFATType : pVoid;
	    SRamLoadV1 : pVoid;
	    FileCreate : pVoid;
	    FileCreate_A : pVoid;
	    SplitNameExtension : pVoid;
	    RemoveDirectory_Full : pVoid;
	    RemoveDirectory_Full_A : pVoid;
	  END_STRUCT;
	END_TYPE
  //Servers:
	Server0 	: SvrChCmd_DINT;
  //Clients:
  //Variables:
  //Functions:
	
	FUNCTION _FileSys
		VAR_OUTPUT
			ret_code 	: ConfStates;
		END_VAR;
				//! <Function Comment="This function opens a file on a local drive." Name="FileOpen"/>
	FUNCTION __CDECL VIRTUAL GLOBAL FileOpen
		VAR_INPUT
			filename 	: ^CHAR;			//! <Variable Comment="Parameter FileName must point to the name of the file to open/create. File names are not case sensitive, they will be converted to upper case. Also it must not contain wildcards!" Name="FileOpen.filename"/>
			attributes 	: UDINT;			//! <Variable Comment="The attributes can be a combination of: &#10;* ATT_READ_WRITE &#10;* ATT_READ_ONLY &#10;* ATT_OPEN_SHARED &#10;* ATT_OPEN_NO_DIR &#10;* ATT_OPEN_DIR &#10;* ATT_CREATE &#10;* ATT_CREATE_ALWAYS &#10;* ATT_COMMITTED &#10;* ATT_CACHE_DATA &#10;* ATT_LAZY_DATA&#10;&#10; For more details please read the OS Interface (-&gt; _FileSys Class -&gt; Appendix B) documentation!" Name="FileOpen.attributes"/>
		END_VAR
		VAR_OUTPUT
			handle (EAX) 	: DINT;			//! <Variable Comment="If the function succeeds, the return value is a file handle for the opened file and the file pointer of the file is set to 0. If the return value is less than 0, the function has failed and the return value is the error code. For the possible &apos;Error Codes&apos;, read the _FileSys class comment." Name="FileOpen.handle"/>
		END_VAR;
				//! <Function Comment="This function reads data from a file.&#13;&#10;Use FileReadV1 instead to get a signed return value. " Name="FileRead"/>
	FUNCTION __CDECL VIRTUAL GLOBAL FileRead
		VAR_INPUT
			handle 	: DINT;			//! <Variable Comment="Parameter Handle references the open file from which to read." Name="FileRead.handle"/>
			buffer 	: pVoid;			//! <Variable Comment="Buffer specifies the address for the data to be read." Name="FileRead.buffer"/>
			length 	: UDINT;			//! <Variable Comment="Length specifies the number of bytes to read." Name="FileRead.length"/>
		END_VAR
		VAR_OUTPUT
			read (EAX) 	: UDINT;			//! <Variable Comment="Reading past the end of file is not regarded as an error. &#13;&#10;If the function returns a value less than the read size, then probably the end of the file was encountered.&#13;&#10;If the function succeeds, the return value is the value of read bytes. &#13;&#10;If the function fails, the return value is zero." Name="FileRead.read"/>
		END_VAR;
				//! <Function Comment="This function writes data to a file." Name="FileWrite"/>
	FUNCTION __CDECL VIRTUAL GLOBAL FileWrite
		VAR_INPUT
			handle 	: DINT;			//! <Variable Comment="Parameter Handle references the open file to write to." Name="FileWrite.handle"/>
			buffer 	: pVoid;			//! <Variable Comment="Buffer specifies the address of the data to be written." Name="FileWrite.buffer"/>
			length 	: UDINT;			//! <Variable Comment="Length specifies the number of bytes to write." Name="FileWrite.length"/>
		END_VAR
		VAR_OUTPUT
			written (EAX) 	: DINT;			//! <Variable Comment="Writing past the current end of file will automatically extend the file. &#10;When the file size exceeds the current allocated file size, new clusters are allocated for the file. The FileSystem will allocate new clusters immediately following the current last cluster, if possible. &#10;&#10;If the function succeeds, the return value is the count of written bytes. If the function fails, the return value is a negative error code. For the possible &apos;Error Codes&apos;, read the _FileSys class comment." Name="FileWrite.written"/>
		END_VAR;
				//! <Function Comment="This function closes an open file." Name="FileClose"/>
	FUNCTION __CDECL VIRTUAL GLOBAL FileClose
		VAR_INPUT
			handle 	: DINT;			//! <Variable Comment="Parameter Handle must have been assigned in a previous successful call to FileOpen." Name="FileClose.handle"/>
		END_VAR;
				//! <Function Comment="This function deletes a file." Name="FileDelete"/>
	FUNCTION __CDECL VIRTUAL GLOBAL FileDelete
		VAR_INPUT
			filename 	: ^CHAR;			//! <Variable Comment="Parameter FileName must point to the name of the file to be deleted and may NOT contain wildcards." Name="FileDelete.filename"/>
		END_VAR
		VAR_OUTPUT
			retval (EAX) 	: DINT;			//! <Variable Comment="If the function succeeds, the return value is 0. If the function fails, the return value is a negative error code. For the possible &apos;Error Codes&apos;, read the _FileSys class comment." Name="FileDelete.retval"/>
		END_VAR;
				//! <Function Comment="FileLSeek repositions a file pointer and possibly extends a file.&#13;&#10;Use FileLSeekV1 instead to get a signed return value. " Name="Filelseek"/>
	FUNCTION __CDECL VIRTUAL GLOBAL Filelseek
		VAR_INPUT
			handle 	: DINT;			//! <Variable Comment="Parameter Handle references the open file for which to reposition the file pointer." Name="Filelseek.handle"/>
			offset 	: UDINT;			//! <Variable Comment="Offset specifies how far the file pointer should be moved. Please note that Offset is a signed integer value." Name="Filelseek.offset"/>
			fromwhere 	: UDINT;			//! <Variable Comment="Parameter fromwhere specifies Offset&apos;s meaning. The following values are allowed: &#10;&#10;FILE_BEGIN(0) - Offset is an absolute file pointer &#10;                           value. &#10;FILE_CURRENT(1) - Offset should be added to &#10;                                 the current file pointer value. &#10;FILE_END(2)  - Offset should be added to the &#10;                         current file size." Name="Filelseek.fromwhere"/>
		END_VAR
		VAR_OUTPUT
			retval (EAX) 	: UDINT;			//! <Variable Comment="If the function succeeds, the return value is the new file pointer value, or, if the file pointer is larger than (2^31)-1, LONG_FILE_POS is returned. If the function fails, the return value is some other negative error code. For the possible &apos;Error Codes&apos;, read the _FileSys class comment. To evaluate the error code the return value must be casted into a signed value." Name="Filelseek.retval"/>
		END_VAR;
				//! <Function Comment="This function returns the current position of the FilePointer." Name="FileTell"/>
	FUNCTION __CDECL VIRTUAL GLOBAL FileTell
		VAR_INPUT
			handle 	: DINT;			//! <Variable Comment="Parameter Handle references the open file for which to get the current position of the file pointer." Name="FileTell.handle"/>
		END_VAR
		VAR_OUTPUT
			retval (EAX) 	: DINT;			//! <Variable Comment="This function returns the current position of the FilePointer referenced by Handle, or -1 if it fails." Name="FileTell.retval"/>
		END_VAR;
				//! <Function Comment="This function returns the length of the file." Name="FileLength"/>
	FUNCTION __CDECL VIRTUAL GLOBAL FileLength
		VAR_INPUT
			handle 	: DINT;			//! <Variable Comment="Parameter Handle references the open file for which to get the length of it." Name="FileLength.handle"/>
		END_VAR
		VAR_OUTPUT
			retval (EAX) 	: DINT;			//! <Variable Comment="This function returns the length of the file referenced by Handle, or -1 if it fails." Name="FileLength.retval"/>
		END_VAR;
				//! <Function Comment="This function searches a directory for a file satisfying certain criteria." Name="FindFirst"/>
	FUNCTION __CDECL VIRTUAL GLOBAL FindFirst
		VAR_INPUT
			path 	: ^CHAR;			//! <Variable Comment="If a path is present, the filename must not contain any wildcard characters." Name="FindFirst.path"/>
			file 	: ^CHAR;			//! <Variable Comment="Parameter File must point to a file name, which can contain wildcard characters &apos;*&apos; and/or &apos;?&apos;, and can optionally be preceded by a path." Name="FindFirst.file"/>
			infostruct 	: ^_DDE_INFO;			//! <Variable Comment="Parameter infoStruct must point to a _DDE_INFO structure." Name="FindFirst.infostruct"/>
			atts_inkl 	: USINT;			//! <Variable Comment="Parameter atts_inkl specifies a set of file attributes a file must have to match the request. A value of zero means that there is no attribute the sought-after file must have." Name="FindFirst.atts_inkl"/>
			atts_exkl 	: USINT;			//! <Variable Comment="Parameter atts_exkl specifies a set of file attributes a file must not have to match the request. A value of zero means that there is no attribute the sought-after file must not have." Name="FindFirst.atts_exkl"/>
		END_VAR
		VAR_OUTPUT
			handle (EAX) 	: DINT;			//! <Variable Comment="If the function succeeds, this structure will be filled with the directory entry of the file found, and at least one file satisfies the search criteria and the function return value is greater than or equal to 0. The return value is a file handle, which may be passed to subsequent calls to FindNext. &#10;It is important to close the handle using FindClose when no longer needed. Failing to do so will quickly exhaust the available file handles. If the function fails, the return value is a negative error code. In this case, no handle is allocated and FindClose need not be called." Name="FindFirst.handle"/>
		END_VAR;
				//! <Function Comment="This function finds more files with the same search criteria as a preceding call to FindFirst." Name="FindNext"/>
	FUNCTION __CDECL VIRTUAL GLOBAL FindNext
		VAR_INPUT
			foundhandle 	: DINT;			//! <Variable Comment="Parameter FoundHandle must be a valid handle returned by a previous call to FindFirst." Name="FindNext.foundhandle"/>
			infostruct 	: ^_DDE_INFO;			//! <Variable Comment="Parameter InfoStruct must point to a _DDE_INFO structure." Name="FindNext.infostruct"/>
		END_VAR
		VAR_OUTPUT
			handle (EAX) 	: DINT;			//! <Variable Comment="If the function succeeds, this structure will be filled with the directory entry of the file found. &#10;If the function succeeds, the return value is 0. If the function fails or no more files are found, the return value is a negative error code." Name="FindNext.handle"/>
		END_VAR;
				//! <Function Comment="This function closes a handle created by FindFirst." Name="FindClose"/>
	FUNCTION __CDECL VIRTUAL GLOBAL FindClose
		VAR_INPUT
			handle 	: DINT;			//! <Variable Comment="Parameter Handle must be a valid handle returned by a previous call to FindFirst." Name="FindClose.handle"/>
		END_VAR
		VAR_OUTPUT
			retval (EAX) 	: DINT;			//! <Variable Comment="If the function succeeds, the return value is 0. If the function fails, the return value is a negative error code." Name="FindClose.retval"/>
		END_VAR;
				//! <Function Comment="This function creates a new directory." Name="CreateDirectory"/>
	FUNCTION __CDECL VIRTUAL GLOBAL CreateDirectory
		VAR_INPUT
			dirname 	: ^CHAR;			//! <Variable Comment="Parameter DirName must point to the name of the directory to create. The directory can have any legal file name syntax." Name="CreateDirectory.dirname"/>
		END_VAR
		VAR_OUTPUT
			retval (EAX) 	: DINT;			//! <Variable Comment="If the function succeeds, the return value is 0. If the function fails, the return value is a negative error code." Name="CreateDirectory.retval"/>
		END_VAR;
				//! <Function Comment="This function removes a directory." Name="RemoveDirectory"/>
	FUNCTION __CDECL VIRTUAL GLOBAL RemoveDirectory
		VAR_INPUT
			dirname 	: ^CHAR;			//! <Variable Comment="Parameter DirName must point to the name of the directory to be removed. The directory can have any legal file name syntax." Name="RemoveDirectory.dirname"/>
		END_VAR
		VAR_OUTPUT
			retval (EAX) 	: DINT;			//! <Variable Comment="If the function succeeds, the return value is 0. If the function fails, the return value is a negative error code." Name="RemoveDirectory.retval"/>
		END_VAR;
				//! <Function Comment="This function renames a file." Name="RenameFile_Dir"/>
	FUNCTION __CDECL VIRTUAL GLOBAL RenameFile_Dir
		VAR_INPUT
			actname 	: ^CHAR;			//! <Variable Comment="Parameter Actname must point to the name of the file to be renamed." Name="RenameFile_Dir.actname"/>
			newname 	: ^CHAR;			//! <Variable Comment="Parameter NewName points to the new name of the file. Both file names must NOT contain wildcards and must reference the same logical drive." Name="RenameFile_Dir.newname"/>
		END_VAR
		VAR_OUTPUT
			retval (EAX) 	: DINT;			//! <Variable Comment="If the function succeeds, the return value is 0. If the function fails, the return value is a negative error code." Name="RenameFile_Dir.retval"/>
		END_VAR;
				//! <Function Comment="This function closes all currently open files, and the buffers of all devices are flushed. This function also invalidates all of the FileSystem&apos;s file handles, which may be in use by the application." Name="CloseAllOpenFiles"/>
	FUNCTION __CDECL VIRTUAL GLOBAL CloseAllOpenFiles;
				//! <Function Comment="This function tries to mount all drives in the range &apos;A:&apos; to &apos;Z:&apos;." Name="GetDriveListShort"/>
	FUNCTION __CDECL VIRTUAL GLOBAL GetDriveListShort
		VAR_INPUT
			drivelist 	: ^CHAR;			//! <Variable Comment="Therefore, the parameter &apos;drivelist&apos; has to be an array of 8, at least 26 characters. Each element in the array corresponds to a drive letter. Index 0 is drive &apos;A:&apos;, index 1 is drive &apos;B:&apos; etc." Name="GetDriveListShort.drivelist"/>
		END_VAR
		VAR_OUTPUT
			retval (EAX) 	: DINT;			//! <Variable Comment="If the value of a character is 0, no drive exists. If a drive exists, bit 0 of the character is set to 1. &#10;Bit 1 = 0:  it&apos;s a floppy &#10;Bit 1 = 1:  it&apos;s a hard-disk &#10;&#10;Bits 2 to 5 contain information about the driver-type: &#10; 001   IDE &#10; 010   USB &#10; 011   CME221 &#10; 100   Smartmedia &#10; 101   User Data RAM-disk" Name="GetDriveListShort.retval"/>
		END_VAR;
				//! <Function Comment="This function tries to extend a file by &apos;size&apos; bytes by allocating consecutive clusters." Name="Extend"/>
	FUNCTION __CDECL VIRTUAL GLOBAL Extend
		VAR_INPUT
			handle 	: DINT;
			size 	: UDINT;
		END_VAR
		VAR_OUTPUT
			retval (EAX) 	: DINT;			//! <Variable Comment="If no cluster chain long enough is found, this function returns error code RTF_DISK_FULL. This means: either the file has to be fragmented or the disk is really full." Name="Extend.retval"/>
		END_VAR;
				//! <Function Comment="This function defines flags applying to all subsequent calls of functions for opening files." Name="SetDefaultOpenFlags"/>
	FUNCTION __CDECL VIRTUAL GLOBAL SetDefaultOpenFlags
		VAR_INPUT
			flags 	: DINT;
		END_VAR;
				//! <Function Comment="The asynchronous function of FileOpen." Name="FileOpen_A"/>
	FUNCTION __CDECL VIRTUAL GLOBAL FileOpen_A
		VAR_INPUT
			Async 	: DINT;			//! <Variable Comment="Async is used to decide between asynchronous or synchronous processing.&#13;&#10;0: synchronous processing&#13;&#10;&lt;&gt;0: asynchronous processing" Name="FileOpen_A.Async"/>
			filename 	: ^CHAR;			//! <Variable Comment="Parameter FileName must point to the name of the file to open/create. File names are not case sensitive, they will be converted to upper case. Also it must not contain wildcards!" Name="FileOpen_A.filename"/>
			attributes 	: UDINT;			//! <Variable Comment="The attributes can be a combination of: &#10;* ATT_READ_WRITE &#10;* ATT_READ_ONLY &#10;* ATT_OPEN_SHARED &#10;* ATT_OPEN_NO_DIR &#10;* ATT_OPEN_DIR &#10;* ATT_CREATE &#10;* ATT_CREATE_ALWAYS &#10;* ATT_COMMITTED &#10;* ATT_CACHE_DATA &#10;* ATT_LAZY_DATA&#10;&#10; For more details please read the OS Interface (-&gt; _FileSys Class -&gt; Appendix B) documentation!" Name="FileOpen_A.attributes"/>
		END_VAR
		VAR_OUTPUT
			handle (EAX) 	: DINT;			//! <Variable Comment="If asynchronous processing is activated, then the function returns a handle, which must be passed to the function GetAsyncState (parameter ID).&#13;&#10;Otherwise the return value is equivalent to the return value of the function FileDelete." Name="FileOpen_A.handle"/>
		END_VAR;
				//! <Function Comment="The asynchronous function of FileRead.&#13;&#10;Use FileRead_AV1 instead to get a signed return value. " Name="FileRead_A"/>
	FUNCTION __CDECL VIRTUAL GLOBAL FileRead_A
		VAR_INPUT
			Async 	: DINT;			//! <Variable Comment="Async is used to decide between asynchronous or synchronous processing.&#13;&#10;0: synchronous processing&#13;&#10;&lt;&gt;0: asynchronous processing" Name="FileRead_A.Async"/>
			handle 	: DINT;			//! <Variable Comment="Parameter handle references the open file from which to read." Name="FileRead_A.handle"/>
			buffer 	: pVoid;			//! <Variable Comment="Buffer specifies the address for the data to be read." Name="FileRead_A.buffer"/>
			length 	: UDINT;			//! <Variable Comment="Length specifies the number of bytes to read." Name="FileRead_A.length"/>
		END_VAR
		VAR_OUTPUT
			read (EAX) 	: UDINT;			//! <Variable Comment="If asynchronous processing is activated, then the function returns a handle, which must be passed to the function GetAsyncState (parameter ID).&#13;&#10;Otherwise the return value is equivalent to the return value of the function FileRead." Name="FileRead_A.read"/>
		END_VAR;
				//! <Function Comment="The asynchronous function of FileWrite.&#13;&#10;Use FileWrite_AV1 instead of this function." Name="FileWrite_A"/>
	FUNCTION __CDECL VIRTUAL GLOBAL FileWrite_A
		VAR_INPUT
			Async 	: DINT;			//! <Variable Comment="Async is used to decide between asynchronous or synchronous processing.&#13;&#10;0: synchronous processing&#13;&#10;&lt;&gt;0: asynchronous processing" Name="FileWrite_A.Async"/>
			handle 	: DINT;			//! <Variable Comment="Parameter handle references the open file to write to." Name="FileWrite_A.handle"/>
			buffer 	: pVoid;			//! <Variable Comment="Buffer specifies the address of the data to be written." Name="FileWrite_A.buffer"/>
			length 	: UDINT;			//! <Variable Comment="Length specifies the number of bytes to write." Name="FileWrite_A.length"/>
		END_VAR
		VAR_OUTPUT
			written (EAX) 	: DINT;			//! <Variable Comment="If asynchronous processing is activated, then the function returns a handle, which must be passed to the function GetAsyncState (parameter ID).&#13;&#10;Otherwise the return value is equivalent to the return value of the function FileWrite." Name="FileWrite_A.written"/>
		END_VAR;
				//! <Function Comment="The asynchronous function of FileClose." Name="FileClose_A"/>
	FUNCTION __CDECL VIRTUAL GLOBAL FileClose_A
		VAR_INPUT
			Async 	: DINT;			//! <Variable Comment="Async is used to decide between asynchronous or synchronous processing.&#13;&#10;0: synchronous processing&#13;&#10;&lt;&gt;0: asynchronous processing" Name="FileClose_A.Async"/>
			handle 	: DINT;			//! <Variable Comment="Parameter handle must have been assigned in a previous successful call to FileOpen." Name="FileClose_A.handle"/>
		END_VAR
		VAR_OUTPUT
			retval (EAX) 	: DINT;			//! <Variable Comment="If asynchronous processing is activated, then the function returns a handle, which must be passed to the function GetAsyncState (parameter ID).&#13;&#10;Otherwise the return value is zero." Name="FileClose_A.retval"/>
		END_VAR;
				//! <Function Comment="The asynchronous function of FileDelete." Name="FileDelete_A"/>
	FUNCTION __CDECL VIRTUAL GLOBAL FileDelete_A
		VAR_INPUT
			Async 	: DINT;			//! <Variable Comment="Async is used to decide between asynchronous or synchronous processing.&#13;&#10;0: synchronous processing&#13;&#10;&lt;&gt;0: asynchronous processing" Name="FileDelete_A.Async"/>
			filename 	: ^CHAR;			//! <Variable Comment="Parameter FileName must point to the name of the file to be deleted and may NOT contain wildcards." Name="FileDelete_A.filename"/>
		END_VAR
		VAR_OUTPUT
			retval (EAX) 	: DINT;			//! <Variable Comment="If asynchronous processing is activated, then the function returns a handle, which must be passed to the function GetAsyncState (parameter ID).&#13;&#10;Otherwise the return value is equivalent to the return value of the function FileDelete." Name="FileDelete_A.retval"/>
		END_VAR;
				//! <Function Comment="The asynchronous function of Filelseek." Name="Filelseek_A"/>
	FUNCTION __CDECL VIRTUAL GLOBAL Filelseek_A
		VAR_INPUT
			Async 	: DINT;			//! <Variable Comment="Async is used to decide between asynchronous or synchronous processing.&#13;&#10;0: synchronous processing&#13;&#10;&lt;&gt;0: asynchronous processing" Name="Filelseek_A.Async"/>
			handle 	: DINT;			//! <Variable Comment="Parameter Handle references the open file for which to reposition the file pointer." Name="Filelseek_A.handle"/>
			offset 	: UDINT;			//! <Variable Comment="Offset specifies how far the file pointer should be moved. Please note that Offset is a signed integer value." Name="Filelseek_A.offset"/>
			fromwhere 	: UDINT;			//! <Variable Comment="Parameter fromwhere specifies Offset&apos;s meaning. The following values are allowed: &#10;&#10;FILE_BEGIN(0) - Offset is an absolute file pointer &#10;                           value. &#10;FILE_CURRENT(1) - Offset should be added to &#10;                                 the current file pointer value. &#10;FILE_END(2)  - Offset should be added to the &#10;                         current file size." Name="Filelseek_A.fromwhere"/>
		END_VAR
		VAR_OUTPUT
			retval (EAX) 	: UDINT;			//! <Variable Comment="If asynchronous processing is activated, then the function returns a handle, which must be passed to the function GetAsyncState (parameter ID).&#13;&#10;Otherwise the return value is equivalent to the return value of the function Filelseek." Name="Filelseek_A.retval"/>
		END_VAR;
				//! <Function Comment="The asynchronous function of FileTell." Name="FileTell_A"/>
	FUNCTION __CDECL VIRTUAL GLOBAL FileTell_A
		VAR_INPUT
			Async 	: DINT;			//! <Variable Comment="Async is used to decide between asynchronous or synchronous processing.&#13;&#10;0: synchronous processing&#13;&#10;&lt;&gt;0: asynchronous processing" Name="FileTell_A.Async"/>
			handle 	: DINT;			//! <Variable Comment="Parameter Handle references the open file for which to get the current position of the file pointer." Name="FileTell_A.handle"/>
		END_VAR
		VAR_OUTPUT
			retval (EAX) 	: DINT;			//! <Variable Comment="If asynchronous processing is activated, then the function returns a handle, which must be passed to the function GetAsyncState (parameter ID).&#13;&#10;Otherwise the return value is equivalent to the return value of the function FileTell." Name="FileTell_A.retval"/>
		END_VAR;
				//! <Function Comment="The asynchronous function of FileLength." Name="FileLength_A"/>
	FUNCTION __CDECL VIRTUAL GLOBAL FileLength_A
		VAR_INPUT
			Async 	: DINT;			//! <Variable Comment="Async is used to decide between asynchronous or synchronous processing.&#13;&#10;0: synchronous processing&#13;&#10;&lt;&gt;0: asynchronous processing" Name="FileLength_A.Async"/>
			handle 	: DINT;			//! <Variable Comment="Parameter Handle references the open file for which to get the length of it." Name="FileLength_A.handle"/>
		END_VAR
		VAR_OUTPUT
			retval (EAX) 	: DINT;			//! <Variable Comment="If asynchronous processing is activated, then the function returns a handle, which must be passed to the function GetAsyncState (parameter ID).&#13;&#10;Otherwise the return value is equivalent to the return value of the function FileLength." Name="FileLength_A.retval"/>
		END_VAR;
				//! <Function Comment="The asynchronous function of FindFirst." Name="FindFirst_A"/>
	FUNCTION __CDECL VIRTUAL GLOBAL FindFirst_A
		VAR_INPUT
			Async 	: DINT;			//! <Variable Comment="Async is used to decide between asynchronous or synchronous processing.&#13;&#10;0: synchronous processing&#13;&#10;&lt;&gt;0: asynchronous processing" Name="FindFirst_A.Async"/>
			path 	: ^CHAR;			//! <Variable Comment="If a path is present, the filename must not contain any wildcard characters." Name="FindFirst_A.path"/>
			file 	: ^CHAR;			//! <Variable Comment="Parameter File must point to a file name, which can contain wildcard characters &apos;*&apos; and/or &apos;?&apos;, and can optionally be preceded by a path." Name="FindFirst_A.file"/>
			infostruct 	: ^_DDE_INFO;			//! <Variable Comment="Parameter infoStruct must point to a _DDE_INFO structure." Name="FindFirst_A.infostruct"/>
			atts_inkl 	: USINT;			//! <Variable Comment="Parameter atts_inkl specifies a set of file attributes a file must have to match the request. A value of zero means that there is no attribute the sought-after file must have." Name="FindFirst_A.atts_inkl"/>
			atts_exkl 	: USINT;			//! <Variable Comment="Parameter atts_exkl specifies a set of file attributes a file must not have to match the request. A value of zero means that there is no attribute the sought-after file must not have." Name="FindFirst_A.atts_exkl"/>
		END_VAR
		VAR_OUTPUT
			handle (EAX) 	: DINT;			//! <Variable Comment="If asynchronous processing is activated, then the function returns a handle, which must be passed to the function GetAsyncState (parameter ID).&#13;&#10;Otherwise the return value is equivalent to the return value of the function FindFirst." Name="FindFirst_A.handle"/>
		END_VAR;
				//! <Function Comment="The asynchronous function of FindNext." Name="FindNext_A"/>
	FUNCTION __CDECL VIRTUAL GLOBAL FindNext_A
		VAR_INPUT
			Async 	: DINT;			//! <Variable Comment="Async is used to decide between asynchronous or synchronous processing.&#13;&#10;0: synchronous processing&#13;&#10;&lt;&gt;0: asynchronous processing" Name="FindNext_A.Async"/>
			foundhandle 	: DINT;			//! <Variable Comment="Parameter FoundHandle must be a valid handle returned by a previous call to FindFirst." Name="FindNext_A.foundhandle"/>
			infostruct 	: ^_DDE_INFO;			//! <Variable Comment="Parameter InfoStruct must point to a _DDE_INFO structure." Name="FindNext_A.infostruct"/>
		END_VAR
		VAR_OUTPUT
			handle (EAX) 	: DINT;			//! <Variable Comment="If asynchronous processing is activated, then the function returns a handle, which must be passed to the function GetAsyncState (parameter ID).&#13;&#10;Otherwise the return value is equivalent to the return value of the function FindNext." Name="FindNext_A.handle"/>
		END_VAR;
				//! <Function Comment="The asynchronous function of FindClose." Name="FindClose_A"/>
	FUNCTION __CDECL VIRTUAL GLOBAL FindClose_A
		VAR_INPUT
			Async 	: DINT;			//! <Variable Comment="Async is used to decide between asynchronous or synchronous processing.&#13;&#10;0: synchronous processing&#13;&#10;&lt;&gt;0: asynchronous processing" Name="FindClose_A.Async"/>
			handle 	: DINT;			//! <Variable Comment="Parameter Handle must be a valid handle returned by a previous call to FindFirst." Name="FindClose_A.handle"/>
		END_VAR
		VAR_OUTPUT
			retval (EAX) 	: DINT;			//! <Variable Comment="If asynchronous processing is activated, then the function returns a handle, which must be passed to the function GetAsyncState (parameter ID).&#13;&#10;Otherwise the return value is equivalent to the return value of the function FindClose." Name="FindClose_A.retval"/>
		END_VAR;
				//! <Function Comment="The asynchronous function of CreateDirectory." Name="CreateDirectory_A"/>
	FUNCTION __CDECL VIRTUAL GLOBAL CreateDirectory_A
		VAR_INPUT
			Async 	: DINT;			//! <Variable Comment="Async is used to decide between asynchronous or synchronous processing.&#13;&#10;0: synchronous processing&#13;&#10;&lt;&gt;0: asynchronous processing" Name="CreateDirectory_A.Async"/>
			dirname 	: ^CHAR;			//! <Variable Comment="Parameter DirName must point to the name of the directory to create. The directory can have any legal file name syntax." Name="CreateDirectory_A.dirname"/>
		END_VAR
		VAR_OUTPUT
			retval (EAX) 	: DINT;			//! <Variable Comment="If asynchronous processing is activated, then the function returns a handle, which must be passed to the function GetAsyncState (parameter ID).&#13;&#10;Otherwise the return value is equivalent to the return value of the function CreateDirectory." Name="CreateDirectory_A.retval"/>
		END_VAR;
				//! <Function Comment="The asynchronous function of RemoveDirectory." Name="RemoveDirectory_A"/>
	FUNCTION __CDECL VIRTUAL GLOBAL RemoveDirectory_A
		VAR_INPUT
			Async 	: DINT;			//! <Variable Comment="Async is used to decide between asynchronous or synchronous processing.&#13;&#10;0: synchronous processing&#13;&#10;&lt;&gt;0: asynchronous processing" Name="RemoveDirectory_A.Async"/>
			dirname 	: ^CHAR;			//! <Variable Comment="Parameter DirName must point to the name of the directory to be removed. The directory can have any legal file name syntax." Name="RemoveDirectory_A.dirname"/>
		END_VAR
		VAR_OUTPUT
			retval (EAX) 	: DINT;			//! <Variable Comment="If asynchronous processing is activated, then the function returns a handle, which must be passed to the function GetAsyncState (parameter ID).&#13;&#10;Otherwise the return value is equivalent to the return value of the function RemoveDirectory." Name="RemoveDirectory_A.retval"/>
		END_VAR;
				//! <Function Comment="The asynchronous function of RenameFile_Dir." Name="RenameFile_Dir_A"/>
	FUNCTION __CDECL VIRTUAL GLOBAL RenameFile_Dir_A
		VAR_INPUT
			Async 	: DINT;			//! <Variable Comment="Async is used to decide between asynchronous or synchronous processing.&#13;&#10;0: synchronous processing&#13;&#10;&lt;&gt;0: asynchronous processing" Name="RenameFile_Dir_A.Async"/>
			actname 	: ^CHAR;			//! <Variable Comment="Parameter Actname must point to the name of the file to be renamed." Name="RenameFile_Dir_A.actname"/>
			newname 	: ^CHAR;			//! <Variable Comment="Parameter NewName points to the new name of the file. Both file names must NOT contain wildcards and must reference the same logical drive." Name="RenameFile_Dir_A.newname"/>
		END_VAR
		VAR_OUTPUT
			retval (EAX) 	: DINT;			//! <Variable Comment="If asynchronous processing is activated, then the function returns a handle, which must be passed to the function GetAsyncState (parameter ID).&#13;&#10;Otherwise the return value is equivalent to the return value of the function RenameFile_Dir." Name="RenameFile_Dir_A.retval"/>
		END_VAR;
				//! <Function Comment="The asynchronous function of CloseAllOpenFiles." Name="CloseAllOpenFiles_A"/>
	FUNCTION __CDECL VIRTUAL GLOBAL CloseAllOpenFiles_A
		VAR_INPUT
			Async 	: DINT;			//! <Variable Comment="Async is used to decide between asynchronous or synchronous processing.&#13;&#10;0: synchronous processing&#13;&#10;&lt;&gt;0: asynchronous processing" Name="CloseAllOpenFiles_A.Async"/>
		END_VAR
		VAR_OUTPUT
			retval (EAX) 	: DINT;			//! <Variable Comment="If asynchronous processing is activated, then the function returns a handle, which must be passed to the function GetAsyncState (parameter ID).&#13;&#10;Otherwise the return value is zero." Name="CloseAllOpenFiles_A.retval"/>
		END_VAR;
				//! <Function Comment="This function returns the state of distinct asynchronous file operation. Up to 50 file operations can be queued, each asynchronous file function returns a handle, which must be passed to this function, parameter &apos;Async&apos;." Name="GetAsyncState"/>
	FUNCTION __CDECL VIRTUAL GLOBAL GetAsyncState
		VAR_INPUT
			ID 	: UDINT;			//! <Variable Comment="Handle returned by the asynchronous functions." Name="GetAsyncState.ID"/>
			Erg 	: ^DINT;			//! <Variable Comment="Result of the asynchronous functions." Name="GetAsyncState.Erg"/>
		END_VAR
		VAR_OUTPUT
			retval (EAX) 	: DINT;			//! <Variable Comment="The return value may be: &#13;&#10;* 0                                 Operation successfully finished &#13;&#10;* RT_INVALID_ID         handle not in queue&#13;&#10;* RT_NOT_STARTED    handle in queue, operation not yet started &#13;&#10;* RT_IN_PROGRESS     handle in queue, operation in progress &#13;&#10;* RT_ERG_DELETED     handle was in queue, but result is lost, successive operations (more than 50) have overwritten the result &#10;&#10;All other values are the real return values of the completed file operation." Name="GetAsyncState.retval"/>
		END_VAR;
				//! <Function Comment="This function sets the current file size to the current file pointer position." Name="Truncate"/>
	FUNCTION __CDECL VIRTUAL GLOBAL Truncate
		VAR_INPUT
			handle 	: DINT;			//! <Variable Comment="Parameter Handle references the file to truncate." Name="Truncate.handle"/>
		END_VAR
		VAR_OUTPUT
			retval (EAX) 	: DINT;
		END_VAR;
				//! <Function Comment="The asynchronous function of Truncate." Name="Truncate_A"/>
	FUNCTION __CDECL VIRTUAL GLOBAL Truncate_A
		VAR_INPUT
			Async 	: DINT;			//! <Variable Comment="Async is used to decide between asynchronous or synchronous processing.&#13;&#10;0: synchronous processing&#13;&#10;&lt;&gt;0: asynchronous processing" Name="Truncate_A.Async"/>
			handle 	: DINT;			//! <Variable Comment="Parameter Handle references the file to truncate." Name="Truncate_A.handle"/>
		END_VAR
		VAR_OUTPUT
			retval (EAX) 	: DINT;			//! <Variable Comment="If asynchronous processing is activated, then the function returns a handle, which must be passed to the function GetAsyncState (parameter ID).&#13;&#10;Otherwise the return value is equivalent to the return value of the function Truncate." Name="Truncate_A.retval"/>
		END_VAR;
				//! <Function Comment="This function behaves like &apos;FindFirst&apos; but additionally returns the long filename. Files with a filename longer than maxlength-1 are not found." Name="FindFirstEx"/>
	FUNCTION __CDECL VIRTUAL GLOBAL FindFirstEx
		VAR_INPUT
			namepattern 	: ^CHAR;
			attr0 	: USINT;			//! <Variable Comment="Parameter attr0 specifies a set of file attributes a file must have to match the request. A value of zero means that there is no attribute the sought-after file must have." Name="FindFirstEx.attr0"/>
			attrmask 	: USINT;			//! <Variable Comment="Parameter attrmask specifies a set of file attributes a file must not have to match the request. A value of zero means that there is no attribute the sought-after file must not have." Name="FindFirstEx.attrmask"/>
			fileinfo 	: ^_DDE_INFO;
			filename 	: ^CHAR;			//! <Variable Comment="Parameter &apos;filename&apos; is the buffer for the long filename." Name="FindFirstEx.filename"/>
			maxlength 	: UDINT;			//! <Variable Comment="Parameter &apos;maxlength&apos; specifies the length of the buffer." Name="FindFirstEx.maxlength"/>
		END_VAR
		VAR_OUTPUT
			retval (EAX) 	: DINT;
		END_VAR;
				//! <Function Comment="This function behaves like &apos;FindNext&apos; but additionally returns the long filename. Files with a filename longer than maxlength-1 are not found." Name="FindNextEx"/>
	FUNCTION __CDECL VIRTUAL GLOBAL FindNextEx
		VAR_INPUT
			fhandle 	: DINT;
			fileinfo 	: ^_DDE_INFO;
			filename 	: ^CHAR;			//! <Variable Comment="Parameter &apos;filename&apos; is the buffer for the long filename." Name="FindNextEx.filename"/>
			maxlength 	: UDINT;			//! <Variable Comment="Parameter &apos;maxlength&apos; specifies the length of the buffer." Name="FindNextEx.maxlength"/>
		END_VAR
		VAR_OUTPUT
			retval (EAX) 	: DINT;
		END_VAR;
				//! <Function Comment="The asynchronous function of FindFirstEx." Name="FindFirstEx_A"/>
	FUNCTION __CDECL VIRTUAL GLOBAL FindFirstEx_A
		VAR_INPUT
			Async 	: DINT;			//! <Variable Comment="Async is used to decide between asynchronous or synchronous processing.&#13;&#10;0: synchronous processing&#13;&#10;&lt;&gt;0: asynchronous processing" Name="FindFirstEx_A.Async"/>
			namepattern 	: ^CHAR;
			attr 	: USINT;			//! <Variable Comment="Parameter attr specifies a set of file attributes a file must have to match the request. A value of zero means that there is no attribute the sought-after file must have." Name="FindFirstEx_A.attr"/>
			attrmask 	: USINT;			//! <Variable Comment="Parameter attrmask specifies a set of file attributes a file must not have to match the request. A value of zero means that there is no attribute the sought-after file must not have." Name="FindFirstEx_A.attrmask"/>
			fileinfo 	: ^_DDE_INFO;
			filename 	: ^CHAR;			//! <Variable Comment="Parameter &apos;filename&apos; is the buffer for the long filename." Name="FindFirstEx_A.filename"/>
			maxlength 	: UDINT;			//! <Variable Comment="Parameter &apos;maxlength&apos; specifies the length of the buffer." Name="FindFirstEx_A.maxlength"/>
		END_VAR
		VAR_OUTPUT
			retval (EAX) 	: DINT;			//! <Variable Comment="If asynchronous processing is activated, then the function returns a handle, which must be passed to the function GetAsyncState (parameter ID).&#13;&#10;Otherwise the return value is equivalent to the return value of the function FindFirstEx." Name="FindFirstEx_A.retval"/>
		END_VAR;
				//! <Function Comment="The asynchronous function of FindNextEx." Name="FindNextEx_A"/>
	FUNCTION __CDECL VIRTUAL GLOBAL FindNextEx_A
		VAR_INPUT
			Async 	: DINT;			//! <Variable Comment="Async is used to decide between asynchronous or synchronous processing.&#13;&#10;0: synchronous processing&#13;&#10;&lt;&gt;0: asynchronous processing" Name="FindNextEx_A.Async"/>
			fhandle 	: DINT;
			fileinfo 	: ^_DDE_INFO;
			filename 	: ^CHAR;			//! <Variable Comment="Parameter &apos;filename&apos; is the buffer for the long filename." Name="FindNextEx_A.filename"/>
			maxlength 	: UDINT;			//! <Variable Comment="Parameter &apos;maxlength&apos; specifies the length of the buffer." Name="FindNextEx_A.maxlength"/>
		END_VAR
		VAR_OUTPUT
			retval (EAX) 	: DINT;			//! <Variable Comment="If asynchronous processing is activated, then the function returns a handle, which must be passed to the function GetAsyncState (parameter ID).&#13;&#10;Otherwise the return value is equivalent to the return value of the function FindNextEx." Name="FindNextEx_A.retval"/>
		END_VAR;
				//! <Function Comment="This function returns the attributes of the file specified with parameter &apos;Filename&apos; in parameter &apos;Attributes&apos;." Name="GetAttributes"/>
	FUNCTION __CDECL VIRTUAL GLOBAL GetAttributes
		VAR_INPUT
			Filename 	: ^CHAR;
			Attributes 	: ^USINT;			//! <Variable Comment="&apos;Attributes&apos; can be any combination of RTF_ATTR_READ_ONLY, RTF_ATTR_HIDDEN, RTF_ATTR_SYSTEM, RTF_ATTR_ARCHIVE, RTF_ATTR_VOLUME and RTF_ATTR_DIR." Name="GetAttributes.Attributes"/>
		END_VAR
		VAR_OUTPUT
			retval (EAX) 	: DINT;
		END_VAR;
				//! <Function Comment="This function sets the attributes of the file specified with parameter &apos;Filename&apos; in parameter &apos;Attributes&apos;." Name="SetAttributes"/>
	FUNCTION __CDECL VIRTUAL GLOBAL SetAttributes
		VAR_INPUT
			Filename 	: ^CHAR;
			Attributes 	: USINT;			//! <Variable Comment="&apos;Attributes&apos; can be any combination of RTF_ATTR_READ_ONLY, RTF_ATTR_HIDDEN, RTF_ATTR_SYSTEM and RTF_ATTR_ARCHIVE." Name="SetAttributes.Attributes"/>
		END_VAR
		VAR_OUTPUT
			retval (EAX) 	: DINT;
		END_VAR;
				//! <Function Comment="This function returns some data about a drive &apos;Drive&apos; which can be a valid drive letter in the range from &apos;A:&apos; to &apos;Z:&apos;." Name="GetDiskSpace"/>
	FUNCTION __CDECL VIRTUAL GLOBAL GetDiskSpace
		VAR_INPUT
			Drive 	: ^CHAR;
			BytesPerSector 	: ^UDINT;			//! <Variable Comment="bytes per sector, for CD-ROM 2048, for all other drives (mostly) 512" Name="GetDiskSpace.BytesPerSector"/>
			SectorsPerCluster 	: ^UDINT;			//! <Variable Comment="number of sectors per cluster" Name="GetDiskSpace.SectorsPerCluster"/>
			TotalClusters 	: ^UDINT;			//! <Variable Comment="number of total clusters" Name="GetDiskSpace.TotalClusters"/>
			FreeClusters 	: ^UDINT;			//! <Variable Comment="number of free clusters" Name="GetDiskSpace.FreeClusters"/>
		END_VAR
		VAR_OUTPUT
			retval (EAX) 	: DINT;
		END_VAR;
				//! <Function Comment="The behavior of the FileReadV1 function is equivalent to FileRead (see above), except that the return value is of type DINT. &#10;The result must no longer be casted." Name="FileReadV1"/>
	FUNCTION __CDECL VIRTUAL GLOBAL FileReadV1
		VAR_INPUT
			handle 	: DINT;			//! <Variable Comment="Parameter Handle references the open file from which to read." Name="FileReadV1.handle"/>
			buffer 	: pVoid;			//! <Variable Comment="Buffer specifies the address for the data to be read." Name="FileReadV1.buffer"/>
			length 	: UDINT;			//! <Variable Comment="Length specifies the number of bytes to read." Name="FileReadV1.length"/>
		END_VAR
		VAR_OUTPUT
			retval (EAX) 	: DINT;			//! <Variable Comment="Reading past the end of file is not regarded as an error. &#13;&#10;If the function returns a positive value, but its less than the readsize, then probably the end of the file was encountered.&#13;&#10;If the function succeeds, the return value is the value of read bytes. &#13;&#10;If the function fails, the return value is a negative error code. For the possible &apos;Error Codes&apos;, read the _FileSys class comment." Name="FileReadV1.retval"/>
		END_VAR;
				//! <Function Comment="The asynchronous function from FileReadV1." Name="FileRead_AV1"/>
	FUNCTION __CDECL VIRTUAL GLOBAL FileRead_AV1
		VAR_INPUT
			Async 	: DINT;			//! <Variable Comment="Async is used to decide between asynchronous or synchronous processing.&#13;&#10;0: synchronous processing&#13;&#10;&lt;&gt;0: asynchronous processing" Name="FileRead_AV1.Async"/>
			handle 	: DINT;			//! <Variable Comment="Parameter handle references the open file from which to read." Name="FileRead_AV1.handle"/>
			buffer 	: pVoid;			//! <Variable Comment="Buffer specifies the address for the data to be read." Name="FileRead_AV1.buffer"/>
			length 	: UDINT;			//! <Variable Comment="Length specifies the number of bytes to read." Name="FileRead_AV1.length"/>
		END_VAR
		VAR_OUTPUT
			retval (EAX) 	: DINT;			//! <Variable Comment="If asynchronous processing is activated and the function succeeds, then the function returns a handle (positive value), &#13;&#10;which must be passed to the function GetAsyncState (parameter ID).&#13;&#10;If the function fails, the return value is a negative error code. For the possible &apos;Error Codes&apos;, read the _FileSys class comment.&#13;&#10;If synchronous processing is activated, then the return value is equivalent to the return value of the function FileRead_V1." Name="FileRead_AV1.retval"/>
		END_VAR;
				//! <Function Comment="The latest version of the asynchronous FileWrite function. Use this function instead of FileWrite_A." Name="FileWrite_AV1"/>
	FUNCTION __CDECL VIRTUAL GLOBAL FileWrite_AV1
		VAR_INPUT
			Async 	: DINT;			//! <Variable Comment="Async is used to decide between asynchronous or synchronous processing.&#13;&#10;0: synchronous processing&#13;&#10;&lt;&gt;0: asynchronous processing" Name="FileWrite_AV1.Async"/>
			handle 	: DINT;
			buffer 	: pVoid;
			length 	: UDINT;
		END_VAR
		VAR_OUTPUT
			retval (EAX) 	: DINT;
		END_VAR;
				//! <Function Comment="Same behavior as Filelseek. The type of Parameter offset and return value retval were changed from UDINT to DINT, it&apos;s not longer necessary to cast these values." Name="FilelseekV1"/>
	FUNCTION __CDECL VIRTUAL GLOBAL FilelseekV1
		VAR_INPUT
			handle 	: DINT;			//! <Variable Comment="Parameter Handle references the open file for which to reposition the file pointer." Name="FilelseekV1.handle"/>
			offset 	: DINT;			//! <Variable Comment="Offset specifies how far the file pointer should be moved. Please note that Offset is a signed integer value." Name="FilelseekV1.offset"/>
			fromwhere 	: UDINT;			//! <Variable Comment="Parameter fromwhere specifies Offset&apos;s meaning. The following values are allowed: &#10;&#10;FILE_BEGIN(0) - Offset is an absolute file pointer &#10;                           value. &#10;FILE_CURRENT(1) - Offset should be added to &#10;                                 the current file pointer value. &#10;FILE_END(2)  - Offset should be added to the &#10;                         current file size." Name="FilelseekV1.fromwhere"/>
		END_VAR
		VAR_OUTPUT
			retval (EAX) 	: DINT;			//! <Variable Comment="If the function succeeds, the return value is the new file pointer value, or, if the file pointer is larger than (2^31)-1, LONG_FILE_POS is returned. If the function fails, the return value is some other negative error code. For the possible &apos;Error Codes&apos;, read the _FileSys class comment." Name="FilelseekV1.retval"/>
		END_VAR;
				//! <Function Comment="The asynchronous function from FilelseekV1." Name="Filelseek_AV1"/>
	FUNCTION __CDECL VIRTUAL GLOBAL Filelseek_AV1
		VAR_INPUT
			Async 	: DINT;			//! <Variable Comment="Async is used to decide between asynchronous or synchronous processing.&#13;&#10;0: synchronous processing&#13;&#10;&lt;&gt;0: asynchronous processing" Name="Filelseek_AV1.Async"/>
			handle 	: DINT;			//! <Variable Comment="Parameter Handle references the open file for which to reposition the file pointer." Name="Filelseek_AV1.handle"/>
			offset 	: DINT;			//! <Variable Comment="Offset specifies how far the file pointer should be moved. Please note that Offset is a signed integer value." Name="Filelseek_AV1.offset"/>
			fromwhere 	: UDINT;			//! <Variable Comment="Parameter fromwhere specifies Offset&apos;s meaning. The following values are allowed: &#10;&#10;FILE_BEGIN(0) - Offset is an absolute file pointer &#10;                           value. &#10;FILE_CURRENT(1) - Offset should be added to &#10;                                 the current file pointer value. &#10;FILE_END(2)  - Offset should be added to the &#10;                         current file size." Name="Filelseek_AV1.fromwhere"/>
		END_VAR
		VAR_OUTPUT
			retval (EAX) 	: DINT;			//! <Variable Comment="If asynchronous processing is activated and the function succeeds, then the function returns a handle (positive value), &#13;&#10;which must be passed to the function GetAsyncState (parameter ID).&#13;&#10;If the function fails, the return value is a negative error code. For the possible &apos;Error Codes&apos;, read the _FileSys class comment.&#13;&#10;If synchronous processing is activated, then the return value is equivalent to the return value of the function Filelseek_V1." Name="Filelseek_AV1.retval"/>
		END_VAR;
				//! <Function Comment="Creates a RAM Disk." Name="CreateRAMDiskV1"/>
	FUNCTION __CDECL VIRTUAL GLOBAL CreateRAMDiskV1
		VAR_INPUT
			pRAMDiskData 	: ^USINT;			//! <Variable Comment="Pointer to an allocated memory area." Name="CreateRAMDiskV1.pRAMDiskData"/>
			udRAMDiskSize 	: UDINT;			//! <Variable Comment="Size of the allocated memory area." Name="CreateRAMDiskV1.udRAMDiskSize"/>
			pDriveLetter 	: ^USINT;			//! <Variable Comment="Pointer to receive the RAM Disk drive letter." Name="CreateRAMDiskV1.pDriveLetter"/>
		END_VAR
		VAR_OUTPUT
			dRC (EAX) 	: DINT;			//! <Variable Comment="APPL_RAMDISK_IN_USE if no RAM Disk is available One of the error codes described in the _FileSys class comment. &#10;0 on success" Name="CreateRAMDiskV1.dRC"/>
		END_VAR;
				//! <Function Comment="Destroys a RAM Disk created with CreateRAMDisk." Name="DestroyRAMDiskV1"/>
	FUNCTION __CDECL VIRTUAL GLOBAL DestroyRAMDiskV1
		VAR_INPUT
			usDriveLetter 	: USINT;			//! <Variable Comment="The driveletter of the RAM Disk to destroy." Name="DestroyRAMDiskV1.usDriveLetter"/>
		END_VAR
		VAR_OUTPUT
			dRC (EAX) 	: DINT;			//! <Variable Comment="APPL_RAMDISK_NOT_INSTALLED if the RAM Disk is not available One of the error codes described in the _FileSys class comment. &#10;0 on success" Name="DestroyRAMDiskV1.dRC"/>
		END_VAR;
				//! <Function Comment="Copies files from a given source to a given destination." Name="FileCopy"/>
	FUNCTION __CDECL VIRTUAL GLOBAL FileCopy
		VAR_INPUT
			pSource 	: ^CHAR;			//! <Variable Comment="File, Files to copy" Name="FileCopy.pSource"/>
			pDest 	: ^CHAR;			//! <Variable Comment="Destination" Name="FileCopy.pDest"/>
			udOption 	: UDINT;			//! <Variable Comment="Additional copy options" Name="FileCopy.udOption"/>
		END_VAR
		VAR_OUTPUT
			dRC (EAX) 	: DINT;			//! <Variable Comment="Return value: &#10;    0  .. no errors &#10; &lt; 0  .. error, For the possible &apos;Error Codes&apos;, read             the _FileSys class comment.  &#10; &gt; 0  .. errorcount if more than 1 file were copied" Name="FileCopy.dRC"/>
		END_VAR;
				//! <Function Comment="The asynchronous function of FileCopy." Name="FileCopy_A"/>
	FUNCTION __CDECL VIRTUAL GLOBAL FileCopy_A
		VAR_INPUT
			Async 	: DINT;			//! <Variable Comment="Async is used to decide between asynchronous or synchronous processing.&#13;&#10;0: synchronous processing&#13;&#10;&lt;&gt;0: asynchronous processing" Name="FileCopy_A.Async"/>
			pSource 	: ^CHAR;			//! <Variable Comment="File, Files to copy" Name="FileCopy_A.pSource"/>
			pDest 	: ^CHAR;			//! <Variable Comment="Destination" Name="FileCopy_A.pDest"/>
			udOption 	: UDINT;			//! <Variable Comment="Additional copy options" Name="FileCopy_A.udOption"/>
		END_VAR
		VAR_OUTPUT
			dRC (EAX) 	: DINT;			//! <Variable Comment="If asynchronous processing is activated, then the function returns a handle, which must be passed to the function GetAsyncState (parameter ID).&#13;&#10;Otherwise the return value is equivalent to the return value of the function FileCopy." Name="FileCopy_A.dRC"/>
		END_VAR;
				//! <Function Comment="Format a drive." Name="Format"/>
	FUNCTION __CDECL VIRTUAL GLOBAL Format
		VAR_INPUT
			DriveName 	: ^CHAR;			//! <Variable Comment="The drive to format." Name="Format.DriveName"/>
			MinSectorsPerCluster 	: UDINT;			//! <Variable Comment="Min Sector Size per Cluster, set 0 to use the default value." Name="Format.MinSectorsPerCluster"/>
			Callback 	: pVoid;			//! <Variable Comment="Callback function." Name="Format.Callback"/>
			Option 	: UDINT;			//! <Variable Comment="Options for format procedure, set 0 for default." Name="Format.Option"/>
			Flags 	: UDINT;			//! <Variable Comment="Flags for format, set 0 for default." Name="Format.Flags"/>
			objThisPtr 	: pVoid;			//! <Variable Comment="THIS pointer of the calling object." Name="Format.objThisPtr"/>
		END_VAR
		VAR_OUTPUT
			dRC (EAX) 	: DINT;			//! <Variable Comment="Return Values: &#10;  0   if OK" Name="Format.dRC"/>
		END_VAR;
				//! <Function Comment="Use SRamLoadV1 instead." Name="SRam_Load"/>
	FUNCTION __CDECL VIRTUAL GLOBAL SRam_Load
		VAR_INPUT
			filename 	: ^CHAR;			//! <Variable Comment="The name of the file to save the SRam image." Name="SRam_Load.filename"/>
		END_VAR
		VAR_OUTPUT
			dRC (EAX) 	: DINT;			//! <Variable Comment="Return Values: &#10;  0   if OK" Name="SRam_Load.dRC"/>
		END_VAR;
				//! <Function Comment="Save SRam image to file." Name="SRamSave"/>
	FUNCTION __CDECL VIRTUAL GLOBAL SRamSave
		VAR_INPUT
			filename 	: ^CHAR;			//! <Variable Comment="The name of the file to save the SRam image." Name="SRamSave.filename"/>
		END_VAR
		VAR_OUTPUT
			dRC (EAX) 	: DINT;			//! <Variable Comment="Return Values: &#10;  0   if OK" Name="SRamSave.dRC"/>
		END_VAR;
				//! <Function Comment="This function writes or removes a volume label to/from a drive." Name="SetVolumeLabel"/>
	FUNCTION __CDECL VIRTUAL GLOBAL SetVolumeLabel
		VAR_INPUT
			drive 	: ^CHAR;
			label 	: ^CHAR;
		END_VAR
		VAR_OUTPUT
			iRC (EAX) 	: DINT;
		END_VAR;
				//! <Function Comment="This function reads the volume label of a drive." Name="GetVolumeLabel"/>
	FUNCTION __CDECL VIRTUAL GLOBAL GetVolumeLabel
		VAR_INPUT
			drive 	: ^CHAR;
			label 	: pVoid;
		END_VAR
		VAR_OUTPUT
			iRC (EAX) 	: DINT;
		END_VAR;
				//! <Function Comment="The asynchronous function of GetDiskSpace." Name="GetDiskSpace_A"/>
	FUNCTION __CDECL VIRTUAL GLOBAL GetDiskSpace_A
		VAR_INPUT
			Async 	: DINT;			//! <Variable Comment="Async is used to decide between asynchronous or synchronous processing.&#13;&#10;0: synchronous processing&#13;&#10;&lt;&gt;0: asynchronous processing" Name="GetDiskSpace_A.Async"/>
			Drive 	: ^CHAR;
			BytesPerSector 	: ^UDINT;			//! <Variable Comment="bytes per sector, for CD-ROM 2048, for all other drives (mostly) 512" Name="GetDiskSpace_A.BytesPerSector"/>
			SectorsPerCluster 	: ^UDINT;			//! <Variable Comment="number of sectors per cluster" Name="GetDiskSpace_A.SectorsPerCluster"/>
			TotalClusters 	: ^UDINT;			//! <Variable Comment="number of total clusters" Name="GetDiskSpace_A.TotalClusters"/>
			FreeClusters 	: ^UDINT;			//! <Variable Comment="number of free clusters" Name="GetDiskSpace_A.FreeClusters"/>
		END_VAR
		VAR_OUTPUT
			retval (EAX) 	: DINT;			//! <Variable Comment="If asynchronous processing is activated, then the function returns a handle, which must be passed to the function GetAsyncState (parameter ID).&#13;&#10;Otherwise the return value is equivalent to the return value of the function GetDiskSpace." Name="GetDiskSpace_A.retval"/>
		END_VAR;
				//! <Function Comment="The asynchronous function of GetDriveListShort." Name="GetDriveListShort_A"/>
	FUNCTION __CDECL VIRTUAL GLOBAL GetDriveListShort_A
		VAR_INPUT
			Async 	: DINT;			//! <Variable Comment="Async is used to decide between asynchronous or synchronous processing.&#13;&#10;0: synchronous processing&#13;&#10;&lt;&gt;0: asynchronous processing" Name="GetDriveListShort_A.Async"/>
			drivelist 	: ^CHAR;			//! <Variable Comment="Therefore, the parameter &apos;drivelist&apos; has to be an array of 8, at least 26 characters. Each element in the array corresponds to a drive letter. Index 0 is drive &apos;A:&apos;, index 1 is drive &apos;B:&apos; etc." Name="GetDriveListShort_A.drivelist"/>
		END_VAR
		VAR_OUTPUT
			retval (EAX) 	: DINT;			//! <Variable Comment="If asynchronous processing is activated, then the function returns a handle, which must be passed to the function GetAsyncState (parameter ID).&#13;&#10;Otherwise the return value is equivalent to the return value of the function GetDriveListShort." Name="GetDriveListShort_A.retval"/>
		END_VAR;
				//! <Function Comment="This function checks and fixes file system errors on a FAT formatted logical drive." Name="CheckDisk"/>
	FUNCTION __CDECL VIRTUAL GLOBAL CheckDisk
		VAR_INPUT
			DriveName 	: ^CHAR;
			Callback 	: pVoid;
			Option 	: UDINT;
			Flags 	: UDINT;
			CheckDiskAgain 	: ^UDINT;
			Status 	: ^UDINT;
		END_VAR
		VAR_OUTPUT
			dRC (EAX) 	: DINT;
		END_VAR;
				//! <Function Comment="The asynchronous function of CheckDisk." Name="CheckDisk_A"/>
	FUNCTION __CDECL VIRTUAL GLOBAL CheckDisk_A
		VAR_INPUT
			Async 	: DINT;
			DriveName 	: ^CHAR;
			Callback 	: pVoid;
			Option 	: UDINT;
			Flags 	: UDINT;
			CheckDiskAgain 	: ^UDINT;
			Status 	: ^UDINT;
		END_VAR
		VAR_OUTPUT
			dRC (EAX) 	: DINT;
		END_VAR;
				//! <Function Comment="Get the FAT type." Name="GetFATType"/>
	FUNCTION __CDECL VIRTUAL GLOBAL GetFATType
		VAR_INPUT
			drive 	: ^CHAR;			//! <Variable Comment="The drive of which to get the FAT type." Name="GetFATType.drive"/>
			fattype 	: ^UDINT;			//! <Variable Comment="After a successful call, this variable contains the FAT type.&#13;&#10;12: The filesystem format is FAT12.&#13;&#10;16: The filesystem format is FAT16.&#13;&#10;32: The filesystem format is FAT32." Name="GetFATType.fattype"/>
		END_VAR
		VAR_OUTPUT
			iRC (EAX) 	: DINT;			//! <Variable Comment="If the function succeeded, the return value is zero.&#13;&#10;If the function fails, the return value is a negative error code. For the possible &apos;Error Codes&apos;, read the _FileSys class comment." Name="GetFATType.iRC"/>
		END_VAR;
				//! <Function Comment="Load SRam image from file." Name="SRamLoadV1"/>
	FUNCTION __CDECL VIRTUAL GLOBAL SRamLoadV1
		VAR_INPUT
			filename 	: ^CHAR;			//! <Variable Comment="The name of the file to save the SRam image." Name="SRamLoadV1.filename"/>
			cmdafterload 	: DINT;			//! <Variable Comment="Command after Load&#13;&#10;1: reboot&#13;&#10;2: run&#13;&#10;3: nothing" Name="SRamLoadV1.cmdafterload"/>
		END_VAR
		VAR_OUTPUT
			dRC (EAX) 	: DINT;			//! <Variable Comment="Return Value: ID&#13;&#10;Use GetAsyncState to check the status of the method" Name="SRamLoadV1.dRC"/>
		END_VAR;
				//! <Function Comment="Creates a new file with the given size and pattern" Name="FileCreate"/>
	FUNCTION __CDECL VIRTUAL GLOBAL FileCreate
		VAR_INPUT
			dpne 	: ^CHAR;			//! <Variable Comment="Parameter dpne (Filename) must point to the name of the file to be created and may NOT contain wildcards." Name="FileCreate.dpne"/>
			size 	: UDINT;			//! <Variable Comment="Size of the file to be created" Name="FileCreate.size"/>
			fill 	: CHAR;			//! <Variable Comment="Pattern which should be written into the file" Name="FileCreate.fill"/>
			att 	: UDINT;			//! <Variable Comment="The attributes can be a combination of: &#10;* ATT_READ_WRITE &#10;* ATT_CREATE &#10;* ATT_CREATE_ALWAYS &#10;* ATT_COMMITTED &#10;* ATT_CACHE_DATA &#10;* ATT_LAZY_DATA&#10;&#10; For more details please read the OS Interface (-&gt; _FileSys Class -&gt; Appendix B) documentation!" Name="FileCreate.att"/>
		END_VAR
		VAR_OUTPUT
			dRC (EAX) 	: DINT;			//! <Variable Comment="The following return codes are valid:&#13;&#10;&#13;&#10;No Error: 0&#13;&#10;SFR_CREATEFILE_INVALID_FPTR       -14000&#13;&#10;SFR_CREATEFILE_FILESIZE_TOO_SMALL -14001&#13;&#10;SFR_CREATEFILE_MALLOC_ERR         -14002&#13;&#10;&#13;&#10;also the standard FileOpen error codes could be returned." Name="FileCreate.dRC"/>
		END_VAR;
				//! <Function Comment="The asynchronous twin of the FileCreate method" Name="FileCreate_A"/>
	FUNCTION __CDECL VIRTUAL GLOBAL FileCreate_A
		VAR_INPUT
			Async 	: DINT;			//! <Variable Comment="Async is used to decide between asynchronous or synchronous processing.&#13;&#10;0: synchronous processing&#13;&#10;&lt;&gt;0: asynchronous processing" Name="FileCreate_A.Async"/>
			dpne 	: ^CHAR;			//! <Variable Comment="Parameter dpne (Filename) must point to the name of the file to be created and may NOT contain wildcards." Name="FileCreate_A.dpne"/>
			size 	: UDINT;			//! <Variable Comment="Size of the file to be created" Name="FileCreate_A.size"/>
			fill 	: CHAR;			//! <Variable Comment="Pattern which should be written into the file" Name="FileCreate_A.fill"/>
			att 	: UDINT;			//! <Variable Comment="The attributes can be a combination of: &#10;* ATT_READ_WRITE &#10;* ATT_CREATE &#10;* ATT_CREATE_ALWAYS &#10;* ATT_COMMITTED &#10;* ATT_CACHE_DATA &#10;* ATT_LAZY_DATA&#10;&#10; For more details please read the OS Interface (-&gt; _FileSys Class -&gt; Appendix B) documentation!" Name="FileCreate_A.att"/>
		END_VAR
		VAR_OUTPUT
			retval (EAX) 	: DINT;			//! <Variable Comment="If asynchronous processing is activated, then the function returns a handle, which must be passed to the function GetAsyncState (parameter ID).&#13;&#10;Otherwise the return value is equivalent to the return value of the function FileCreate." Name="FileCreate_A.retval"/>
		END_VAR;
				//! <Function Comment="Splits a filename string into 2 separate strings. If you have &quot;filename.ext&quot; you will receive &quot;filename&quot; and &quot;ext&quot;." Name="SplitNameExtension"/>
	FUNCTION __CDECL VIRTUAL GLOBAL SplitNameExtension
		VAR_INPUT
			pNameExtension 	: ^CHAR;			//! <Variable Comment="Pointer to the filename. Example &quot;filename.ext&quot;" Name="SplitNameExtension.pNameExtension"/>
			pName 	: ^CHAR;			//! <Variable Comment="Pointer to free memory for &quot;filename&quot;." Name="SplitNameExtension.pName"/>
			MaxLenName 	: UDINT;			//! <Variable Comment="Length of the &quot;filename&quot; memory." Name="SplitNameExtension.MaxLenName"/>
			pExtension 	: ^CHAR;			//! <Variable Comment="Pointer to free memory for &quot;ext&quot;." Name="SplitNameExtension.pExtension"/>
			MaxLenExtension 	: UDINT;			//! <Variable Comment="Length of free memory for &quot;ext&quot;." Name="SplitNameExtension.MaxLenExtension"/>
		END_VAR
		VAR_OUTPUT
			retcode (EAX) 	: DINT;			//! <Variable Comment="SNE_ERR_NOERROR                 0x0&#13;&#10;&#13;&#10;SNE_ERR_NULLPTR                 -1000&#13;&#10;SNE_ERR_FILENAMEGT256           -1001&#13;&#10;SNE_ERR_NOFILENAME              -1002&#13;&#10;SNE_ERR_FILENAMEFIELD_TOO_SMALL -1003&#13;&#10;SNE_ERR_EXTFIELD_TOO_SMALL      -1004&#13;&#10;SNE_ERR_SIZEZERONOTALLOWED      -1005&#13;&#10;SNE_INFO_EXTNOTSET              -1006&#13;&#10;SNE_NOT_IMPLEMENTED             -1007" Name="SplitNameExtension.retcode"/>
		END_VAR;
				//! <Function Comment="This function removes a directory (including files and subfolders).&#13;&#10;This method is supported since LASALOS v01.03.015." Name="RemoveDirectory_Full"/>
	FUNCTION __CDECL VIRTUAL GLOBAL RemoveDirectory_Full
		VAR_INPUT
			DirName 	: ^CHAR;			//! <Variable Comment="Parameter DirName must point to the name of the directory to be removed. The directory can have any legal file name syntax." Name="RemoveDirectory_Full.DirName"/>
		END_VAR
		VAR_OUTPUT
			RetVal (EAX) 	: DINT;			//! <Variable Comment="If the function succeeds, the return value is 0. If the function fails, the return value is a negative error code." Name="RemoveDirectory_Full.RetVal"/>
		END_VAR;
				//! <Function Comment="The asynchronous function of RemoveDirectory_Full.&#13;&#10;This method is supported since LASALOS v01.03.015." Name="RemoveDirectory_Full_A"/>
	FUNCTION __CDECL VIRTUAL GLOBAL RemoveDirectory_Full_A
		VAR_INPUT
			Async 	: DINT;			//! <Variable Comment="Async is used to decide between asynchronous or synchronous processing.&#13;&#10;0: synchronous processing&#13;&#10;&lt;&gt;0: asynchronous processing" Name="RemoveDirectory_Full_A.Async"/>
			DirName 	: ^CHAR;			//! <Variable Comment="Parameter DirName must point to the name of the directory to be removed. The directory can have any legal file name syntax." Name="RemoveDirectory_Full_A.DirName"/>
		END_VAR
		VAR_OUTPUT
			RetVal (EAX) 	: DINT;			//! <Variable Comment="If asynchronous processing is activated, then the function returns a handle, which must be passed to the function GetAsyncState (parameter ID).&#13;&#10;Otherwise the return value is equivalent to the return value of the function RemoveDirectory." Name="RemoveDirectory_Full_A.RetVal"/>
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

//}}LSL_DECLARATION


FUNCTION GLOBAL TAB _FileSys::@CT_
0$UINT,
2#0100000000001000$UINT, //TY__FILESYS
1$UINT, 19$UINT, (SIZEOF(::_FileSys))$UINT, 
1$UINT, 0$UINT, 0$UINT, 
TO_UDINT(545279513), "_FileSys", //Class
TO_UDINT(0), 0, 0$UINT, 0$UINT, //Baseclass
//Servers:
(::_FileSys.Server0.pMeth)$UINT, _CH_CMD$UINT, 2#0000000000000000$UINT, TO_UDINT(2759080719), "Server0", 
//Clients:
END_FUNCTION


#define USER_CNT__FileSys 68

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT__FileSys] OF ^Void;
	END_STRUCT;
END_TYPE



//{{LSL_IMPLEMENTATION


//*********************Inserted from .\code\_FileSys_00_00.st*********************



 



#include <Rtos_interfaces.h> // we need this for the SysCIL functions
#include "..\..\Source\code\OsiBaseNew.h"



// Dummy Functions, if OS is too old
#pragma warning (disable:73)

FUNCTION __CDECL DummyVolumeLabel
VAR_INPUT
	param1	: ^CHAR;
	param2	: ^CHAR;
END_VAR
VAR_OUTPUT
	ret1	: DINT;
END_VAR

	TRACE("ERROR: Function not available with this version/platform!");

	ret1 := 0;

END_FUNCTION
FUNCTION __CDECL DummyGetFATType
VAR_INPUT
	param1	: ^CHAR;
  param2  : ^UDINT;
END_VAR
VAR_OUTPUT
	ret1	: DINT;
END_VAR

	TRACE("ERROR: Function not available with this version/platform!");

	ret1 := 0;

END_FUNCTION
FUNCTION __CDECL DummySRamLoadV1
VAR_INPUT
	param1 	: ^CHAR;
	param2 	: DINT;
END_VAR
VAR_OUTPUT
	ret1 	: DINT;
END_VAR
  
	TRACE("ERROR: Function not available with this version/platform! OS >= 01.02.086 required");

	ret1 := 0;

END_FUNCTION
FUNCTION __CDECL DummySRamLoad
VAR_INPUT
	param1 	: ^CHAR;
END_VAR
VAR_OUTPUT
	ret1 	: DINT;
END_VAR
  
	TRACE("ERROR: Function not available with this version/platform! Use SRamLoadV1");

	ret1 := 0;

END_FUNCTION

#pragma warning (default:73)

FUNCTION __CDECL DummyFileCreate
#pragma warning (disable:73)
	VAR_INPUT
		dpne 	: ^CHAR;
		size 	: UDINT;
		fill 	: CHAR;
		att 	: UDINT;
	END_VAR
	VAR_OUTPUT
		dRC 	: DINT;
	END_VAR
#pragma warning (default:73)

  TRACE("ERROR: Function not available with this version/platform! OS >= 01.02.195 required");

	dRC := 0;

END_FUNCTION


FUNCTION __CDECL DummyFileCreate_A
#pragma warning (disable:73)
	VAR_INPUT
		Async 	: DINT;
		dpne 	: DINT;
		size 	: DINT;
		fill 	: DINT;
		att 	: DINT;
	END_VAR
	VAR_OUTPUT
		retval 	: DINT;
	END_VAR
#pragma warning (default:73)

  TRACE("ERROR: Function not available with this version/platform! OS >= 01.02.195 required");

	retval := 0;

END_FUNCTION


FUNCTION __CDECL DummySplitNameExtensionToNameAndExtension
#pragma warning (disable:73)
	VAR_INPUT
		pNameExtension 	: ^CHAR;
		pName 	: ^CHAR;
		MaxLenName 	: UDINT;
		pExtension 	: ^CHAR;
		MaxLenExtension 	: UDINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: DINT;
	END_VAR
#pragma warning (default:73)


  TRACE("ERROR: Function not available with this version/platform! OS >= 01.02.224 required");

	retcode := -1007;

END_FUNCTION

FUNCTION __CDECL DummyRemoveDirectory_Full
#pragma warning (disable:73)
	VAR_INPUT
		DirName 	: ^CHAR;			
	END_VAR
	VAR_OUTPUT
		dRC 	: DINT;			
	END_VAR
	
	#pragma warning (default:73)
  TRACE("ERROR: Function not available with this version/platform! OS >= 01.03.015 or OS >= 09.01.190 or OS >= 09.03.010 required");

	dRC := -1007;
END_FUNCTION
			
FUNCTION __CDECL DummyRemoveDirectory_Full_A
#pragma warning (disable:73)
	VAR_INPUT
		Async 	: DINT;			
		DirName 	: ^CHAR;			
	END_VAR
	VAR_OUTPUT
		dRC 	: DINT;			
	END_VAR
		
	#pragma warning (default:73)
  TRACE("ERROR: Function not available with this version/platform! OS >= 01.03.015 or OS >= 09.01.190 or OS >= 09.03.010 required");

	dRC := -1007;
END_FUNCTION

FUNCTION  _FileSys::_FileSys
VAR_OUTPUT
	ret_code		: CONFSTATES;
END_VAR
VAR
    pFile   : ^OS_FILE;
	aMeths	: ARRAY[0..USER_CNT__FileSys + 2] OF ^void; // +2: FilelseekV1, Filelseek_AV1
	retv    : SYS_ERROR;
END_VAR;

	retv := OS_CILGet("OS_FILE", #pFile$void);

	if retv <> SYS_ERR_NONE then

		TRACE("ERROR: FILE-Handling Interface not available with this version/platform!");
		ret_code	:= C_UNKNOWN_CONSTR;
    else

		aMeths [0]	:= pFile^.FileOpenX;
		aMeths [1]	:= pFile^.FileRead;
		aMeths [2]	:= pFile^.FileWriteX;
		aMeths [3]	:= pFile^.FileClose;
		aMeths [4]	:= pFile^.FileDel;
		aMeths [5]	:= pFile^.Filelseek;
		aMeths [6]	:= pFile^.Filetell;
		aMeths [7]	:= pFile^.Filelength;
		aMeths [8]	:= pFile^.FindFirst;
		aMeths [9]	:= pFile^.FindNext;
		aMeths [10]	:= pFile^.FindClose;
		aMeths [11]	:= pFile^.CreateDir;
		aMeths [12]	:= pFile^.RemoveDir;
		aMeths [13]	:= pFile^.Rename;
		aMeths [14]	:= pFile^.CloseAllOpenFiles;

		aMeths [15]	:= pFile^.GetDriveListShort;
		aMeths [16]	:= pFile^.Extend;
		aMeths [17]	:= pFile^.SetDefaultOpenFlags;

		aMeths [18]	:= pFile^.FileOpen_A;
		aMeths [19]	:= pFile^.FileRead_A;
		aMeths [20]	:= pFile^.FileWrite_A;
		aMeths [21]	:= pFile^.FileClose_A;
		aMeths [22]	:= pFile^.FileDel_A;
		aMeths [23]	:= pFile^.Filelseek_A;
		aMeths [24]	:= pFile^.Filetell_A;
		aMeths [25]	:= pFile^.Filelength_A;
		aMeths [26]	:= pFile^.FindFirst_A;
		aMeths [27]	:= pFile^.FindNext_A;
		aMeths [28]	:= pFile^.FindClose_A;
		aMeths [29]	:= pFile^.CreateDir_A;
		aMeths [30]	:= pFile^.RemoveDir_A;
		aMeths [31]	:= pFile^.Rename_A;
		aMeths [32]	:= pFile^.CloseAllOpenFiles_A;
		aMeths [33]	:= pFile^.GetAsyncState;
		aMeths [34]	:= pFile^.Truncate;
		aMeths [35]	:= pFile^.Truncate_A;
		aMeths [36]	:= pFile^.FindFirstEx;
		aMeths [37]	:= pFile^.FindNextEx;
		aMeths [38]	:= pFile^.FindFirstEx_A;
		aMeths [39]	:= pFile^.FindNextEx_A;
		aMeths [40]	:= pFile^.GetAttributes;
		aMeths [41]	:= pFile^.SetAttributes;
		aMeths [42]	:= pFile^.GetDiskSpace;
		aMeths [43] := pFile^.FileReadV1;
		aMeths [44] := pFile^.FileRead_AV1;
		aMeths [45] := pFile^.FileWrite_AV1;

		// FilelseekV1, Filelseek_AV1: OS Funktion ok nur der bergabeparameter offset war der falsche Typ
		aMeths [46] := pFile^.Filelseek;
		aMeths [47] := pFile^.Filelseek_A;

		aMeths [48] := pFile^.CreateRAMDisk;
		aMeths [49] := pFile^.DestroyRAMDisk;
		aMeths [50] := pFile^.FileCopy;
		aMeths [51] := pFile^.FileCopy_A;

		aMeths [52] := pFile^.FormatDrive;

		if _RtOSversion >= 16#1256 then			// requires >= 01.02.086
      aMeths [53] := #DummySRamLoad();
		else
      aMeths [53] := pFile^.SRam_Load;
		end_if;
    
		aMeths [54] := pFile^.SRamSave;

		if _RtOSversion >= 16#122d then			// requires >= 01.02.045
      aMeths [55] := pFile^.SetVolumeLabel;
      aMeths [56] := pFile^.GetVolumeLabel;
 		else
		  aMeths [55] := #DummyVolumeLabel();
		  aMeths [56] := #DummyVolumeLabel();
		end_if;
     
		aMeths [57] := pFile^.GetDiskSpace_A;
		aMeths [58] := pFile^.GetDriveListShort_A;
		aMeths [59] := pFile^.CheckDisk;
		aMeths [60] := pFile^.CheckDisk_A;

		if _RtOSversion >= 16#1246 then			// requires >= 01.02.070
      aMeths [61] := pFile^.GetFATType;
		else
		  aMeths [61] := #DummyGetFATType();
		end_if;
    
		if _RtOSversion >= 16#1256 then			// requires >= 01.02.086
      aMeths [62] := pFile^.SRamLoadV1;
		else
		  aMeths [62] := #DummySRamLoadV1();
		end_if;
    
    if _RtOSVersion >= 16#12C2 then         // requires >= 01.02.194
      aMeths [63] := pFile^.FileCreate;
      aMeths [64] := pFile^.FileCreate_A;
    else
      aMeths [63] := #DummyFileCreate();
      aMeths [64] := #DummyFileCreate_A();
    end_if;
    
    if _RtOSVersion >= 16#12E0 then
      aMeths [65] := pFile^.SplitNameExtension;
    else
      aMeths [65] := #DummySplitNameExtensionToNameAndExtension();
    end_if;
    
    //Methods supported by RTK version >= 01.03.015, Salamander version >= 09.01.190 and >= 09.03.010
    if(_RtOSVersion < 16#9000) & (_RtOSVersion >= 16#130E) |
      (_RtOSVersion >= 16#91BE) & (_RtOSVersion < 16#9300) |
      (_RtOSVersion >= 16#930A) then
      if pFile^.RemoveDirectory_Full & pFile^.RemoveDirectory_Full_A then
        aMeths [66] := pFile^.RemoveDirectory_Full;
        aMeths [67] := pFile^.RemoveDirectory_Full_A;      
      else
        aMeths [66] := #DummyRemoveDirectory_Full();
        aMeths [67] := #DummyRemoveDirectory_Full_A();      
      end_if;

    else
      aMeths [66] := #DummyRemoveDirectory_Full();
      aMeths [67] := #DummyRemoveDirectory_Full_A();
    end_if;
    
    
		ret_code  := InitOsiM_new(#aMeths[0]$void, USER_CNT__FileSys);
	end_if;
  

END_FUNCTION //  _FileSys::_FileSys