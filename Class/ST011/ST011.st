//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)

//{{LSL_DEFINES
#define DEVICE_ID_ST011 1052
#define ST011_MINIMAL_PULSEWIDTH 16#003C


#define ST011_ADDR_PDO_WRITE    16#001F
#define ST011_ADDR_SDO_WRITE_1  16#0025
#define ST011_ADDR_PDO_READ     16#0037
#define ST011_ADDR_SDO_WRITE_2  16#0042


#define ST011_FPGAVersion_PulsCntCorrect 16#12

// in MHz
#define ST011_FREQUENCY_MHZ 125

// in Hz
#define ST011_FREQUENCY_HZ (ST011_FREQUENCY_MHZ * 1000000)


#define ST011_SDO_RESPONSE_TIMEOUT  SDIAS_SDO_TIMEOUT * 2
//}}LSL_DEFINES

//{{LSL_DECLARATION

(*!
<Class
	Name               = "ST011"
	Revision           = "1.11"
	GUID               = "{5309A48A-6099-4044-81C4-B0F4F87CFBB9}"
	RealtimeTask       = "false"
	CyclicTask         = "false"
	BackgroundTask     = "false"
	Sigmatek           = "true"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	IconPath           = ".\Class\s-dias.ico"
	SharedCommandTable = "true"
	Objectsize         = "(600,1440)"
	Comment            = "SDIAS Stepper Module (1x Incremental Encoder Input,&#13;&#10;1x Motor Out, 2x Digital Out 24V, 2x Digital In 24V)">
	<Channels>
		<Server Name="ClockCounter" GUID="{4A34D774-0940-4694-B7B5-D7277DA2D795}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="motor 1 counts the issued steps"/>
		<Server Name="ClockCounterLatched" GUID="{A52A889A-DF59-4270-9CC0-861F30BB263A}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="actual Latch-Value of the Clock Counter."/>
		<Server Name="Enable" GUID="{3450CE4D-2989-4008-9263-76D88DAB0BBC}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false" Comment="motor 1 enable servo"/>
		<Server Name="Encoder" GUID="{2ED885BA-C3CC-4379-A678-A6282CE19822}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="motor 1 number of edges"/>
		<Server Name="EncoderLatched" GUID="{8FF59F38-4DC1-41CA-8C05-3D0A1EBF15E8}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="actual Latch-Value of the Incremental Encoder."/>
		<Server Name="FreqOut" GUID="{FAA2F976-DB25-412D-9B3B-F8E6FFE01071}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false" Comment="motor out frequency in Hz. Can be positive and negative"/>
		<Server Name="Input1" GUID="{E439BB09-9405-420E-B94B-0CE072EEB981}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Digital Input 1"/>
		<Server Name="Input1Latched" GUID="{1822937C-06DD-4DF3-A5EB-92D76EE3FDC4}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="1 = input has been latched &#13;&#10;(is reset when read() method is called)"/>
		<Server Name="Input2" GUID="{1F5B16F3-2EBF-4F2D-8541-0702F6D671FA}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Digital Input 2"/>
		<Server Name="Input2Latched" GUID="{B2809604-36E7-41D4-92E7-D9D3B1E822FC}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="1 = input has been latched &#13;&#10;(is reset when read() method is called)"/>
		<Server Name="Input3" GUID="{0CCD75F5-12DD-4CCB-985E-C494D28866BE}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Feedback Input of Output2."/>
		<Server Name="Input3Latched" GUID="{98BF4EDC-FE72-43FC-986C-C91031EFC20E}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="1 = input has been latched &#13;&#10;(is reset when read() method is called)"/>
		<Server Name="Output1" GUID="{78DF941B-29DF-4BF7-9401-5D4F204CC7CE}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false" Comment="Digital Output 1."/>
		<Server Name="Output2" GUID="{4081431B-CD14-4E99-8118-A9C8838A9B71}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false" Comment="Digital Output 2."/>
		<Server Name="VoltageOk24V" GUID="{82F755EC-4E0E-4039-A1DF-DD0543213549}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Shows state of the 24V voltage supply &#13;&#10;0 .. OK&#13;&#10;1 .. Error at power supply."/>
		<Server Name="VoltageOKEncoder" GUID="{3E83764F-D891-4F3A-80CF-EA070BD4897F}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Shows state of voltage supply of encoder&#13;&#10;0 .. OK&#13;&#10;1 .. Error at power supply."/>
		<Server Name="ZPuls" GUID="{A5FF402F-CC53-4A7F-868D-28F8B08DAFE7}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="is 1 if its incremantal encoder zero position"/>
		<Server Name="ZPulsLatched" GUID="{BBBB6749-F344-4F33-9DA8-8D00C17BCF10}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="is 1 if incremental zero position is passed, a read resets the server"/>
		<Client Name="Deathtime" Required="false" Internal="false" DefValue="60" Comment="Minimal output pulse width in clock counts&#13;&#10;&#13;&#10;If MinPulseWidth is set, the value of this Client will be ignored.&#13;&#10;&#13;&#10;defines the minimal high or low time of the output signal. &#13;&#10;The value must be set as init value&#13;&#10;&#13;&#10;60 is the lowest allowed value&#13;&#10;&#13;&#10;ATTENTION: does not be lower than Period-3, otherwise the component doesn&apos;t work proper"/>
		<Client Name="EncoderSampling" Required="false" Internal="false" Comment="Sampling of the Incremental Encoder.&#13;&#10;0 .. Encoder off&#13;&#10;1 .. 1-edge (rising edge)&#13;&#10;2 .. 2-edge&#13;&#10;3 .. 4-edge&#13;&#10;4 .. 1-edge(falling edge)&#13;&#10;"/>
		<Client Name="Input1Latch" Required="false" Internal="false" DefValue="0" Comment="The digital input latches the incremental encoder value&#13;&#10;0..not active&#13;&#10;1..rising edge&#13;&#10;2..falling edge&#13;&#10;3..both edges&#13;&#10;Note: The signals are connected via an OR gate.&#13;&#10;Every configured input latches the encoder value."/>
		<Client Name="Input2Latch" Required="false" Internal="false" DefValue="0" Comment="The digital input latches the incremental encoder value&#13;&#10;0..not active&#13;&#10;1..rising edge&#13;&#10;2..falling edge&#13;&#10;3..both edges&#13;&#10;Note: The signals are connected via an OR gate.&#13;&#10;Every configured input latches the encoder value."/>
		<Client Name="Input3Latch" Required="false" Internal="false" DefValue="0" Comment="The digital input latches the incremental encoder value&#13;&#10;0..not active&#13;&#10;1..rising edge&#13;&#10;2..falling edge&#13;&#10;3..both edges&#13;&#10;Note: The signals are connected via an OR gate.&#13;&#10;Every configured input latches the encoder value."/>
		<Client Name="InvertEnable" Required="false" Internal="false" DefValue="0" Comment="Invert the output signal for the enable. (Server Enable must always be 1 to enable)&#13;&#10;0 = standard&#13;&#10;1 = inverted (If Server Enable = 0 the output is high, if Enable = 1 the output is low)"/>
		<Client Name="InvertEncoder" Required="false" Internal="false" Comment="This client can be used to invert Phase B of incremental encoder&#13;&#10;0 .. Phase B non-inverted&#13;&#10;1 .. Phase B inverted"/>
		<Client Name="LatchClockCounter" Required="false" Internal="false" Comment="writes the latched value"/>
		<Client Name="LatchEncoder" Required="false" Internal="false" Comment="writes the latched value"/>
		<Client Name="MinPulseWidth" Required="false" Internal="false" Comment="Minimal pulse width in ns&#13;&#10;&#13;&#10;If this client is set, the value of DeathTime will be ignored"/>
		<Client Name="ModeClockCounter" Required="false" Internal="false" Comment="to count only steps and not edges: 0=count edges | 1=count steps (for Pulse Mode 1 and 3) | 2=count steps (for PulseMode 0,2)"/>
		<Client Name="PulseMode" Required="false" Internal="false" Comment="0 or 2 .. 2-phase pulse with 90° phase difference&#13;&#10;1 .. CW/CCW pulse command mode&#13;&#10;3 .. Pulse/Sign Command mode"/>
		<Client Name="UsePulseCntCorrection" Required="false" Internal="false" DefValue="0" Comment="Xilinx version 1.2&#13;&#10;0 = Old Pulse count Mode&#13;&#10;1 = Corrected Pulse count Mode"/>
		<Client Name="ZPulseLatch" Required="false" Internal="false" DefValue="0" Comment="The Z-Pulse latches the incremental encoder value&#13;&#10;0..not active&#13;&#10;1..rising edge&#13;&#10;2..falling edge&#13;&#10;3..both edges&#13;&#10;Note: The signals are connected via an OR gate.&#13;&#10;Every configured input latches the encoder value."/>
	</Channels>
	<RevDoku>
		<Owner Company="Sigmatek" Author="EisMic"/>
		<Dokumentation Revision="1.11" Date="08.06.2018" Author="RamAnd" Company="Sigmatek" Description="LASAL Hardware Description (.lhd) file has been updated."/>
		<Dokumentation Revision="1.10" Date="23.01.2018" Author="RamAnd" Company="Sigmatek" Description="Log messages have been standardized for easier maintenance, easier use in any class and to allow spam filtering. Code for the logging functions is now only located in HwControl."/>
		<Dokumentation Revision="1.9" Date="16.05.2017" Author="RamAnd" Company="Sigmatek" Description="When adding an SDO (i.e. via ReadSPIData) from background priority it was possible that the adding process got interrupted by receiving the answer to this SDO which is handled in cyclic priority. In the error case the answer was unexpected and therefore ignored. Then the class signals a timeout while waiting for the answer, which already arrived before waiting for it. Added mutex and changed instruction order to prevent this error."/>
		<Dokumentation Revision="1.8" Date="14.02.2017" Author="BerSte1&#13;&#10;RamAnd" Company="Sigmatek" Description="Added PulseCntCorrection, Added EncoderSampling Mode 4&#13;&#10;Added MinPulsWidth"/>
		<Dokumentation Revision="1.7" Date="01.09.2016" Author="ZoePat" Company="Sigmatek" Description="The settings for Latch=2 now works also with compiler version &gt;= C29."/>
		<Dokumentation Revision="1.6" Date="12.07.2016" Author="SeiChr" Company="Sigmatek" Description="Added Values for the total Current calculation. SA 31571"/>
		<Dokumentation Revision="1.5" Date="01.03.2016" Author="EisMic" Company="Sigmatek" Description="Corrected BoundExceed Error in base class at Write method of LEDControl Server when Place = LSL_DEACTIVATED."/>
		<Dokumentation Revision="1.4" Date="09.07.2015" Author="PieSte" Company="Sigmatek" Description="Corrected cast for pointer in methode UpdateRtPostScan()."/>
		<Dokumentation Revision="1.3" Date="17.06.2015" Author="EisMic" Company="Sigmatek" Description="The servers FPGAVersion, SerialNo, Device ID and status and input servers are now not reset anymore when the module is disconnected."/>
		<Dokumentation Revision="1.2" Date="16.04.2015" Author="EisMic&#13;&#10;LanSte" Company="Sigmatek" Description="Added support for visualisation in graphical hardware editor.&#13;&#10;Added support for calculating resources for graphical hardware editor."/>
		<Dokumentation Revision="1.1" Date="17.03.2015" Author="RamAnd" Company="Sigmatek" Description="Added HW Version for sdias clients."/>
		<Dokumentation Revision="1.0" Date="23.01.2015" Author="EisMic" Company="Sigmatek" Description="Initial Version."/>
	</RevDoku>
	<Network Name="ST011">
		<!-- List of Components in this network -->
		<Components>
			<Object
				Name       = "_base"
				GUID       = "{401D0091-F8EA-49A5-8ACD-E46868826AF4}"
				Class      = "SdiasBase"
				Position   = "(218,120)"
				Visualized = "true">
				<Channels>
					<Server Name="ClassState"/>
					<Server Name="DeviceID"/>
					<Server Name="FPGAVersion"/>
					<Server Name="HwVersion"/>
					<Server Name="LEDControl" Value="0"/>
					<Server Name="RetryCounter"/>
					<Server Name="SDOState"/>
					<Server Name="SerialNo"/>
					<Client Name="Place" Value="0"/>
					<Client Name="Required" Value="1"/>
					<Client Name="SdiasIn"/>
					<Client Name="ToStdLib"/>
				</Channels>
			</Object>
		</Components>
		<Comments>
		</Comments>
		<!-- List of Connections in this network -->
		<Connections>
			<Connection Source="this.ClassState" Destination="_base.ClassState" Vertices="(804,210),(632,210),"/>
			<Connection Source="this.DeviceID" Destination="_base.DeviceID" Vertices="(804,270),(632,270),"/>
			<Connection Source="this.FPGAVersion" Destination="_base.FPGAVersion" Vertices="(804,330),(632,330),"/>
			<Connection Source="this.SerialNo" Destination="_base.SerialNo" Vertices="(804,450),(632,450),"/>
			<Connection Source="this.RetryCounter" Destination="_base.RetryCounter" Vertices="(804,510),(632,510),"/>
			<Connection Source="this.LEDControl" Destination="_base.LEDControl" Vertices="(804,570),(632,570),"/>
			<Connection Source="_base.SdiasIn" Destination="this.SdiasIn" Vertices="(218,210),(38,210),"/>
			<Connection Source="_base.Place" Destination="this.Place" Vertices="(218,270),(38,270),"/>
			<Connection Source="_base.Required" Destination="this.Required" Vertices="(218,330),(38,330),"/>
			<Connection Source="this.HwVersion" Destination="_base.HwVersion" Vertices="(804,390),(632,390),"/>
		</Connections>
		<!-- Headerfiles -->
		<Options>
		</Options>
	</Network>
</Class>
*)
#pragma using SdiasBase

ST011 : CLASS
: SdiasBase
	TYPE
	  t_e_InitSSW :
	  (
	    _InitVariables,
	    _ConfigSDO1,
	    _ConfigSDO2,
	    _Finish,
	    _InitError
	  )$UDINT;
	  t_ResponseState :
	  (
	    _idle,
	    _wait,
	    _valid
	  )$UDINT;
#pragma pack(push, 1)
	  t_s_ConfigWrite1 : STRUCT
	    ServoControlRegister : BSINT
	    [
	    ];
	    MinPulsWidth : UINT;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_s_ConfigWrite2 : STRUCT
	    LatchEnableRising : BSINT
	    [
	      1 Input1Rising,
	      2 Input2Rising,
	      3 Input3Rising,
	      4 ZPulseRising,
	    ];
	    LatchEnableFalling : BSINT
	    [
	      1 Input1Falling,
	      2 Input2Falling,
	      3 Input3Falling,
	      4 ZPulseFalling,
	    ];
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_s_ReadData : STRUCT
	    ServoStateRegister1 : BSINT
	    [
	      2 Enable,
	      3 Boost,
	      5 IncEncoderZeroPos,
	      6 IncEncoderZeroPosLatched,
	    ];
	    CounterIncremental : UINT;
	    PulseCounter16Bit : INT;
	    CounterIncrementalSaved : UINT;
	    PulseCounter16BitLatched : INT;
	    DigitalInputStateRegister1 : BSINT
	    [
	      1 Input1,
	      2 Input2,
	      3 FeedBackOutput3,
	      7 VoltageOK24V,
	      8 VoltageOK5V,
	    ];
	    LatchSourceRegister : BSINT
	    [
	      1 DigIn1Latched,
	      2 DigIn2Latched,
	      3 DigIn3Latched,
	    ];
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_s_WriteData : STRUCT
	    OutputRegister : USINT;
	    ServoOutputPulseTime : DINT;
	    ServoControlReg : USINT;
	  END_STRUCT;
#pragma pack(pop)
	END_TYPE
  //Servers:
	FreqOut 	: SvrChCmd_DINT;
	Encoder 	: SvrCh_DINT;
	EncoderLatched 	: SvrCh_DINT;
	ClockCounter 	: SvrCh_DINT;
	ClockCounterLatched 	: SvrCh_DINT;
	Enable 	: SvrCh_DINT;
	ZPuls 	: SvrCh_DINT;
	ZPulsLatched 	: SvrCh_DINT;
	Input1 	: SvrCh_DINT;
	Input1Latched 	: SvrCh_DINT;
	Input2 	: SvrCh_DINT;
	Input2Latched 	: SvrCh_DINT;
	Input3 	: SvrCh_DINT;
	Input3Latched 	: SvrCh_DINT;
	Output1 	: SvrCh_DINT;
	Output2 	: SvrCh_DINT;
	VoltageOKEncoder 	: SvrCh_DINT;
	VoltageOk24V 	: SvrCh_DINT;
  //Clients:
	UsePulseCntCorrection 	: CltCh_DINT;
	PulseMode 	: CltCh_DINT;
	ModeClockCounter 	: CltCh_DINT;
	InvertEncoder 	: CltCh_DINT;
	InvertEnable 	: CltCh_DINT;
	EncoderSampling 	: CltCh_DINT;
	LatchEncoder 	: CltCh_DINT;
	LatchClockCounter 	: CltCh_DINT;
	MinPulseWidth 	: CltCh_DINT;
	Deathtime 	: CltCh_DINT;
	Input1Latch 	: CltCh_DINT;
	Input2Latch 	: CltCh_DINT;
	Input3Latch 	: CltCh_DINT;
	ZPulseLatch 	: CltCh_DINT;
  //Variables:
		us_PulseDivider 	: USINT;
		sd_PulseTime 	: DINT;
		sd_PositionLatched 	: DINT;
		us_ServoRegister 	: USINT;
		ui_PositionOld 	: UINT;
		ui_ClockCounterOld 	: UINT;
		sd_ClockCounterLatched 	: DINT;
		si_Counter16Old 	: INT;
		si_CounterMod 	: INT;
		eInitSSW 	: t_e_InitSSW;
		s_ConfigModuleSDO1 	: t_s_ConfigWrite1;
		s_ConfigModuleSDO2 	: t_s_ConfigWrite2;
		eResponseState 	: t_ResponseState;
		udSDOTimeOut 	: UDINT;
		pReadData 	: ^t_s_ReadData;
		pWriteData 	: ^t_s_WriteData;
		bsLatchReaded : BSINT
		[
		  1 Input1,
		  2 Input2,
		  3 Input3,
		  4 ZPuls,
		];

		bsSelectedLatch : BSINT
		[
		  1 DigIn1,
		  2 DigIn2,
		  3 DigIn3,
		  4 ZPos,
		];

  //Functions:
	
	FUNCTION ST011
		VAR_OUTPUT
			ret_code 	: ConfStates;
		END_VAR;
				//! <Function Comment="Realtime Update Methode which runs in PreScan." Name="UpdateRt"/>
	FUNCTION VIRTUAL GLOBAL UpdateRt;
				//! <Function Comment="Realtime Update Methode which runs in PostScan." Name="UpdateRtPostScan"/>
	FUNCTION VIRTUAL GLOBAL UpdateRtPostScan;
				//! <Function Comment="Methode is called if this Module gets connected." Name="ConnectEvent"/>
	FUNCTION VIRTUAL GLOBAL ConnectEvent;
				//! <Function Comment="Methode is called if this Module gets disconnected." Name="DisconnectEvent"/>
	FUNCTION VIRTUAL GLOBAL DisconnectEvent;
				//! <Function Comment="Methode should be used to run a Statemachine to Initialize the Module." Name="InitModule"/>
	FUNCTION VIRTUAL GLOBAL InitModule
		VAR_OUTPUT
			eModuleInitState 	: iprStates;			//! <Variable Comment="Return BUSY until the Initialisation is finished." Name="InitModule.eModuleInitState"/>
		END_VAR;
				//! <Function Comment="This Methode should be used, to check the DeviceID of the Module." Name="CheckDeviceID"/>
	FUNCTION VIRTUAL GLOBAL CheckDeviceID
		VAR_INPUT
			udID2Check 	: UDINT;			//! <Variable Comment="Device ID of connected Module." Name="CheckDeviceID.udID2Check"/>
		END_VAR
		VAR_OUTPUT
			bIsOK 	: BOOL;			//! <Variable Comment="FALSE = Wrong DeviceID for Module&#13;&#10;TRUE  = DeviceID of Module is correct" Name="CheckDeviceID.bIsOK"/>
		END_VAR;
				//! <Function Comment="Methode to receive the Response in case of SDO-Communication." Name="ReceiveSDOResponse"/>
	FUNCTION VIRTUAL ReceiveSDOResponse
		VAR_INPUT
			eCommand 	: t_SDIAS_SDO_Cmd;			//! <Variable Comment="Type of SDO-Command" Name="ReceiveSDOResponse.eCommand"/>
			hOffset 	: HINT;			//! <Variable Comment="Address-Offset in Module." Name="ReceiveSDOResponse.hOffset"/>
			usLength 	: USINT;			//! <Variable Comment="Length of Data." Name="ReceiveSDOResponse.usLength"/>
			eResult 	: iprStates;			//! <Variable Comment="State of SDO-Communication." Name="ReceiveSDOResponse.eResult"/>
			pResponseBuffer 	: ^USINT;			//! <Variable Comment="Pointer of ResponseBuffer, where the SDO-Data is located." Name="ReceiveSDOResponse.pResponseBuffer"/>
			ResponseLength 	: USINT;			//! <Variable Comment="Size of the ResponseBuffer." Name="ReceiveSDOResponse.ResponseLength"/>
		END_VAR
		VAR_OUTPUT
			ret_code 	: iprStates;			//! <Variable Comment="Indicates if the Methode was successful." Name="ReceiveSDOResponse.ret_code"/>
		END_VAR;
	
	FUNCTION VIRTUAL GetTaskCfg
		VAR_OUTPUT
			TaskCfg 	: BDINT;			//! <Variable Comment="Select which tasks will be available for this module:&#13;&#10;Bit0..Realtime PreScan&#13;&#10;Bit1..Realtime PostScan&#13;&#10;Bit2..Cyclic&#13;&#10;&#13;&#10;e.g. if only realtime postscan is needed:&#13;&#10;2#010" Name="GetTaskCfg.TaskCfg"/>
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL GetDeviceID
		VAR_OUTPUT
			output 	: UDINT;
		END_VAR;
	
	FUNCTION CheckLatchSetting
		VAR_INPUT
			dLatch 	: DINT;
		END_VAR
		VAR_OUTPUT
			dSetting 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL FreqOut::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL Enable::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL ZPulsLatched::Read
		VAR_OUTPUT
			output (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL Input1Latched::Read
		VAR_OUTPUT
			output (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL Input2Latched::Read
		VAR_OUTPUT
			output (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL Input3Latched::Read
		VAR_OUTPUT
			output (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL Output1::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL Output2::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

//}}LSL_DECLARATION


FUNCTION GLOBAL TAB ST011::@CT_
0$UINT,
2#0100000000000000$UINT, //TY_ST011
1$UINT, 11$UINT, (SIZEOF(::ST011))$UINT, 
18$UINT, 14$UINT, 0$UINT, 
TO_UDINT(1310079211), "ST011", //Class
TO_UDINT(3175101883), "SdiasBase", 1$UINT, 58$UINT, //Baseclass
//Servers:
(::ST011.FreqOut.pMeth)$UINT, _CH_CMD$UINT, 2#0000000000000000$UINT, TO_UDINT(3361701694), "FreqOut", 
(::ST011.Encoder.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(500247242), "Encoder", 
(::ST011.EncoderLatched.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3296418541), "EncoderLatched", 
(::ST011.ClockCounter.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2133336079), "ClockCounter", 
(::ST011.ClockCounterLatched.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(802079747), "ClockCounterLatched", 
(::ST011.Enable.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(56102836), "Enable", 
(::ST011.ZPuls.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3142960073), "ZPuls", 
(::ST011.ZPulsLatched.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3904789169), "ZPulsLatched", 
(::ST011.Input1.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1344628668), "Input1", 
(::ST011.Input1Latched.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(751816755), "Input1Latched", 
(::ST011.Input2.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3375117830), "Input2", 
(::ST011.Input2Latched.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2722158544), "Input2Latched", 
(::ST011.Input3.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3190490768), "Input3", 
(::ST011.Input3Latched.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1860884302), "Input3Latched", 
(::ST011.Output1.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2425114930), "Output1", 
(::ST011.Output2.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(159711368), "Output2", 
(::ST011.VoltageOKEncoder.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2453190080), "VoltageOKEncoder", 
(::ST011.VoltageOk24V.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(4117632969), "VoltageOk24V", 
//Clients:
(::ST011.UsePulseCntCorrection.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(3640186780), "UsePulseCntCorrection", 
(::ST011.PulseMode.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(2418306836), "PulseMode", 
(::ST011.ModeClockCounter.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(2847341348), "ModeClockCounter", 
(::ST011.InvertEncoder.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(164824020), "InvertEncoder", 
(::ST011.InvertEnable.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(2973352), "InvertEnable", 
(::ST011.EncoderSampling.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(1045480734), "EncoderSampling", 
(::ST011.LatchEncoder.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(1952436013), "LatchEncoder", 
(::ST011.LatchClockCounter.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(1542024366), "LatchClockCounter", 
(::ST011.MinPulseWidth.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(3540403579), "MinPulseWidth", 
(::ST011.Deathtime.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(1638860645), "Deathtime", 
(::ST011.Input1Latch.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(1200938485), "Input1Latch", 
(::ST011.Input2Latch.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(3238047579), "Input2Latch", 
(::ST011.Input3Latch.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(173833470), "Input3Latch", 
(::ST011.ZPulseLatch.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(898682994), "ZPulseLatch", 
END_FUNCTION


#define USER_CNT_ST011 20

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_ST011] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION ST011::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
		nCmdSize	: UINT;
	END_VAR

	ret_code	:= SdiasBase::@STD();
	IF ret_code <> C_OK THEN
		RETURN;
	END_IF;
	nCmdSize		:= SdiasBase::ClassState.pMeth^.nCmds$UINT*SIZEOF(pVoid) + CMDMETH.Init;

	_memcpy((#vmt.CmdTable)$^USINT, SdiasBase::ClassState.pMeth, nCmdSize);
	vmt.CmdTable.nCmds		:= nSTDCMD + USER_CNT_ST011;
#pragma warning (disable : 74)
	vmt.UserFcts[0]		:= #UpdateRt();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[1]		:= #UpdateRtPostScan();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[5]		:= #ConnectEvent();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[6]		:= #DisconnectEvent();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[7]		:= #InitModule();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[8]		:= #CheckDeviceID();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[9]		:= #ReceiveSDOResponse();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[13]		:= #GetTaskCfg();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[14]		:= #GetDeviceID();

#pragma warning (default : 74)
	SdiasBase::ClassState.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF SdiasBase::ClassState.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	_memcpy((#vmt.CmdTable)$^USINT, FreqOut.pMeth, SIZEOF(CMDMETH));
	vmt.CmdTable.nCmds		:= nSTDCMD;
	vmt.CmdTable.Write		:= #FreqOut::Write();
	FreqOut.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF FreqOut.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	Enable.pMeth			:= StoreMethod( #M_RD_DIRECT(), #Enable::Write() );
	IF Enable.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	ZPulsLatched.pMeth			:= StoreMethod( #ZPulsLatched::Read(), #M_NO_F() );
	IF ZPulsLatched.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	Input1Latched.pMeth			:= StoreMethod( #Input1Latched::Read(), #M_NO_F() );
	IF Input1Latched.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	Input2Latched.pMeth			:= StoreMethod( #Input2Latched::Read(), #M_NO_F() );
	IF Input2Latched.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	Input3Latched.pMeth			:= StoreMethod( #Input3Latched::Read(), #M_NO_F() );
	IF Input3Latched.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	Output1.pMeth			:= StoreMethod( #M_RD_DIRECT(), #Output1::Write() );
	IF Output1.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	Output2.pMeth			:= StoreMethod( #M_RD_DIRECT(), #Output2::Write() );
	IF Output2.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	ret_code	:= ST011();

END_FUNCTION

//{{LSL_IMPLEMENTATION
FUNCTION VIRTUAL GLOBAL ST011::ConnectEvent
  
  
  // start the accesses on the SDIAS (initialize the control byte in the DPRAM)
  //Read Access
  if DefaultAccesses.ReadAccess.pControlByte then
    pReadData := DefaultAccesses.ReadAccess.pData$^t_s_ReadData;
    
    DefaultAccesses.ReadAccess.pControlByte^.EnableDO := TRUE;
  else
    eInitState := _DOHandleInvalid;
    return;
  end_if;
  
  //Write Access
  if DefaultAccesses.WriteAccess.pControlByte then
    pWriteData := DefaultAccesses.WriteAccess.pData$^t_s_WriteData;
    
    DefaultAccesses.WriteAccess.pControlByte^.EnableDO := TRUE;
  else
    eInitState := _DOHandleInvalid;
    return;
  end_if;
  
  eInitSSW := _InitVariables;
  eResponseState := _idle;
  eInitState    := _NotInitialized;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL ST011::CheckDeviceID
	VAR_INPUT
		udID2Check 	: UDINT;
	END_VAR
	VAR_OUTPUT
		bIsOK 	: BOOL;
	END_VAR
  
  if (udID2Check <> DEVICE_ID_ST011) then
    bIsOK := FALSE;
  else
    bIsOK := TRUE;
  end_if;
  
END_FUNCTION


FUNCTION VIRTUAL GLOBAL ST011::InitModule
	VAR_OUTPUT
		eModuleInitState 	: iprStates;
	END_VAR
  VAR
  	TmpRetcode      : iprStates;
  END_VAR
  
  eModuleInitState := BUSY;
  
  case eInitSSW of
  
//**********************************************************************************************************************************************************  
    _InitVariables:
    
      //Read Clients 
      PulseMode 		    := PulseMode.read() AND 2#11;
      InvertEncoder 	  := InvertEncoder.read() AND 2#1;
      
      //Invert Enable Settings
      InvertEnable  := InvertEnable.Read() <> 0;      
      Enable.Write(Enable); //--- to ensure function of InvertEnable      
      
      //EncoderSampling       := EncoderSampling.read() AND 2#11;//SB#000
      EncoderSampling       := EncoderSampling.read() AND 2#111;
      ModeClockCounter      := ModeClockCounter.read() AND 2#11;      
      DeathTime             := DeathTime.Read();
      MinPulseWidth         := MinPulseWidth.Read();
      
      UsePulseCntCorrection := UsePulseCntCorrection.Read() and 2#1;//SB#000
      
      if MinPulseWidth then
        DeathTime := MinPulseWidth / (1000 / ST011_FREQUENCY_MHZ);
        if MinPulseWidth MOD (1000 / ST011_FREQUENCY_MHZ) then
          DeathTime += 1;
          MinPulseWidth := DeathTime * (1000 / ST011_FREQUENCY_MHZ);
        end_if;
      end_if;


      //Limit Deathtime
      if DeathTime < ST011_MINIMAL_PULSEWIDTH then
        DeathTime := ST011_MINIMAL_PULSEWIDTH;
      end_if;
      
      //Check Latch Setting
      Input1Latch       := CheckLatchSetting(dLatch := Input1Latch.Read());
      Input2Latch       := CheckLatchSetting(dLatch := Input2Latch.Read());
      Input3Latch       := CheckLatchSetting(dLatch := Input3Latch.Read());
      ZPulseLatch       := CheckLatchSetting(dLatch := ZPulseLatch.Read());

      // remember flags for further use
      bsSelectedLatch.DigIn1 := Input1Latch <> 0;
      bsSelectedLatch.DigIn2 := Input2Latch <> 0;
      bsSelectedLatch.DigIn3 := Input3Latch <> 0;
      bsSelectedLatch.ZPos   := ZPulseLatch <> 0;

      //Limit Encoder Sampling
      if ( EncoderSampling < 0 ) then
        EncoderSampling := 0;
      elsif ( EncoderSampling > 4 ) then//SB#000
        EncoderSampling := 4;
      end_if;
      
      //Set Pulse Divider
      if PulseMode = 1 | PulseMode = 3 then		
        us_PulseDivider := 2;
      else	
        us_PulseDivider := 4; 	
      end_if;   
            
      //SB#000 Start
      if EncoderSampling = 4 then        
      
        //set variable for servo command register 
        s_ConfigModuleSDO1.ServoControlRegister := PulseMode$USINT 
                                                OR 2#10000//1 FlankenModus
                                                OR ( To_Bool( InvertEncoder ) SHL 3 )
                                                OR 2#1000000; //Fallende Flanke ;
                           
      else
        //set variable for servo command register 
        s_ConfigModuleSDO1.ServoControlRegister := PulseMode$USINT 
                                                OR ( EncoderSampling$USINT SHL 4 ) 
                                                OR ( To_Bool( InvertEncoder ) SHL 3 );                                
      end_if;
      
      
      if UsePulseCntCorrection then                                        
        if FPGAVersion >= ST011_FPGAVersion_PulsCntCorrect then
          s_ConfigModuleSDO1.ServoControlRegister := s_ConfigModuleSDO1.ServoControlRegister OR 2#10000000;
        else
          eModuleInitState := ERROR;
          LogError("@ZZZZ (ST011::InitModule) Xilinx Version < 1.2 does not support UsePulseCntCorrection = 1");
          eInitState := _InvalidConfguration;
          return;
        end_if;      
      end_if;
      //SB#000 End                                        
                                              
      s_ConfigModuleSDO1.MinPulsWidth := DeathTime$UINT;
      
      //Set variable for latch enable registers
      s_ConfigModuleSDO2.LatchEnableRising.Input1Rising   := to_bool(Input1Latch and 1);
      s_ConfigModuleSDO2.LatchEnableFalling.Input1Falling := to_bool((Input1Latch shr 1) and 1);
      s_ConfigModuleSDO2.LatchEnableRising.Input2Rising   := to_bool(Input2Latch and 1);
      s_ConfigModuleSDO2.LatchEnableFalling.Input2Falling := to_bool((Input2Latch shr 1) and 1);
      s_ConfigModuleSDO2.LatchEnableRising.Input3Rising   := to_bool(Input3Latch and 1);
      s_ConfigModuleSDO2.LatchEnableFalling.Input3Falling := to_bool((Input3Latch shr 1) and 1);
      s_ConfigModuleSDO2.LatchEnableRising.ZPulseRising   := to_bool(ZPulseLatch and 1);
      s_ConfigModuleSDO2.LatchEnableFalling.ZPulseFalling := to_bool((ZPulseLatch shr 1) and 1);

      eInitSSW := _ConfigSDO1;
      
//**********************************************************************************************************************************************************
    _ConfigSDO1:
    
      case eResponseState of
        _idle:
          TmpRetcode  := StartWriteSDO(hOffset:=ST011_ADDR_SDO_WRITE_1, usLength:=sizeof(t_s_ConfigWrite1), pWriteBuffer:=(#s_ConfigModuleSDO1)$^USINT, eCommand:=SDIAS_SDO_CMD_MEM_WRITE);
          if TmpRetcode = READY then
            udSDOTimeout  := ops.tAbsolute;
            eResponseState:= _wait; 
          elsif TmpRetcode = ERROR then
            eModuleInitState := ERROR;
            LogError("@ZZZZ (ST011::InitModule) Failed to add write SDO for configuration");
            eInitState := _NoMem;
          end_if;
          //*****************************************************
        _wait:
          // wait for response
          if ((ops.tAbsolute - udSDOTimeout) > ST011_SDO_RESPONSE_TIMEOUT) then
            LogError("@ZZZZ (ST011::InitModule) SDO Response timeout config module");
            eInitSSW := _InitError;
          end_if;
        //*****************************************************
        _valid:
          eInitSSW        := _ConfigSDO2;
          eResponseState  := _idle;
        //*****************************************************
      end_case;
      
//**********************************************************************************************************************************************************
    _ConfigSDO2:
    
      case eResponseState of
        _idle:
          TmpRetcode  := StartWriteSDO(hOffset:=ST011_ADDR_SDO_WRITE_2, usLength:=sizeof(t_s_ConfigWrite2), pWriteBuffer:=(#s_ConfigModuleSDO2)$^USINT, eCommand:=SDIAS_SDO_CMD_MEM_WRITE);
          if TmpRetcode = READY then
            udSDOTimeout  := ops.tAbsolute;
            eResponseState:= _wait; 
          elsif TmpRetcode = ERROR then
            eModuleInitState := ERROR;
            LogError("@ZZZZ (ST011::InitModule) Failed to add write SDO for configuration");
            eInitState := _NoMem;
          end_if;
          //*****************************************************
        _wait:
          // wait for response
          if ((ops.tAbsolute - udSDOTimeout) > ST011_SDO_RESPONSE_TIMEOUT) then
            LogError("@ZZZZ (ST011::InitModule) SDO Response timeout config module");
            eInitSSW := _InitError;
          end_if;
        //*****************************************************
        _valid:
          eInitSSW        := _Finish;
          eResponseState  := _idle;
        //*****************************************************
      end_case;
      
//**********************************************************************************************************************************************************
    _Finish:
      eInitSSW         := _InitVariables;
      eModuleInitState := READY;
      eInitState      := _ClassOk;
      
//**********************************************************************************************************************************************************
    _InitError:
      eModuleInitState := ERROR; 
      if (eInitState <> _InvalidConfguration) then
        eInitState      := _ClientNotready;
      end_if;  
      
//**********************************************************************************************************************************************************

  end_case;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL ST011::UpdateRt
VAR
	TempReadData : t_s_ReadData;
  ui_NewEncoder : UINT;
  si_Counter16New : INT;
  si_deltaCounter16 : INT;
  ui_encoder_latched			: UINT;
  si_delta_encoder_latched 	: INT;
  ui_tact_latched				: UINT;
  si_delta_tact_latched		: INT;
END_VAR
  
  TempReadData := pReadData^;
  
  //Update Server Values  
  Enable   := TempReadData.ServoStateRegister1.Enable;
  VoltageOk24V := TempReadData.DigitalInputStateRegister1.VoltageOK24V;
  VoltageOKEncoder := TempReadData.DigitalInputStateRegister1.VoltageOK5V;
  
  ZPuls := TempReadData.ServoStateRegister1.IncEncoderZeroPos;
  
  if TempReadData.ServoStateRegister1.IncEncoderZeroPosLatched = 1 then
    ZPulsLatched := TempReadData.ServoStateRegister1.IncEncoderZeroPosLatched;
  end_if;
  
  //Update Digital Inputs  
  Input1 := TempReadData.DigitalInputStateRegister1.Input1;
  Input2 := TempReadData.DigitalInputStateRegister1.Input2;
  Input3 := TempReadData.DigitalInputStateRegister1.FeedBackOutput3;

  //Encoder
  ui_NewEncoder   := TempReadData.CounterIncremental;
  Encoder      += to_int(ui_NewEncoder - ui_PositionOld);
  
  ui_PositionOld := ui_NewEncoder;
  
  //Update clock
  si_Counter16New := TempReadData.PulseCounter16Bit;
  si_deltaCounter16 := si_Counter16New - si_Counter16Old;
  
  if ModeClockCounter = 2 then
  
    si_CounterMod += si_deltaCounter16 mod 4;
    
    // Add delta
    if si_deltaCounter16 < 0 then
      ClockCounter -= (-si_deltaCounter16)/4; // Prevent division of neg val
    else
      ClockCounter += si_deltaCounter16/4;
    end_if;    
    // Add delta mod
    if si_CounterMod < 0 then  
      ClockCounter -= (-si_CounterMod)/4; // Prevent division of neg val
    else
      ClockCounter += si_CounterMod/4;
    end_if;
    
    si_CounterMod := si_CounterMod mod 4;
    
  elsif ModeClockCounter = 1 then
  
    si_CounterMod += si_deltaCounter16 mod 2;
    
    // Add delta
    if si_deltaCounter16 < 0 then
      ClockCounter -= (-si_deltaCounter16)/2; // Prevent division of neg val
    else
      ClockCounter += si_deltaCounter16/2;
    end_if;    
    // Add delta mod
    if si_CounterMod < 0 then
      ClockCounter -= (-si_CounterMod)/2; // Prevent division of neg val
    else
      ClockCounter += si_CounterMod/2;
    end_if;
    
    si_CounterMod := si_CounterMod mod 2;
  else
     // Add delta 
     ClockCounter += si_deltaCounter16;  
  end_if;
  
  si_Counter16Old := si_Counter16New;  
  
  // check for latched bits
  if (TempReadData.LatchSourceRegister AND 2#1111) | bsLatchReaded | (TempReadData.ServoStateRegister1.IncEncoderZeroPosLatched & ZPulseLatch <> 0) then
    
    //Input1 latched
    if ( TempReadData.LatchSourceRegister.DigIn1Latched ) | bsLatchReaded.Input1 then
      bsLatchReaded.Input1 := FALSE;
      Input1Latched := TempReadData.LatchSourceRegister.DigIn1Latched; //Reset of Bit is done with Read-Access
    end_if;    
    
    //Input2 latched
    if ( TempReadData.LatchSourceRegister.DigIn2Latched ) | bsLatchReaded.Input2 then
      bsLatchReaded.Input2 := FALSE;
      Input2Latched := TempReadData.LatchSourceRegister.DigIn2Latched; //Reset of Bit is done with Read-Access
    end_if;    

    //Input3 latched
    if ( TempReadData.LatchSourceRegister.DigIn3Latched ) | bsLatchReaded.Input3 then
      bsLatchReaded.Input3 := FALSE;
      Input3Latched := TempReadData.LatchSourceRegister.DigIn3Latched; //Reset of Bit is done with Read-Access
    end_if;
    
    //Zpuls Latched
    if bsLatchReaded.ZPuls then
      bsLatchReaded.ZPuls := FALSE;
      ZPulsLatched := TempReadData.ServoStateRegister1.IncEncoderZeroPosLatched;
    end_if;

    ui_encoder_latched  := TempReadData.CounterIncrementalSaved;
    ui_tact_latched     := to_uint(TempReadData.PulseCounter16BitLatched); 

    if ModeClockCounter = 1 then
      ui_tact_latched := ui_tact_latched AND 16#FFFE;
    elsif ModeClockCounter = 2 then
      ui_tact_latched := ui_tact_latched AND 16#FFFC;
    end_if;

    si_delta_encoder_latched := ( ui_PositionOld - ui_encoder_latched )$INT;
    sd_PositionLatched := Encoder - si_delta_encoder_latched;

    si_delta_tact_latched := ( si_Counter16Old - ui_tact_latched )$INT;

    if ModeClockCounter = 1 then
      si_delta_tact_latched /= 2;
    elsif ModeClockCounter = 2 then
      si_delta_tact_latched /= 4;
    end_if;
    
    sd_ClockCounterLatched := ClockCounter - si_delta_tact_latched;

    EncoderLatched := sd_PositionLatched;
    ClockCounterLatched := sd_ClockCounterLatched;
  
    LatchEncoder.write( sd_PositionLatched );
    LatchClockCounter.write( sd_ClockCounterLatched );

  end_if;
    

END_FUNCTION


FUNCTION VIRTUAL GLOBAL ST011::UpdateRtPostScan
VAR
  TempWriteData : t_s_WriteData;
END_VAR
    
  TempWriteData.OutputRegister := Output1$USINT OR  ( Output2$USINT SHL 1 );
  
  TempWriteData.ServoOutputPulseTime := sd_PulseTime;
  
  TempWriteData.ServoControlReg := us_ServoRegister;
   
  pWriteData^ := TempWriteData;
   
END_FUNCTION


FUNCTION VIRTUAL GLOBAL ST011::GetDeviceID
	VAR_OUTPUT
		output 	: UDINT;
	END_VAR
  
  output := DEVICE_ID_ST011;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL ST011::FreqOut::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

  FreqOut := input;

  if FreqOut = 0 then
    sd_PulseTime := 0;
  else
    sd_PulseTime := ST011_FREQUENCY_HZ / FreqOut;
    sd_PulseTime /= us_PulseDivider;
  end_if;

  result := FreqOut;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL ST011::Enable::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

  Enable := input;

  us_ServoRegister := ( us_ServoRegister AND 16#FD ) OR ( ( (Enable AND 1) XOR InvertEnable )$USINT SHL 1 );

  result := Enable;

END_FUNCTION





FUNCTION VIRTUAL GLOBAL ST011::Output1::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

  if input then  
    result  := 1;  
    Output1 := 1;  
  else  
    result  := 0;  
    Output1 := 0;  
  end_if;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL ST011::Output2::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

  if input then  
    result  := 1;  
    Output2 := 1;  
  else  
    result  := 0;  
    Output2 := 0;  
  end_if;

END_FUNCTION


FUNCTION VIRTUAL ST011::ReceiveSDOResponse
	VAR_INPUT
		eCommand 	: t_SDIAS_SDO_Cmd;
		hOffset 	: HINT;
		usLength 	: USINT;
		eResult 	: iprStates;
		pResponseBuffer 	: ^USINT;
		ResponseLength 	: USINT;
	END_VAR
	VAR_OUTPUT
		ret_code 	: iprStates;
	END_VAR
  
  ret_code := SdiasBase::ReceiveSDOResponse(eCommand, hOffset, usLength, eResult, pResponseBuffer, ResponseLength);
  
  // spi access from baseclass                                         
  if bSDOResponseHandle = TRUE then
    return;
  end_if;
  
  if eResult = READY then
    
    case eCommand of
    //**********************************************************************
      SDIAS_SDO_CMD_MEM_WRITE:

        case hOffset of
        //-------------------------------------------------------------
          ST011_ADDR_SDO_WRITE_1,
          ST011_ADDR_SDO_WRITE_2:
            if eResponseState = _wait then
              eResponseState := _valid;
            end_if;           
        end_case;
       
    end_case;
    
    if eResponseState <> _valid then
      LogError("@ZZZZ (ST011::ReceiveSDOResponse) Error in response data of SDO");
      // error was at initialisation
      eInitSSW := _InitError;

    end_if;
  else
    case eCommand of
      SDIAS_SDO_CMD_MEM_WRITE:
        LogError("@ZZZZ (ST011::ReceiveSDOResponse) Error while writing the firmware configuration");
    end_case;
    // error was at initialisation
    eInitSSW := _InitError;
  end_if;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL ST011::Input1Latched::Read
	VAR_OUTPUT
		output (EAX) 	: DINT;
	END_VAR

  //Return Latch
	output := Input1Latched;
  
  //Reset Latch in next rt-run
  bsLatchReaded.Input1 := TRUE;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL ST011::Input2Latched::Read
	VAR_OUTPUT
		output (EAX) 	: DINT;
	END_VAR

  //Return Latch
	output := Input2Latched;
  
  //Reset Latch in next rt-run
  bsLatchReaded.Input2 := TRUE;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL ST011::Input3Latched::Read
	VAR_OUTPUT
		output (EAX) 	: DINT;
	END_VAR

  //Return Latch
	output := Input3Latched;
  
  //Reset Latch in next rt-run
  bsLatchReaded.Input3 := TRUE;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL ST011::ZPulsLatched::Read
	VAR_OUTPUT
		output (EAX) 	: DINT;
	END_VAR
  
  //Return Latch
	output := ZPulsLatched;
  
  //Reset Latch in next rt-run
  bsLatchReaded.ZPuls := TRUE;
  
END_FUNCTION


FUNCTION ST011::CheckLatchSetting
	VAR_INPUT
		dLatch 	: DINT;
	END_VAR
	VAR_OUTPUT
		dSetting 	: DINT;
	END_VAR

  //Only Values from 0 to 3 are Valid
  if (dLatch >= 0) & (dLatch <= 3) then
    //Value is OK
    dSetting := dLatch;
    
  else
    //Disable Latch
    dSetting := 0;
    LogError("@ZZZZ (ST011::CheckLatchSetting) Invalid InputLatch setting value");    
  end_if;
END_FUNCTION


FUNCTION VIRTUAL GLOBAL ST011::DisconnectEvent
  //Reset DO-Data
  if pWriteData then
    _memset(dest := pWriteData, usByte := 0, cntr := sizeof(pWriteData^));
  end_if;
  
  //Call Disconnect of Base-Class
  SdiasBase::DisconnectEvent();
  
END_FUNCTION


FUNCTION ST011::ST011
	VAR_OUTPUT
		ret_code 	: ConfStates;
	END_VAR
  
	ret_code := C_OK;

END_FUNCTION


FUNCTION VIRTUAL ST011::GetTaskCfg
	VAR_OUTPUT
		TaskCfg 	: BDINT;
	END_VAR
  
  TaskCfg := SDIAS_TASK_MASK_RT_PRE OR SDIAS_TASK_MASK_RT_POST;
  
END_FUNCTION
