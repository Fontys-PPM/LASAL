//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)

//{{LSL_DEFINES
#define DEVICE_ID_ST151                                                    1086
                                
#define ST151_ADDR_PDO_WRITE                                            16#0000
#define ST151_ADDR_PDO_READ                                             16#0038
#define ST151_ADDR_SDO_1                                                16#0008
#define ST151_ADDR_SDO_2           (ST151_ADDR_SDO_1+sizeof(t_s_ConfigModule1))
#define ST151_ADDR_SDO_3                                (ST151_ADDR_PDO_READ+6)  //only read sdo!!!
#define ST151_ADDR_SDO_4           (ST151_ADDR_SDO_3+sizeof(t_s_ConfigModule3))
#define ST151_ADDR_SDO_5           (ST151_ADDR_SDO_4+sizeof(t_s_ConfigModule4))
#define ST151_ADDR_SDO_6           (ST151_ADDR_SDO_5+sizeof(t_s_ConfigModule5))


#define ST151_OSZI_ADDR_WRITE                                           16#0800
#define ST151_OSZI_ADDR_READ                                            16#0808
#define ST151_OSZI_ADDR_DATA                                            16#0820
#define ST151_OSZI_READPOINTER_OFFSET                                   16#0020
#define ST151_OSZI_ONE_PDOSIZE                                              126
#define ST151_OSZI_VALUES_DATA             (ST151_OSZI_ONE_PDOSIZE/sizeof(UINT))
#define ST151_OSZI_BUFFER_SIZE                                             1024
#define ST151_OSZI_MAX_SAMPLES             (ST151_OSZI_BUFFER_SIZE/sizeof(UINT))
#define ST151_OSZI_MAX_PDOREAD   ((ST151_OSZI_BUFFER_SIZE/ST151_OSZI_ONE_PDOSIZE)+1)

// in MHz
#define ST151_FREQUENCY_MHZ                             125
// in Hz
#define ST151_FREQUENCY_HZ   (ST151_FREQUENCY_MHZ * 1000000)

#define ST151_SDO_RESPONSE_TIMEOUT   (SDIAS_SDO_TIMEOUT * 2)
#define ST151_SDO_MAX_RETRYS                              3

#define ST151_MAXFREQUENCY_OUT                   2_000_000 // 2Mhz/64 max frequency of module output
#define ST151_MAXSTEPPING_MODES                          6
#define ST151_FREQLIMITS_TABLESIZE      (ST151_MAXSTEPPING_MODES*sizeof(UDINT)*2)
                                    
#define ST151_MAX_ALLOWED_PERCENT                      100 // maximum value for percent value
#define ST151_BLANKING_TIME                             10 // minimum on time of pwm (*20ns)

#define ST151_CYCLICREFRESHDATA_TIME                   200 // time to refresh asynchrone values
#define ST151_INVALID_VALUE                   16#8000_0010 // invalid value for server
#define ST151_AUTOSET_FREQUENCYLIMIT          16#0000_0000 // value for autoset limit
#define ST151_DEACTIVATE_FREQUENCYLIMIT       16#FFFF_FFFF // value for deactivate limit

#define ST151_MAX_ALLOWED_CURRENT                     5000 // max allowed current (5A) in mA, from h-bridge according to hw-documentation
#define ST151_MAX_ALLOWED_CHOPPEROFFTIME              2500 // max allowed chopper off time in 20ns steps
#define ST151_MIN_ALLOWED_CHOPPEROFFTIME              1500 // min allowed chopper off time in 20ns steps
#define ST151_STALL_CURRENT_LIMIT                     1000 // calculation for stall current in permille
#define ST151_CURRENTOFFSETADJUST_MAX                  250 // maximum current offset adjust in mA
#define ST151_CURRENTOFFSETADJUST_MIN                 -250 // minimum current offset adjust in mA
                                       
//pll settings                         
#define ST151_SYNC_OUT_ID                             16#03
#define ST151_PLL_OFFSET                             16#140
#define ST151_PLL_CONTROL               (ST151_PLL_OFFSET+8)

#define ST151_ERROR_BITMASK_STATE_WORD               0x013E
#define ST151_ERROR_BITMASK_EXTENDED_STATE_WORD      0xFF3E
//}}LSL_DEFINES

//{{LSL_DECLARATION

(*!
<Class
	Name               = "ST151Base"
	Revision           = "1.2"
	GUID               = "{AA3F5E4D-B8F7-4425-BBA0-9542CB6C1E8E}"
	RealtimeTask       = "false"
	CyclicTask         = "false"
	BackgroundTask     = "false"
	Sigmatek           = "true"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	IconPath           = ".\Class\s-dias.ico"
	SharedCommandTable = "true"
	Objectsize         = "(910,120)"
	Comment            = "SDIAS Stepper Module (1x Motor Out max. 5A, 2x Digital In 24V, 2x STO Enable 24V, 1x Incremental Encoder Input, 1x Regen Resistor)">
	<Channels>
		<Server Name="ActPosition" GUID="{77A439B5-A5BA-4A34-9AFF-A124ECB8BA18}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Actual internal Step-Position as 64 micro step."/>
		<Server Name="ActRegenResistorLoad" GUID="{234AE7D8-18C2-4B50-860D-3363E3C450A8}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Actual load of regen resistor in xxx [%].&#13;&#10;If the value is never refreshed it shows -2 147 483 632.&#13;&#10;- Value is read asynchronous"/>
		<Server Name="AxError" GUID="{9016CA67-4291-4969-90AF-6F622A49C4D8}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Shows a fault of power-stage.&#13;&#10;(eg. over temperature, over current, power not connected)"/>
		<Server Name="ChopperOffTime" GUID="{A580F373-23FD-4B78-BF7E-89E43FAF3F43}" Visualized="true" Initialize="true" DefValue="1562" WriteProtected="false" Retentive="false" Comment="Set fixed off-time of the PWM  [20ns steps].&#13;&#10;If the value is changed, it is transferred asynchronously to the module.&#13;&#10;Valid range is from 1500 up to 2500."/>
		<Server Name="ChopperOnTimeMin" GUID="{0F2D0C4D-4C3F-4291-A7F0-85EB7CAF077D}" Visualized="true" Initialize="true" DefValue="180" WriteProtected="false" Retentive="false" Comment="Set minimum on-time of the PWM  [20ns steps].&#13;&#10;If the value is changed, it is transferred asynchronously to the module.&#13;&#10;Valid range is from 0 up to 2500."/>
		<Server Name="ControlWord" GUID="{CCDFE21A-991F-4328-865D-F758DF0AC496}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false" Comment="SwitchOn + Enable: Enable Motor&#13;&#10;ResetFault: Quit Error&#13;&#10;Bit12 ManufactureSpec1: current increase allowed"/>
		<Server Name="CurrentIncrease" GUID="{C5DC545A-8379-469F-8A13-9BFB156D7604}" Visualized="true" Initialize="true" DefValue="1" WriteProtected="false" Retentive="false" Comment="allow sqrt(2) current increase in halfstep mode&#13;&#10;&#13;&#10;in microstep mode the increase is always active"/>
		<Server Name="CurrentOffsetAdjBridge1" GUID="{2C29A7B5-8154-4984-8F8F-2023938D9501}" Visualized="true" Initialize="true" DefValue="100" WriteProtected="false" Retentive="false" Comment="!This setting has no effect if the version of the module is &gt;= HW2.0X1.4!&#13;&#10;&#13;&#10;Set current offset adjustment for bridge in [mA].&#13;&#10;Valid range is from -250 to 250 and default value is 100."/>
		<Server Name="CurrentOffsetAdjBridge2" GUID="{7A9F19E1-BA69-4C80-912D-05FFD52F0DFB}" Visualized="true" Initialize="true" DefValue="100" WriteProtected="false" Retentive="false" Comment="!This setting has no effect if the version of the module is &gt;= HW2.0X1.4!&#13;&#10;&#13;&#10;Set current offset adjustment for bridge in [mA].&#13;&#10;Valid range is from -250 to 250 and default value is 100."/>
		<Server Name="Enable" GUID="{7EE7CFF5-8891-4AF9-BCA3-30C60EF78402}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false" Comment="Enable stepper output.&#13;&#10;0 .. disabled&#13;&#10;1 .. enabled"/>
		<Server Name="EnableSteps" GUID="{A355E91D-6109-42E3-B5B5-635D99EE807A}" Visualized="true" Initialize="true" DefValue="2#1000111" WriteProtected="false" Retentive="false" Comment="Enable or disable microstepping modes. The full step mode cannot be deactivated.&#13;&#10;Bit1 .. Fullstep mode&#13;&#10;Bit2 .. Halfstep mode&#13;&#10;Bit3 .. Microstepping mode 4&#13;&#10;Bit4 .. Microstepping mode 8&#13;&#10;Bit5 .. Microstepping mode 16&#13;&#10;Bit6 .. Microstepping mode 32&#13;&#10;Bit7 .. Microstepping mode 64"/>
		<Server Name="EncoderPosition" GUID="{D6BEE859-3C93-4C08-AB41-7DCCEE24B023}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Actual position of encoder."/>
		<Server Name="ErrorInfo" GUID="{B7F520F8-2B2D-43DD-AED7-3EDC11B69074}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Shows errors from hardware. Errors above Bit 16 are refreshed at cyclic task over &quot;RefreshValues&quot; server.&#13;&#10;Bit 1: reserved&#13;&#10;Bit 2: Fault (Bridge not ok)&#13;&#10;Bit 3: Temperature  not ok&#13;&#10;Bit 4: Over current&#13;&#10;Bit 5: STO switch off (en1/en2)&#13;&#10;Bit 6: STO test switch off (negative test during operation)&#13;&#10;Bit 7: reserved&#13;&#10;Bit 8: reserved&#13;&#10;Bit 9: Brake chopper over current (disable brake chopper) &#13;&#10;Bit 10: reserved&#13;&#10;Bit 11: reserved&#13;&#10;Bit 12: reserved&#13;&#10;Bit 13: reserved&#13;&#10;Bit 14: reserved&#13;&#10;Bit 15: reserved&#13;&#10;Bit 16: reserved&#13;&#10;&#13;&#10;refreshed asynchrone:&#13;&#10;Bit 17: Regen resistor load warning&#13;&#10;Bit 18: Over temperature warning&#13;&#10;Bit 19: Over temperature failure (disable drive)&#13;&#10;Bit 20: Over current failure GND (disable drive)&#13;&#10;Bit 21: Over current failure Bridge 1 (disable drive)&#13;&#10;Bit 22: Over current failure Bridge 2 (disable drive)&#13;&#10;Bit 23: Regen resistor load threshold bridge (disable bridge)&#13;&#10;Bit 24: Regen resistor load error threshold resistor (disable resistor)&#13;&#10;Bit 25: Bridge voltage too low&#13;&#10;Bit 26: Bridge voltage too high&#13;&#10;Bit 27: External Enable 1 (STO) not ok&#13;&#10;Bit 28: External Enable 2 (STO) not ok&#13;&#10;Bit 29: Safety start up status test not ok&#13;&#10;Bit 30: Motor enable error&#13;&#10;Bit 31: Three time sync in lost&#13;&#10;Bit 32: Safe Ramp down pending"/>
		<Server Name="ErrorQuit" GUID="{0891083A-971A-4EFD-882D-38A29371B70B}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false" Comment="quits error if server &quot;Error&quot; is set"/>
		<Server Name="ExtendedStateWord" GUID="{EC0DE156-F00E-48D8-8F99-E8B9378FF6F6}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Shows the extended motor state word.&#13;&#10;- Value is read asynchronous&#13;&#10;Bit 1 : Zero Position (Input)&#13;&#10;Bit 2 : Over temperature warning&#13;&#10;Bit 3 : Over temperature failure (disable drive)&#13;&#10;Bit 4 : Over current failure GND (disable drive)&#13;&#10;Bit 5 : Over current failure Bridge 1 (disable drive)&#13;&#10;Bit 6 : Over current failure Bridge 2 (disable drive)&#13;&#10;Bit 7 : 5V Incremental encoder ok&#13;&#10;Bit 8 : reserved&#13;&#10;Bit 9 : Bridge voltage too low&#13;&#10;Bit 10: Bridge voltage too high&#13;&#10;Bit 11: External Enable 1 (STO)&#13;&#10;Bit 12: External Enable 2 (STO)&#13;&#10;Bit 13: Safety start up status test ok&#13;&#10;Bit 14: Motor enable error&#13;&#10;Bit 15: Three time sync in lost&#13;&#10;Bit 16: Safe Ramp down pending"/>
		<Server Name="ExternalEnable1" GUID="{E1F1B4FF-7068-4218-A00D-8C7C16EA2F9D}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="State of External Enable  (STO).&#13;&#10;If the value is never refreshed it shows -2 147 483 632.&#13;&#10;- Value is read asynchronous&#13;&#10;0 .. off&#13;&#10;1 .. on&#13;&#10;"/>
		<Server Name="ExternalEnable2" GUID="{2CF5E1E9-B375-49EE-97AB-D534A47C4B7F}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="State of External Enable  (STO).&#13;&#10;If the value is never refreshed it shows -2 147 483 632.&#13;&#10;- Value is read asynchronous&#13;&#10;0 .. off&#13;&#10;1 .. on&#13;&#10;"/>
		<Server Name="FastDecayTime" GUID="{122827C7-3CD7-4011-B3A9-F7B852A6F62E}" Visualized="true" Initialize="true" DefValue="200" WriteProtected="false" Retentive="false" Comment="Set Fast Decay time [20ns steps].&#13;&#10;If the value is changed, it is transferred asynchronously to the module.&#13;&#10;Must be smaller than chopper off time!"/>
		<Server Name="FastDecayTimeFallingStep" GUID="{B38F0CE7-ECAD-4E45-ADC4-BE1A61847A0B}" Visualized="true" Initialize="true" DefValue="600" WriteProtected="false" Retentive="false" Comment="Set Fast Decay time for falling step [20ns steps].&#13;&#10;If the value is changed, it is transferred asynchronously to the module.&#13;&#10;Must be smaller than chopper off time!"/>
		<Server Name="FrequLimitDecrease16to32" GUID="{EAA49CD7-D087-4244-9620-76476AD00704}" Visualized="true" Initialize="true" DefValue="0" WriteProtected="false" Retentive="false" Comment="Set Frequency stepping mode limit if frequence is decreased.&#13;&#10;If the value is changed, it is transferred asynchronously to the module.&#13;&#10;If value is set to 0 the limit is automatically set."/>
		<Server Name="FrequLimitDecrease1to2" GUID="{131828AC-1F48-4F6B-B630-A01CBAFF3D3A}" Visualized="true" Initialize="true" DefValue="0" WriteProtected="false" Retentive="false" Comment="Set Frequency stepping mode limit if frequence is decreased.&#13;&#10;If the value is changed, it is transferred asynchronously to the module.&#13;&#10;If value is set to 0 the limit is automatically set."/>
		<Server Name="FrequLimitDecrease2to4" GUID="{E6BC11ED-674B-438D-9D23-4D0F5A87284A}" Visualized="true" Initialize="true" DefValue="0" WriteProtected="false" Retentive="false" Comment="Set Frequency stepping mode limit if frequence is decreased.&#13;&#10;If the value is changed, it is transferred asynchronously to the module.&#13;&#10;If value is set to 0 the limit is automatically set."/>
		<Server Name="FrequLimitDecrease32to64" GUID="{A63CCADE-AF38-47F7-B748-9F7940A42B90}" Visualized="true" Initialize="true" DefValue="0" WriteProtected="false" Retentive="false" Comment="Set Frequency stepping mode limit if frequence is decreased.&#13;&#10;If the value is changed, it is transferred asynchronously to the module.&#13;&#10;If value is set to 0 the limit is automatically set."/>
		<Server Name="FrequLimitDecrease4to8" GUID="{22B9BE59-10E5-4673-9B14-D8C71324B02F}" Visualized="true" Initialize="true" DefValue="0" WriteProtected="false" Retentive="false" Comment="Set Frequency stepping mode limit if frequence is decreased.&#13;&#10;If the value is changed, it is transferred asynchronously to the module.&#13;&#10;If value is set to 0 the limit is automatically set."/>
		<Server Name="FrequLimitDecrease8to16" GUID="{7C1F62AD-D3AD-4A33-A84F-770D498EAAA5}" Visualized="true" Initialize="true" DefValue="0" WriteProtected="false" Retentive="false" Comment="Set Frequency stepping mode limit if frequence is decreased.&#13;&#10;If the value is changed, it is transferred asynchronously to the module.&#13;&#10;If value is set to 0 the limit is automatically set."/>
		<Server Name="FrequLimitIncrease16to8" GUID="{75D53AE6-EDCC-46C6-9E1E-413BF36E68B3}" Visualized="true" Initialize="true" DefValue="20000" WriteProtected="false" Retentive="false" Comment="Set Frequency stepping mode limit if frequence is increased.&#13;&#10;If the value is changed, it is transferred asynchronously to the module.&#13;&#10;"/>
		<Server Name="FrequLimitIncrease2to1" GUID="{A44CA492-C8B9-4333-99BF-AF8245DF7531}" Visualized="true" Initialize="true" DefValue="50000" WriteProtected="false" Retentive="false" Comment="Set Frequency stepping mode limit if frequence is increased.&#13;&#10;If the value is changed, it is transferred asynchronously to the module.&#13;&#10;"/>
		<Server Name="FrequLimitIncrease32to16" GUID="{3F3E19BB-E350-482B-AB2D-156B2F1B6031}" Visualized="true" Initialize="true" DefValue="10000" WriteProtected="false" Retentive="false" Comment="Set Frequency stepping mode limit if frequence is increased.&#13;&#10;If the value is changed, it is transferred asynchronously to the module.&#13;&#10;"/>
		<Server Name="FrequLimitIncrease4to2" GUID="{6D2DEC18-E7A8-45A1-AFE9-EF528BA7E328}" Visualized="true" Initialize="true" DefValue="40000" WriteProtected="false" Retentive="false" Comment="Set Frequency stepping mode limit if frequence is increased.&#13;&#10;If the value is changed, it is transferred asynchronously to the module.&#13;&#10;"/>
		<Server Name="FrequLimitIncrease64to32" GUID="{D1D45B87-0F4D-4629-A900-4851682D1CAF}" Visualized="true" Initialize="true" DefValue="5000" WriteProtected="false" Retentive="false" Comment="Set Frequency stepping mode limit if frequence is increased.&#13;&#10;If the value is changed, it is transferred asynchronously to the module.&#13;&#10;"/>
		<Server Name="FrequLimitIncrease8to4" GUID="{11738AE5-8F98-44E4-8A8A-D83B64DF9F53}" Visualized="true" Initialize="true" DefValue="30000" WriteProtected="false" Retentive="false" Comment="Set Frequency stepping mode limit if frequence is increased.&#13;&#10;If the value is changed, it is transferred asynchronously to the module.&#13;&#10;"/>
		<Server Name="HBridgeTemperature" GUID="{FF77D64F-3986-4067-872D-0C30C787FA7B}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="actual Temperature in xx.x [°C]&#13;&#10;If the value is never refreshed it shows -2 147 483 632.&#13;&#10;- Value is read asynchronous."/>
		<Server Name="HBridgeVoltage" GUID="{8B8AAC12-96DC-4967-B92D-B10F132F218D}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Actual Voltage in xx.xx [V].&#13;&#10;If the value is never refreshed it shows -2 147 483 632.&#13;&#10;- Value is read asynchronous"/>
		<Server Name="HWEnableSoftwareRampdown" GUID="{DB8E13CA-1A89-4087-B904-133A98FF426B}" Visualized="true" Initialize="true" WriteProtected="false" Retentive="false" Comment=" 0 ... HardwareRampdown&#13;&#10; 1 ... SoftwareRampdown"/>
		<Server Name="HWRampdownDeltaFrequency" GUID="{9604431C-05FD-49F0-BEF0-62145390CB3B}" Visualized="true" Initialize="true" DefValue="40" WriteProtected="false" Retentive="false" Comment="If the enable-signal is lost the output frequency is decreased by HWRampdownDeltaFrequency every HWRampdownDeltaTime"/>
		<Server Name="HWRampdownDeltaTime" GUID="{7FAC79CD-315E-406B-B4FD-D3DD3D7A790F}" Visualized="true" Initialize="true" DefValue="1" WriteProtected="false" Retentive="false" Comment="[20ns steps]&#13;&#10;If the enable-signal is lost the output frequency is decreased by HWRampdownDeltaFrequency every HWRampdownDeltaTime"/>
		<Server Name="Input1" GUID="{A65D4797-EE56-4967-9C97-C0B25B8F9495}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="first digital input"/>
		<Server Name="Input1LatchedFalling" GUID="{4A344BB3-882B-4424-AAC1-5355FA983251}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="latched falling edge of first digital input&#13;&#10;signal will stay until read-method is called"/>
		<Server Name="Input1LatchedRising" GUID="{B6BDBAE6-1996-4C9A-9E62-F9586C63D72E}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="latched rising edge of first digital input&#13;&#10;signal will stay until read-method is called"/>
		<Server Name="Input2" GUID="{5C3862B1-3B13-444C-AC68-7ABAD1D01C82}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="second digital input"/>
		<Server Name="Input2LatchedFalling" GUID="{3862811E-A228-4C93-AF1C-583A367EA847}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="latched falling edge of second digital input&#13;&#10;signal will stay until read-method is called"/>
		<Server Name="Input2LatchedRising" GUID="{1501D58D-5B78-4A43-B91F-FF46B63D63F4}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="latched rising edge of second digital input&#13;&#10;signal will stay until read-method is called"/>
		<Server Name="LatchPositionEncoderZeroPulse" GUID="{AC0ECFF1-743D-4271-875D-933B24A21E10}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Latched position of encoder zero pulse."/>
		<Server Name="LatchPositionInput1Falling" GUID="{5D75441C-E03D-4ABB-AC3F-BB8F080D5DC5}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Latched position of falling edge of input 1."/>
		<Server Name="LatchPositionInput1Rising" GUID="{F1CD2EB6-17C8-45CC-BD38-D18E893EF9A9}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Latched position of rising edge of input 1."/>
		<Server Name="LatchPositionInput2Falling" GUID="{19DF1EFF-3DEB-4F7D-96BE-F96A5606E4F0}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Latched position of falling edge of input 2."/>
		<Server Name="LatchPositionInput2Rising" GUID="{668D5FCF-C7EB-41F7-B4CE-7FDF2A70CBA8}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Latched position of rising edge of input 2."/>
		<Server Name="MaxCurrent" GUID="{C2470A11-2581-44CD-9BD4-CC5F44AF9C28}" Visualized="true" Initialize="true" WriteProtected="false" Retentive="false" Comment="Set maximum output current [mA] (effectiv value) as init value.&#13;&#10;If value is changed it is written asynchronosly.&#13;&#10;If the value is changed, it is transferred asynchronously to the module.&#13;&#10;Valid range is from 0 up to 5000."/>
		<Server Name="Online" GUID="{A6F24F8F-47D6-48DC-A83E-487725CC9C69}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Shows if hardware is ready.&#13;&#10;0 .. not ready&#13;&#10;1 .. ready"/>
		<Server Name="RefreshValues" GUID="{D0303A82-39DF-4337-8B29-1C23D94B11B4}" Visualized="true" Initialize="true" WriteProtected="false" Retentive="false" Comment="Set refresh of asynchrone values&#13;&#10; 0 .. do not refresh values&#13;&#10; 1 .. do cyclic refresh of values (every 200ms)&#13;&#10; 2 .. refresh values once"/>
		<Server Name="SetFreqOut" GUID="{7F85FD5E-5087-40B4-871F-710CB6C28B6B}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false" Comment="Frequency in Hz of one Microstep [1/64 Hz]&#13;&#10;64 Microsteps = 1 Fullstep"/>
		<Server Name="StateWord" GUID="{4D804F08-80D7-434B-87FE-AE2C913479D9}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Statusword with DS402 Standard :&#13;&#10;Bit1  .. ReadyToSwitchOn&#13;&#10;Bit2  .. SwitchedOn&#13;&#10;Bit3  .. OperationEnabled&#13;&#10;Bit4  .. Fault&#13;&#10;Bit5  .. VoltageDisabled&#13;&#10;Bit6  .. QuickStop&#13;&#10;Bit7  .. SwitchOnDisabled&#13;&#10;Bit8  .. Warning&#13;&#10;Bit9  .. ManufactureSpecific1&#13;&#10;Bit10 .. Remote&#13;&#10;Bit11 .. TargetReached&#13;&#10;Bit12 .. InternalLimitActive&#13;&#10;Bit13 .. OperationModeSpecific1&#13;&#10;Bit14 .. OperationModeSpecific2&#13;&#10;Bit15 .. Manufacture Specific2&#13;&#10;Bit16 .. Manufacture Specific3"/>
		<Server Name="TargetFreqOut" GUID="{57E1D39E-EBAD-41E5-A437-89B48FC90C98}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false" Comment="Set desired motor frequency in [1/64 Hz].&#13;&#10;This value is needed for adaptive Microstepping calculation.&#13;&#10;64 Microsteps = 1 Fullstep&#13;&#10;-1 .. feature is deactivated."/>
		<Server Name="VoltageOKEncoder" GUID="{26A9C083-399F-4368-B10C-62F5CB63133C}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Shows state of voltage supply of encoder.&#13;&#10;If the value is never refreshed it shows -2 147 483 632.&#13;&#10;- Value is read asynchronous&#13;&#10;0 .. Error at power supply.&#13;&#10;1 .. OK"/>
		<Server Name="ZPuls" GUID="{CCB5536D-5B92-4BB8-80A8-E89FED180089}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="It is 1 if incremental encoder zero position is passed."/>
		<Server Name="ZPulsLatched" GUID="{90D655C7-26F7-4F37-8903-593A86EF78F9}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="It is 1 if incremental encoder zero position is passed, a read resets the server"/>
		<Client Name="ABCountMode" Required="true" Internal="false" DefValue="1" Comment="Set A/B count mode if &quot;1 edge&quot; sampling is activated, as init value.&#13;&#10;0 .. A pulses, B direction&#13;&#10;1 .. true A/B (default)"/>
		<Client Name="CompModeVST" Required="true" Internal="false" DefValue="0" Comment="Set Compatibility mode to VST01x as init value.&#13;&#10;0 .. Frequency as 64 microsteps - default&#13;&#10;1 .. Frequency as 32 microsteps&#13;&#10;This setting affects all &quot;FrequencyLimitsIncrease&quot;, &quot;FrequencyLimitsDecrease&quot;, &quot;SetFreqOut&quot;, &quot;ActPosition&quot;, &#13;&#10;&quot;TargetFreqOut&quot; server and the &quot;Latched Position&quot; server if LatchType is latch virtual counter."/>
		<Client Name="EnableRegenResistor" Required="true" Internal="false" DefValue="0" Comment="Enable external regen resistor.&#13;&#10;0 .. disabled&#13;&#10;1 .. enabled"/>
		<Client Name="EncMode" Required="true" Internal="false" DefValue="0" Comment="Mode of the Incremental Encoder as init value.&#13;&#10;0 .. TTL&#13;&#10;1 .. RS422&#13;&#10;"/>
		<Client Name="EncoderSampling" Required="true" Internal="false" DefValue="3" Comment="Sampling of the Incremental Encoder.&#13;&#10;0 .. Encoder off&#13;&#10;1 .. 1-edge&#13;&#10;2 .. 2-edge&#13;&#10;3 .. 4-edge&#13;&#10;"/>
		<Client Name="InvertEncoder" Required="true" Internal="false" DefValue="0" Comment="Counting direction of the encoder as initvalue.&#13;&#10;0 .. Phase B non-inverted&#13;&#10;1 .. Phase B inverted&#13;&#10;&#13;&#10;"/>
		<Client Name="InvertZeroPosition" Required="true" Internal="false" DefValue="0" Comment="Inverts server ZPulse as initvalue.&#13;&#10;0..normal &#13;&#10;1..inverted&#13;&#10;"/>
		<Client Name="LatchType" Required="true" Internal="false" DefValue="0" Comment="0 .. latch virtual counter&#13;&#10;1 .. latch incremental encoder&#13;&#10;as initvalue"/>
		<Client Name="LoadThresholdBridge" Required="true" Internal="false" DefValue="90" Comment="Set threshold value for regen resistor load [%] to switch off bridge, as init value.&#13;&#10;If this limit is reached, the bridge is switched off.&#13;&#10;Valid Range is 0 up to 100% and default value is 90%."/>
		<Client Name="LoadThresholdResistor" Required="true" Internal="false" DefValue="100" Comment="Set threshold value for regen resistor load [%] to switch external resistor off, as init value. &#13;&#10;If this limit is reached, the bridge and the regen resistor is switched off.&#13;&#10;Valid Range is 0 up to 100% and default value is 100%."/>
		<Client Name="LoadThresholdWarning" Required="true" Internal="false" DefValue="80" Comment="Set threshold value for regen resistor load [%] to set the warning bit, as init value.&#13;&#10;Valid Range is 0 up to 100% and default value is 80%."/>
		<Client Name="RatedMaxPower" Required="true" Internal="false" DefValue="1000" Comment="Set value for rated maximum Power of regen resistor in [1/10 W] as init value.&#13;&#10;Value is needed for capacity calculation of resistor.&#13;&#10;Valid range is from 1 up to 65535."/>
		<Client Name="RegenResistance" Required="true" Internal="false" DefValue="150" Comment="Set resistance of regen resistor in [1/10 Ohm] as init value.&#13;&#10;Value is needed for capacity calculation of resistor.&#13;&#10;Valid range is from 1 up to 65535."/>
		<Client Name="StallCurrentReduction" Required="true" Internal="false" DefValue="0" Comment="Value to reduce MaxCurrent for the Stop Position [0,1%] as init value. &#13;&#10;Defaultvalue: 0 (no reduction in the stop position)&#13;&#10;Range: 0 - 1000 (0-100%)&#13;&#10;Stop Position means, the value of the server SetFreqOut is lower than the StallCurrentWindow, &#13;&#10;which can be set with StallCurrentWindow and is 0 by default."/>
		<Client Name="StallCurrentWindow" Required="true" Internal="false" DefValue="0" Comment="Set a window in which the StallCurrentReduction setting is active as init value.&#13;&#10;Valid range is from 0 up to 65535."/>
		<Client Name="SteppingHysteresis" Required="true" Internal="false" DefValue="64" Comment="Set automatically stepping hysterese in [1/64 Hz] if the value for decrease limit is zero as init value.&#13;&#10;This value is substracted from the corresponding increase limit value and set for the decrease limit."/>
		<Client Name="toFreqLimitTable" Required="false" Internal="false"/>
		<Client Name="UseOszi" Required="true" Internal="false" DefValue="0" Comment="Activate oszi function of modul as init value.&#13;&#10;To use the Oszi function, the methods &quot;StartMeasure ()&quot; and &quot;GetMeasureState ()&quot; must be used.&#13;&#10;&#13;&#10;0 .. deactivated&#13;&#10;1 .. activated"/>
	</Channels>
	<Separators>
		<Servers>
			<SepChn Position="1"/>
			<SepChn Position="16"/>
			<SepChn Position="50"/>
		</Servers>
		<Clients>
			<SepChn Position="6"/>
		</Clients>
	</Separators>
	<RevDoku>
		<Owner Company="Sigmatek" Author="PieSte"/>
		<Dokumentation Revision="1.2" Date="31.07.2018" Author="RamAnd" Company="Sigmatek" Description="LASAL Hardware Description (.lhd) file has been updated.&#13;&#10;Removed initialize flag from server TargetFreqOut."/>
		<Dokumentation Revision="1.1" Date="01.02.2018" Author="ZoePat" Company="Sigmatek" Description="An error has been fixed if server settings were written in the init()."/>
		<Dokumentation Revision="1.0" Date="22.11.2017" Author="ZoePat" Company="Sigmatek" Description="first release version."/>
	</RevDoku>
	<Network Name="ST151Base">
		<!-- List of Components in this network -->
		<Components>
			<Object
				Name       = "_base"
				GUID       = "{67C26B6D-7D2C-437E-9BFA-E85CD5AF43BC}"
				Class      = "SdiasBase"
				Position   = "(218,120)"
				Visualized = "true">
				<Channels>
					<Server Name="ClassState"/>
					<Server Name="DeviceID"/>
					<Server Name="FPGAVersion"/>
					<Server Name="HwVersion"/>
					<Server Name="LEDControl" Value="0"/>
					<Server Name="RetryCounter"/>
					<Server Name="SDOState"/>
					<Server Name="SerialNo"/>
					<Client Name="Place" Value="0"/>
					<Client Name="Required" Value="1"/>
					<Client Name="SdiasIn"/>
					<Client Name="ToStdLib"/>
				</Channels>
			</Object>
		</Components>
		<Comments>
		</Comments>
		<!-- List of Connections in this network -->
		<Connections>
			<Connection Source="this.ClassState" Destination="_base.ClassState" Vertices="(804,210),(632,210),"/>
			<Connection Source="this.DeviceID" Destination="_base.DeviceID" Vertices="(804,270),(632,270),"/>
			<Connection Source="this.FPGAVersion" Destination="_base.FPGAVersion" Vertices="(804,330),(632,330),"/>
			<Connection Source="this.SerialNo" Destination="_base.SerialNo" Vertices="(804,450),(632,450),"/>
			<Connection Source="this.RetryCounter" Destination="_base.RetryCounter" Vertices="(804,510),(632,510),"/>
			<Connection Source="this.LEDControl" Destination="_base.LEDControl" Vertices="(804,570),(632,570),"/>
			<Connection Source="_base.SdiasIn" Destination="this.SdiasIn" Vertices="(218,210),(38,210),"/>
			<Connection Source="_base.Place" Destination="this.Place" Vertices="(218,270),(38,270),"/>
			<Connection Source="_base.Required" Destination="this.Required" Vertices="(218,330),(38,330),"/>
			<Connection Source="this.HwVersion" Destination="_base.HwVersion" Vertices="(804,390),(632,390),"/>
			<Connection Source="this.SDOState" Destination="_base.SDOState" Vertices="(804,630),(632,630),"/>
		</Connections>
		<!-- Headerfiles -->
		<Options>
		</Options>
	</Network>
</Class>
*)
#pragma using SdiasBase

ST151Base : CLASS
: SdiasBase
	TYPE
	  a_uiOsziValues : ARRAY [0..ST151_OSZI_VALUES_DATA-1] OF UINT;
	  bd_EnabledFreqLimit : BDINT  //! <Type Public="true" Name="bd_EnabledFreqLimit"/>
	  [
	    1 FullStep,
	    2 HalfStep,
	    3 MicroStepping4,
	    4 MicroStepping8,
	    5 MicroStepping16,
	    6 MicroStepping32,
	    7 MicroStepping64,
	    8 Bit8,
	    9 Bit9,
	    10 Bit10,
	    11 Bit11,
	    12 Bit12,
	    13 Bit13,
	    14 Bit14,
	    15 Bit15,
	    16 Bit16,
	    17 Bit17,
	    18 Bit18,
	    19 Bit19,
	    20 Bit20,
	    21 Bit21,
	    22 Bit22,
	    23 Bit23,
	    24 Bit24,
	    25 Bit25,
	    26 Bit26,
	    27 Bit27,
	    28 Bit28,
	    29 Bit29,
	    30 Bit30,
	    31 Bit31,
	    32 Bit32,
	  ];
	  bd_ExtendedStateWord : BDINT  //! <Type Public="true" Name="bd_ExtendedStateWord"/>
	  [
	    1 ZeroPosition,
	    2 OverTempWarning,
	    3 OverTempFailure,
	    4 OverCurrentFailureGND,
	    5 OverCurrentFailureBridge1,
	    6 OverCurrentFailureBridge2,
	    7 Encoder5VOk,
	    8 Bit8,
	    9 BridgeVoltageTooLow,
	    10 BridgeVoltageTooHigh,
	    11 ExternEnableSTO1,
	    12 ExternEnableSTO2,
	    13 SafetyStartUpOK,
	    14 MotorEnableError,
	    15 ThreeTimeSyncInLost,
	    16 SafeRampDownPending,
	    17 LoadWarning,
	    18 LoadDisableBridge,
	    19 LoadDisableResistor,
	    20 Bit20,
	    21 Bit21,
	    22 Bit22,
	    23 Bit23,
	    24 Bit24,
	    25 Bit25,
	    26 Bit26,
	    27 Bit27,
	    28 Bit28,
	    29 Bit29,
	    30 Bit30,
	    31 Bit31,
	    32 Bit32,
	  ];
	  e_ActStepMode :
	  (
	    Microstepping_1,
	    Microstepping_2,
	    Microstepping_4,
	    Microstepping_8,
	    Microstepping_16,
	    Microstepping_32,
	    Microstepping_64
	  )$UDINT;
	  t_StatusWord : BINT
	  [
	    1 MotorEnabled,
	    2 Fault,
	    3 TemperatureOk,
	    4 OverCurrent,
	    5 STOSwitchOff,
	    6 STOTestSwitchOff,
	    7 STOReadyRestart,
	    8 ReadyToSwitchOn,
	    9 BrakeChopperOverCurrentLatch,
	    10 LatchIncZero,
	    11 LatchDigIn1Rise,
	    12 LatchDigIn1Fall,
	    13 LatchDigIn2Rise,  //! <Type Comment="Low bit of failure state depending on InternalLimitActive bit&#13;&#10;&#13;&#10;Meaning:&#13;&#10;2#00...No failure&#13;&#10;2#01...Overtemperature failure&#13;&#10;2#10...Overcurrent failure" Name="t_StatusWord.LatchDigIn2Rise"/>
	    14 LatchDigIn2Fall,  //! <Type Comment="High bit of failure state depending on InternalLimitActive bit&#13;&#10;&#13;&#10;Meaning:&#13;&#10;2#00...No failure&#13;&#10;2#01...Overtemperature failure&#13;&#10;2#10...Overcurrent failure" Name="t_StatusWord.LatchDigIn2Fall"/>
	    15 DigIn1,  //! <Type Comment="Low bit of failure state depending on InternalLimitActive bit&#13;&#10;&#13;&#10;Meaning:&#13;&#10;2#00...No failure&#13;&#10;2#01...Overtemperature failure&#13;&#10;2#10...Overcurrent failure" Name="t_StatusWord.DigIn1"/>
	    16 DigIn2,  //! <Type Comment="High bit of failure state depending on InternalLimitActive bit&#13;&#10;&#13;&#10;Meaning:&#13;&#10;2#00...No failure&#13;&#10;2#01...Overtemperature failure&#13;&#10;2#10...Overcurrent failure" Name="t_StatusWord.DigIn2"/>
	  ];
#pragma pack(push, 1)
	  t_s_ReadData : STRUCT
	    StateWord : t_StatusWord;
	    ActPos : UINT;
	    IncrementalEncoderValue : UINT;
	  END_STRUCT;
#pragma pack(pop)
	  t_ControlWord : BINT
	  [
	    1 SwitchOn,
	    2 FaultReset,
	    3 CurrentDropEnable,
	    4 CurrentIncrease,
	    5 HWEnableSofwareRampdownToggleBit,
	    6 QuitSTOOff,
	    7 RegenResistorEnable,
	    8 RegenResistorFaultReset,
	    9 SwitchMaxCurrent,  //! <Type Comment="0 .. internal counter&#13;&#10;1 .. incremental encoder" Name="t_ControlWord.SwitchMaxCurrent"/>
	    10 EnableStep64,
	    11 EnableStep32,
	    12 EnableStep16,
	    13 EnableStep8,
	    14 EnableStep4,
	    15 EnableHalfStep,
	    16 EnableFullStep,
	  ];
#pragma pack(push, 1)
	  t_s_WriteData : STRUCT
	    StepFrequencyReg : DINT;
	    ControlWord : t_ControlWord;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_Accesses : STRUCT
	    pReadData : ^t_s_ReadData;
	    pWriteData : ^t_s_WriteData;
	    sWriteData : t_s_WriteData;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_s_ControlAccess : STRUCT
	    AccessHandle : UDINT;
	    pControlByte : t_SDIAS_pControlByte;
	    pStateByte : t_SDIAS_pStateByte;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_s_OsziWrite : STRUCT
	    SamplesAfterTrigger : UINT;
	    TriggerLevel : UINT;
	    SampleTimePrescaler : UINT;
	    TriggerChannelSelect : USINT;
	    ControlOszi : BSINT
	    [
	      1 StartTriggering,
	      2 CancelTrigger,
	      3 RisingEdge,
	      4 FallingEdge,
	      5 Force,
	      6 Bit6,
	      7 Bit7,
	      8 Bit8,
	    ];
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_s_OsziRead : STRUCT
	    SizeOfRam : UDINT;
	    PointerOnLastSampleData : HDINT;
	    StateOszi : BSINT
	    [
	      1 Ready,
	      2 Triggered,
	      3 BufferOverflow,
	      4 Bit4,
	      5 Bit5,
	      6 Bit6,
	      7 Bit7,
	      8 Bit8,
	    ];
	    NbrOfChAvailable : USINT;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_AccessesOszi : STRUCT
	    WriteHeaderControl : t_s_ControlAccess;
	    pWriteHeader : ^t_s_OsziWrite;
	    sWriteOszi : t_s_OsziWrite;
	    ReadHeaderControl : t_s_ControlAccess;
	    pReadHeader : ^t_s_OsziRead;
	    aReadDataControl : ARRAY [0..ST151_OSZI_MAX_PDOREAD-1] OF t_s_ControlAccess;
	    apOsziData : ARRAY [0..ST151_OSZI_MAX_PDOREAD-1] OF ^a_uiOsziValues;
	    uiSamplesAfterTrigger : UINT;
	    uiSamplesBeforeTrigger : UINT;
	    bDataReady : DINT;
	    bSplitBuffer : BOOL;
	    uiDatalength1 : UINT;
	    uiDatalength2 : UINT;
	    eOsziData :
	    (
	      _OsziDataIdle,
	      _OsziTriggerStart,
	      _OsziResetTrigger,
	      _OsziWait4Reset,
	      _OsziWait4Trigger,
	      _OsziDisableRead,
	      _OsziGetData,
	      _OsziWait4Data,
	      _OsziFinished
	    )$UDINT;
	    sLastOsziState : t_s_OsziRead;
	    aLastOsziData : ARRAY [0..ST151_OSZI_MAX_SAMPLES-1] OF UINT;
	    pLastEntryOsziData : ^UINT;
	    pFirstEntryOsziData : ^UINT;
	    pToExternData : ^void;
	    usOsziTriggerOffset : USINT;
	    bMeasureStarted : BOOL;
	  END_STRUCT;
#pragma pack(pop)
	  t_bi_ReqSDOConfig : BINT
	  [
	    1 WriteConfigSDO1,
	    2 WriteConfigSDO2,
	    3 WriteConfigSDO3,
	    4 WriteConfigSDO4,
	    5 WriteConfigSDO5,
	    6 WriteConfigSDO6,
	    7 Bit7,
	    8 ReadConfigSDO1,
	    9 ReadConfigSDO2,
	    10 ReadConfigSDO3,
	    11 ReadConfigSDO4,
	    12 ReadConfigSDO5,
	    13 ReadConfigSDO6,
	    14 Bit14,
	    15 Bit15,
	    16 Bit16,
	  ];
	  t_bs_IsyncValue : BSINT
	  [
	    1 IncZero,
	    2 DigIn1Rise,
	    3 DigIn1Fall,
	    4 DigIn2Rise,
	    5 DigIn2Fall,
	  ];
	  t_e_InitSSW :
	  (
	    _ReadInitValuesFromModule,
	    _InitVariables,
	    _WriteConfigSDO,
	    _ReadConfigSDO,
	    _DisablePll,
	    _ReadPll,
	    _SetPll,
	    _Wait4FPGAReset,
	    _ActivateFPGA,
	    _Finish,
	    _InitError
	  )$UDINT;
	  t_e_SDOConfig :
	  (
	    _SDOConfig_Idle,
	    _SDOConfig_Write1,
	    _SDOConfig_Write2,
	    _SDOConfig_Write3,
	    _SDOConfig_Write4,
	    _SDOConfig_Write5,
	    _SDOConfig_Write6,
	    _SDOConfig_Read1,
	    _SDOConfig_Read2,
	    _SDOConfig_Read3,
	    _SDOConfig_Read4,
	    _SDOConfig_Read5,
	    _SDOConfig_Read6,
	    _SDOConfig_Finished,
	    _SDOConfig_Error
	  )$UDINT;
#pragma pack(push, 1)
	  t_EnabledFreqLimit : STRUCT
	    DecreaseFreq : bd_EnabledFreqLimit;
	    IncreaseFreq : bd_EnabledFreqLimit;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_FrequencyLimits : STRUCT
	    LimitDecrease : UDINT;  //! <Type Comment="save the higher limit" Name="t_FrequencyLimits.LimitDecrease"/>
	    LimitIncrease : UDINT;  //! <Type Comment="save the lower limit" Name="t_FrequencyLimits.LimitIncrease"/>
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_LatchValues : STRUCT
	    uiISyncIncZeroOldCounter : UINT;
	    uiISyncDigIn1RiseOldCounter : UINT;
	    uiISyncDigIn1FallOldCounter : UINT;
	    uiISyncDigIn2RiseOldCounter : UINT;
	    uiISyncDigIn2FallOldCounter : UINT;
	    sdISyncIncZeroOldPosition : DINT;
	    sdISyncDigIn1RiseOldPosition : DINT;
	    sdISyncDigIn1FallOldPosition : DINT;
	    sdISyncDigIn2RiseOldPosition : DINT;
	    sdISyncDigIn2FallOldPosition : DINT;
	    uiLatchInputZero : DINT;
	    uiLatchInputDigIn1Rising : UINT;
	    uiLatchInputDigIn1Falling : UINT;
	    uiLatchInputDigIn2Rising : UINT;
	    uiLatchInputDigIn2Falling : UINT;
	    bsValidISyncValue : t_bs_IsyncValue;
	    bsActiveISyncValue : t_bs_IsyncValue;
	    bsLatchReaded : t_bs_IsyncValue;
	    bResetActiveSyncValue : BOOL;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_SyncOut : STRUCT
	    uiOffset : UINT;
	    usPeriodMulti : USINT;
	    bsSyncStartDelay : BSINT
	    [
	      1 SyncStartDelay1,
	      2 SyncStartDelay2,
	      3 SyncStartDelay3,
	      4 SyncStartDelay4,
	    ];
	    hsSyncOutID : HSINT;
	    bsControlState : BSINT
	    [
	      1 SyncEnable,
	      2 StartDelayEnable,
	      3 SyncSelector,
	    ];
	    uiReserved : UINT;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_PllRegister : STRUCT
	    udSystemPerTime : UDINT;
	    udSystemPerTimeMeasure : UDINT;
	    bsStateControlReg : BSINT
	    [
	      1 locked_res1,
	      2 unlocked_res2,
	      3 Soft_enable,
	      4 res3,
	      5 res4,
	      6 res5,
	      7 res6,
	      8 res7,
	    ];
	    usSystemPeriodeDividier : USINT;
	    bsCompDelay : BSINT
	    [
	    ];
	    usReserved : USINT;
	    SyncOut0 : t_SyncOut;
	  END_STRUCT;
#pragma pack(pop)
	  t_ResponseState :
	  (
	    _idle,
	    _wait,
	    _valid
	  )$UDINT;
#pragma pack(push, 1)
	  t_s_AdaptiveSteppingCalc : STRUCT
	    usIncreaseActStepsActivated : USINT;
	    aIncreaseLimitsArrayEntry : ARRAY [0..ST151_MAXSTEPPING_MODES] OF USINT;
	    usDecreaseActStepsActivated : USINT;
	    aDecreaseLimitsArrayEntry : ARRAY [0..ST151_MAXSTEPPING_MODES] OF USINT;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_s_ConfigModule1 : STRUCT
	    ChopperOffTime : UINT;
	    FastDecayTime : UINT;
	    FrequLimitRising64 : UDINT;
	    FrequLimitRising32 : UDINT;
	    FrequLimitRising16 : UDINT;
	    FrequLimitRising8 : UDINT;
	    FrequLimitRising4 : UDINT;
	    FrequLimitRising2 : UDINT;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_s_ConfigModule2 : STRUCT
	    HWRampdownDeltaFrequency : UINT;
	    HWRampdownDeltaTime : UINT;
	    IncrementalEncoderSettings : BSINT
	    [
	      1 ZeroPosInversion,
	      2 PhaseBInversion,
	      3 EdgeSampling1,
	      4 EdgeSampling2,
	      5 TTL_RS422Mode,
	      6 ABCountMode,
	      7 LatchType,
	      8 Bit8,
	    ];
	    BlankingTimeRegister : USINT;
	    reserved1 : USINT;
	    reserved2 : USINT;
	    RatedMaximumPowerWatt : UINT;
	    RegenResistance : UINT;
	    LoadThresholdWarning : USINT;
	    LoadThresholdDisableResistor : USINT;
	    MaximumCurrentReg : UINT;
	    ReducedCurrentReg : UINT;
	    LoadThresholdDisableBridge : USINT;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_s_ConfigModule3 : STRUCT
	    LatchCntZPuls : UINT;
	    LatchCntInput1Rising : UINT;
	    LatchCntInput1Falling : UINT;
	    LatchCntInput2Rising : UINT;
	    LatchCntInput2Falling : UINT;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_s_ConfigModule4 : STRUCT
	    ExtendedMotorStateReg1 : BINT
	    [
	      1 ZeroPosition,
	      2 OverTempWarning,
	      3 OverTempFailure,
	      4 OverCurrentFailureGND,
	      5 OverCurrentFailureBridge1,
	      6 OverCurrentFailureBridge2,
	      7 Encoder5VOk,
	      8 Bit8,
	      9 BridgeVoltageTooLow,
	      10 BridgeVoltageTooHigh,
	      11 ExternEnableSTO1,
	      12 ExternEnableSTO2,
	      13 SafetyStartUpOK,
	      14 MotorEnableError,
	      15 ThreeTimeSyncInLost,
	      16 SafeRampDownPending,
	    ];
	    ExtendedMotorStateReg2 : BSINT
	    [
	      1 LoadWarning,
	      2 LoadDisableBridge,
	      3 LoadDisableResistor,
	    ];
	    ActRegenResistorLoad : USINT;
	    u2tValue : UDINT;
	    HBridgeVoltage : INT;
	    HBridgeTemperature : INT;
	    CommutationCntHBridge1 : UINT;
	    CommutationCntHBridge2 : UINT;
	    OntimeCntHBridge1 : UINT;
	    OntimeCntHBridge2 : UINT;
	    bsControllerStateReg : BSINT
	    [
	      1 NoCalibData,
	      2 InvalidCalibData,
	      3 Bit3,
	      4 ControllerOP,
	      5 Bit5,
	      6 Bit6,
	      7 Bit7,
	      8 Bit8,
	    ];
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_s_ConfigModule5 : STRUCT
	    bsControllerControlReg : BSINT
	    [
	      1 Bit1,
	      2 Bit2,
	      3 Bit3,
	      4 Bit4,
	      5 Bit5,
	      6 Bit6,
	      7 LoadConfigNew,
	      8 ControllerReset,
	    ];
	    reserved1 : UINT;
	    FrequLimitFalling32to64 : UDINT;
	    FrequLimitFalling16to32 : UDINT;
	    FrequLimitFalling8to16 : UDINT;
	    FrequLimitFalling4to8 : UDINT;
	    FrequLimitFalling2to4 : UDINT;
	    FrequLimitFalling1to2 : UDINT;
	    FastDecayTimeFallingStep : UINT;
	    ChopperOnTimeMin : UINT;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_s_ConfigModule6 : STRUCT
	    CurrentOffsetAdjBridge1 : INT;
	    CurrentOffsetAdjBridge2 : INT;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_s_ConfigModul : STRUCT
	    SDOData1 : t_s_ConfigModule1;
	    SDOData2 : t_s_ConfigModule2;
	    SDOData3 : t_s_ConfigModule3;
	    SDOData4 : t_s_ConfigModule4;
	    SDOData5 : t_s_ConfigModule5;
	    SDOData6 : t_s_ConfigModule6;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_SPI_CalibHeader : STRUCT
	    ud_Checksum : UDINT;
	    ud_ListVersion : UDINT;
	    ud_ListLength : UDINT;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_SPI_CalibData : STRUCT
	    SPI_Header : t_SPI_CalibHeader;
	    Offset0 : INT;
	    Multiplier0 : INT;
	    Divisor0 : UINT;
	    Offset1 : INT;
	    Multiplier1 : INT;
	    Divisor1 : UINT;
	    AI1Offset : INT;
	    AI1Multiplikator : INT;
	    AI1Divisor : INT;
	    AI2Offset : INT;
	    AI2Multiplikator : INT;
	    AI2Divisor : INT;
	    BridgeMaximumCurrent : UINT;
	    BridgeSupplyVoltageLowerThreshold : UINT;
	    BridgeSupplyVoltageUpperThreshold : UINT;
	    BridgeTemperatureWarningThreshold : UINT;
	    BridgeTemperatureErrorThreshold : UINT;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_SPIReadData : STRUCT
	    IDHeader : t_SPI_ListHeader;
	    udMaxDataLength : UDINT;
	    udActReadLength : UDINT;
	    udReadLength : UDINT;
	    udReadOffset : UDINT;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_SPIWriteData : STRUCT
	    usBytesToWrite : USINT;
	    usBytesActWrite : USINT;
	    usWriteOffset : USINT;
	  END_STRUCT;
#pragma pack(pop)
	END_TYPE
  //Servers:
	Online 	: SvrCh_DINT;
	EncoderPosition 	: SvrCh_DINT;
	ZPuls 	: SvrCh_DINT;
	ZPulsLatched 	: SvrCh_DINT;
	LatchPositionEncoderZeroPulse 	: SvrCh_DINT;
	LatchPositionInput1Rising 	: SvrCh_DINT;
	LatchPositionInput1Falling 	: SvrCh_DINT;
	LatchPositionInput2Rising 	: SvrCh_DINT;
	LatchPositionInput2Falling 	: SvrCh_DINT;
	Input1 	: SvrCh_DINT;
	Input1LatchedRising 	: SvrCh_DINT;
	Input1LatchedFalling 	: SvrCh_DINT;
	Input2 	: SvrCh_DINT;
	Input2LatchedRising 	: SvrCh_DINT;
	Input2LatchedFalling 	: SvrCh_DINT;
	Enable 	: SvrCh_DINT;
	ActPosition 	: SvrCh_DINT;
	SetFreqOut 	: SvrCh_DINT;
	TargetFreqOut 	: SvrCh_DINT;
	CurrentIncrease 	: SvrCh_DINT;
	ControlWord 	: SvrCh_DS402_Control;
	StateWord 	: SvrCh_DS402_State;
	ErrorInfo 	: SvrCh_BDINT;
	AxError 	: SvrCh_DINT;
	ErrorQuit 	: SvrCh_DINT;
	HWEnableSoftwareRampdown 	: SvrCh_DINT;
	HWRampdownDeltaFrequency 	: SvrCh_DINT;
	HWRampdownDeltaTime 	: SvrCh_DINT;
	MaxCurrent 	: SvrCh_DINT;
	CurrentOffsetAdjBridge1 	: SvrCh_DINT;
	CurrentOffsetAdjBridge2 	: SvrCh_DINT;
	ChopperOffTime 	: SvrCh_DINT;
	ChopperOnTimeMin 	: SvrCh_DINT;
	FastDecayTime 	: SvrCh_DINT;
	FastDecayTimeFallingStep 	: SvrCh_DINT;
	EnableSteps 	: SvrCh_bd_EnabledFreqLimit_PTofCls_ST151Base;
	FrequLimitIncrease2to1 	: SvrCh_UDINT;
	FrequLimitIncrease4to2 	: SvrCh_UDINT;
	FrequLimitIncrease8to4 	: SvrCh_UDINT;
	FrequLimitIncrease16to8 	: SvrCh_UDINT;
	FrequLimitIncrease32to16 	: SvrCh_UDINT;
	FrequLimitIncrease64to32 	: SvrCh_UDINT;
	FrequLimitDecrease1to2 	: SvrCh_UDINT;
	FrequLimitDecrease2to4 	: SvrCh_UDINT;
	FrequLimitDecrease4to8 	: SvrCh_UDINT;
	FrequLimitDecrease8to16 	: SvrCh_UDINT;
	FrequLimitDecrease16to32 	: SvrCh_UDINT;
	FrequLimitDecrease32to64 	: SvrCh_UDINT;
	RefreshValues 	: SvrCh_DINT;
	ExtendedStateWord 	: SvrCh_bd_ExtendedStateWord_PTofCls_ST151Base;
	HBridgeVoltage 	: SvrChCmd_DINT;
	HBridgeTemperature 	: SvrCh_DINT;
	ExternalEnable1 	: SvrCh_DINT;
	ExternalEnable2 	: SvrCh_DINT;
	ActRegenResistorLoad 	: SvrCh_DINT;
	VoltageOKEncoder 	: SvrCh_DINT;
  //Clients:
	InvertEncoder 	: CltCh_DINT;
	InvertZeroPosition 	: CltCh_DINT;
	EncoderSampling 	: CltCh_DINT;
	EncMode 	: CltCh_DINT;
	LatchType 	: CltCh_DINT;
	ABCountMode 	: CltCh_DINT;
	StallCurrentReduction 	: CltCh_DINT;
	StallCurrentWindow 	: CltCh_DINT;
	EnableRegenResistor 	: CltCh_DINT;
	RegenResistance 	: CltCh_DINT;
	RatedMaxPower 	: CltCh_DINT;
	LoadThresholdWarning 	: CltCh_DINT;
	LoadThresholdBridge 	: CltCh_DINT;
	LoadThresholdResistor 	: CltCh_DINT;
	SteppingHysteresis 	: CltCh_DINT;
	CompModeVST 	: CltCh_DINT;
	UseOszi 	: CltCh_DINT;
	toFreqLimitTable 	: CltCh_DINT;
  //Variables:
		sAccesses 	: t_Accesses;
		sAccessesOszi 	: t_AccessesOszi;
		eActStepping 	: e_ActStepMode;
		sWriteSDO 	: t_s_ConfigModul;
		sReadSDO 	: t_s_ConfigModul;
		udStallCurrentWindow 	: UDINT;
		uiPositionOld 	: UINT;
		eInitSSW 	: t_e_InitSSW;
		eInitSSWErrorStep 	: t_e_InitSSW;
		eResponseState 	: t_ResponseState;
		udSDOTimeOut 	: UDINT;
		aFrequencyLimit : ARRAY [0..ST151_MAXSTEPPING_MODES] OF t_FrequencyLimits;

		eActSDOConfigRdWr 	: t_e_SDOConfig;
		biReqSDOConfigRdWr 	: t_bi_ReqSDOConfig;
		bsRespSDOConfigRdWr 	: t_bi_ReqSDOConfig;
		usSDORetrys 	: USINT;
		uiOldCntVirtual 	: UINT;
		uiOldCntEncoder 	: UINT;
		sPLLRegister 	: t_PllRegister;
		sSPIReadData 	: t_SPIReadData;
		sSPIWriteData 	: t_SPIWriteData;
		sStepsNeeded 	: t_EnabledFreqLimit;
		dActDirection 	: DINT;
		dOldSetFrequ 	: DINT;
		udCyclicRefresh 	: UDINT;
		dFrequBandwith 	: DINT;
		dHighFrequencyLimit 	: DINT;
		sAdaptiveStepping 	: t_s_AdaptiveSteppingCalc;
		sLatchValues 	: t_LatchValues;
		udStartWaitTime 	: UDINT;
		udLimitsHysteresis 	: UDINT;
		usCompModeVST 	: USINT;
  //Functions:
				//! <Function Comment="Init-Methode of Class.&#13;&#10;&#13;&#10;This Methode needs to get called. In case the Methode gets overwritten, a call needs to bet installed." Name="Init"/>
	FUNCTION VIRTUAL GLOBAL Init;
	
	FUNCTION ST151Base
		VAR_OUTPUT
			ret_code 	: ConfStates;
		END_VAR;
				//! <Function Comment="Realtime Update Methode which runs in PreScan." Name="UpdateRt"/>
	FUNCTION VIRTUAL GLOBAL UpdateRt;
				//! <Function Comment="Realtime Update Methode which runs in PostScan." Name="UpdateRtPostScan"/>
	FUNCTION VIRTUAL GLOBAL UpdateRtPostScan;
				//! <Function Comment="Cyclic Update Methode which runs in PostScan." Name="UpdateCy"/>
	FUNCTION VIRTUAL GLOBAL UpdateCy;
	
	FUNCTION VIRTUAL GLOBAL AddAccesses
		VAR_OUTPUT
			eModuleInitState 	: iprStates;
		END_VAR;
				//! <Function Comment="Methode is called if this Module gets connected." Name="ConnectEvent"/>
	FUNCTION VIRTUAL GLOBAL ConnectEvent;
				//! <Function Comment="Methode is called if this Module gets disconnected." Name="DisconnectEvent"/>
	FUNCTION VIRTUAL GLOBAL DisconnectEvent;
				//! <Function Comment="Methode should be used to run a Statemachine to Initialize the Module." Name="InitModule"/>
	FUNCTION VIRTUAL GLOBAL InitModule
		VAR_OUTPUT
			eModuleInitState 	: iprStates;			//! <Variable Comment="Return BUSY until the Initialisation is finished." Name="InitModule.eModuleInitState"/>
		END_VAR;
				//! <Function Comment="This Methode should be used, to check the DeviceID of the Module." Name="CheckDeviceID"/>
	FUNCTION VIRTUAL GLOBAL CheckDeviceID
		VAR_INPUT
			udID2Check 	: UDINT;			//! <Variable Comment="Device ID of connected Module." Name="CheckDeviceID.udID2Check"/>
		END_VAR
		VAR_OUTPUT
			bIsOK 	: BOOL;			//! <Variable Comment="FALSE = Wrong DeviceID for Module&#13;&#10;TRUE  = DeviceID of Module is correct" Name="CheckDeviceID.bIsOK"/>
		END_VAR;
				//! <Function Comment="Methode to receive the Response in case of SDO-Communication." Name="ReceiveSDOResponse"/>
	FUNCTION VIRTUAL ReceiveSDOResponse
		VAR_INPUT
			eCommand 	: t_SDIAS_SDO_Cmd;			//! <Variable Comment="Type of SDO-Command" Name="ReceiveSDOResponse.eCommand"/>
			hOffset 	: HINT;			//! <Variable Comment="Address-Offset in Module." Name="ReceiveSDOResponse.hOffset"/>
			usLength 	: USINT;			//! <Variable Comment="Length of Data." Name="ReceiveSDOResponse.usLength"/>
			eResult 	: iprStates;			//! <Variable Comment="State of SDO-Communication." Name="ReceiveSDOResponse.eResult"/>
			pResponseBuffer 	: ^USINT;			//! <Variable Comment="Pointer of ResponseBuffer, where the SDO-Data is located." Name="ReceiveSDOResponse.pResponseBuffer"/>
			ResponseLength 	: USINT;			//! <Variable Comment="Size of the ResponseBuffer." Name="ReceiveSDOResponse.ResponseLength"/>
		END_VAR
		VAR_OUTPUT
			ret_code 	: iprStates;			//! <Variable Comment="Indicates if the Methode was successful." Name="ReceiveSDOResponse.ret_code"/>
		END_VAR;
	
	FUNCTION VIRTUAL GetTaskCfg
		VAR_OUTPUT
			TaskCfg 	: BDINT;			//! <Variable Comment="Select which tasks will be available for this module:&#13;&#10;Bit0..Realtime PreScan&#13;&#10;Bit1..Realtime PostScan&#13;&#10;Bit2..Cyclic&#13;&#10;&#13;&#10;e.g. if only realtime postscan is needed:&#13;&#10;2#010" Name="GetTaskCfg.TaskCfg"/>
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL GetDeviceID
		VAR_OUTPUT
			output 	: UDINT;
		END_VAR;
	
	FUNCTION CalcAdaptiveMicroStepping
		VAR_INPUT
			dTargetFrequency 	: DINT;
			dActSetFrequency 	: DINT;
		END_VAR
		VAR_OUTPUT
			dRetCode 	: DINT;
		END_VAR;
	
	FUNCTION SDORdWrData
		VAR_OUTPUT
			dRetCode 	: iprStates;
		END_VAR;
	
	FUNCTION CalcSimpleMode;
				//! <Function Comment="Start measuring of h-bridge voltage." Name="StartMeasure"/>
	FUNCTION GLOBAL StartMeasure
		VAR_INPUT
			pData 	: ^void;			//! <Variable Comment="pointer to memory area which must have a minimum size of 1024 bytes." Name="StartMeasure.pData"/>
			uiTriggerLevel 	: UINT;			//! <Variable Comment="set the trigger level in xx.xx [V]." Name="StartMeasure.uiTriggerLevel"/>
			uiSamplePrescaler 	: UINT;			//! <Variable Comment="Set a prescaler for recording of values.&#13;&#10;The values are recorded at 62,5 intervals.&#13;&#10;1 .. every value is recorded.&#13;&#10;10 .. every tenth value is recorded." Name="StartMeasure.uiSamplePrescaler"/>
			bStartStopMeasure 	: BOOL;			//! <Variable Comment="Start or stop measuring.&#13;&#10;0 .. stop measure&#13;&#10;1 .. start measure" Name="StartMeasure.bStartStopMeasure"/>
			usTriggerSetting 	: USINT;			//! <Variable Comment="set trigger mode:&#13;&#10;0 .. rising edge&#13;&#10;1 .. falling edge&#13;&#10;2 .. forced trigger" Name="StartMeasure.usTriggerSetting"/>
			usTriggerOffset 	: USINT;			//! <Variable Comment="set offset for trigger record:&#13;&#10;0 .. 0%&#13;&#10;1 .. -25%&#13;&#10;2 .. -50%&#13;&#10;3 .. -75%" Name="StartMeasure.usTriggerOffset"/>
		END_VAR
		VAR_OUTPUT
			dRetCode 	: DINT;			//! <Variable Comment="Returnvalue of function.&#13;&#10;0 .. ok&#13;&#10;-1 .. function not activated (client &quot;UseOszi&quot;)&#13;&#10;-2 .. data pointer not valid&#13;&#10;-3 .. usTriggerSetting not valid&#13;&#10;-4 .. usTriggerOffset not valid&#13;&#10;-5 .. measure is already started" Name="StartMeasure.dRetCode"/>
		END_VAR;
	
	FUNCTION GetMeasureData
		VAR_INPUT
			pData 	: ^void;
		END_VAR;
	
	FUNCTION SetSDORdWrStep
		VAR_INPUT
			eActStep 	: t_e_SDOConfig;
		END_VAR
		VAR_OUTPUT
			eNextStep 	: t_e_SDOConfig;
		END_VAR;
				//! <Function Comment="Get state of measuring." Name="GetMeasureState"/>
	FUNCTION GLOBAL GetMeasureState
		VAR_INPUT
			pbTriggered 	: ^BOOL := NIL;			//! <Variable Comment="Pointer to bool value.&#13;&#10;0 .. not triggerd&#13;&#10;1 .. triggerd" Name="GetMeasureState.pbTriggered"/>
		END_VAR
		VAR_OUTPUT
			dRetCode 	: DINT;			//! <Variable Comment="Returnvalue of methode.&#13;&#10;0 .. measure ready&#13;&#10;1 .. measure busy&#13;&#10;&#13;&#10;-1 .. pointer for pbTriggerd is not valid.&#13;&#10;-2 .. pointer for pbBufferOverflow is not valid.&#13;&#10;-3 .. no measure started&#13;&#10;" Name="GetMeasureState.dRetCode"/>
		END_VAR;
	
	FUNCTION GLOBAL GetActFreqLimits
		VAR_INPUT
			usValueIncDec 	: USINT;
			usArrayEntry 	: USINT;
			pusActCompMode 	: ^USINT;
		END_VAR
		VAR_OUTPUT
			udData 	: UDINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL ZPulsLatched::Read
		VAR_OUTPUT
			output (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL Input1LatchedRising::Read
		VAR_OUTPUT
			output (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL Input1LatchedFalling::Read
		VAR_OUTPUT
			output (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL Input2LatchedRising::Read
		VAR_OUTPUT
			output (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL Input2LatchedFalling::Read
		VAR_OUTPUT
			output (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL Enable::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL SetFreqOut::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL TargetFreqOut::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL CurrentIncrease::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL ControlWord::Write
		VAR_INPUT
			input (EAX) 	: DS402_Control;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DS402_Control;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL ErrorQuit::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL HWEnableSoftwareRampdown::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL HWRampdownDeltaFrequency::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL HWRampdownDeltaTime::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL MaxCurrent::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL CurrentOffsetAdjBridge1::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL CurrentOffsetAdjBridge2::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
				//! <Function Comment="Set fixed off-time of the PWM  [20ns steps] as init value.&#13;&#10;Valid range is from 1500 up to 65535." Name="ChopperOffTime.Write"/>
	FUNCTION VIRTUAL GLOBAL ChopperOffTime::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL ChopperOnTimeMin::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL FastDecayTime::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL FastDecayTimeFallingStep::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL EnableSteps::Write
		VAR_INPUT
			input (EAX) 	: ST151Base::bd_EnabledFreqLimit;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: ST151Base::bd_EnabledFreqLimit;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL FrequLimitIncrease2to1::Write
		VAR_INPUT
			input (EAX) 	: UDINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: UDINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL FrequLimitIncrease4to2::Write
		VAR_INPUT
			input (EAX) 	: UDINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: UDINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL FrequLimitIncrease8to4::Write
		VAR_INPUT
			input (EAX) 	: UDINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: UDINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL FrequLimitIncrease16to8::Write
		VAR_INPUT
			input (EAX) 	: UDINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: UDINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL FrequLimitIncrease32to16::Write
		VAR_INPUT
			input (EAX) 	: UDINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: UDINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL FrequLimitIncrease64to32::Write
		VAR_INPUT
			input (EAX) 	: UDINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: UDINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL FrequLimitDecrease1to2::Write
		VAR_INPUT
			input (EAX) 	: UDINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: UDINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL FrequLimitDecrease2to4::Write
		VAR_INPUT
			input (EAX) 	: UDINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: UDINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL FrequLimitDecrease4to8::Write
		VAR_INPUT
			input (EAX) 	: UDINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: UDINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL FrequLimitDecrease8to16::Write
		VAR_INPUT
			input (EAX) 	: UDINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: UDINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL FrequLimitDecrease16to32::Write
		VAR_INPUT
			input (EAX) 	: UDINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: UDINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL FrequLimitDecrease32to64::Write
		VAR_INPUT
			input (EAX) 	: UDINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: UDINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL RefreshValues::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

//}}LSL_DECLARATION


FUNCTION GLOBAL TAB ST151Base::@CT_
0$UINT,
2#0100000000000000$UINT, //TY_ST151BASE
1$UINT, 2$UINT, (SIZEOF(::ST151Base))$UINT, 
56$UINT, 18$UINT, 0$UINT, 
TO_UDINT(1832775974), "ST151Base", //Class
TO_UDINT(3175101883), "SdiasBase", 1$UINT, 58$UINT, //Baseclass
//Servers:
(::ST151Base.Online.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1858763116), "Online", 
(::ST151Base.EncoderPosition.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1101453613), "EncoderPosition", 
(::ST151Base.ZPuls.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3142960073), "ZPuls", 
(::ST151Base.ZPulsLatched.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3904789169), "ZPulsLatched", 
(::ST151Base.LatchPositionEncoderZeroPulse.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2850658915), "LatchPositionEncoderZeroPulse", 
(::ST151Base.LatchPositionInput1Rising.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(779300112), "LatchPositionInput1Rising", 
(::ST151Base.LatchPositionInput1Falling.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1493319658), "LatchPositionInput1Falling", 
(::ST151Base.LatchPositionInput2Rising.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(530265997), "LatchPositionInput2Rising", 
(::ST151Base.LatchPositionInput2Falling.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3616356361), "LatchPositionInput2Falling", 
(::ST151Base.Input1.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1344628668), "Input1", 
(::ST151Base.Input1LatchedRising.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2444548434), "Input1LatchedRising", 
(::ST151Base.Input1LatchedFalling.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3245332642), "Input1LatchedFalling", 
(::ST151Base.Input2.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3375117830), "Input2", 
(::ST151Base.Input2LatchedRising.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3990224009), "Input2LatchedRising", 
(::ST151Base.Input2LatchedFalling.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3490886363), "Input2LatchedFalling", 
(::ST151Base.Enable.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(56102836), "Enable", 
(::ST151Base.ActPosition.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3276766410), "ActPosition", 
(::ST151Base.SetFreqOut.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2717077001), "SetFreqOut", 
(::ST151Base.TargetFreqOut.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(560956402), "TargetFreqOut", 
(::ST151Base.CurrentIncrease.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3186795653), "CurrentIncrease", 
(::ST151Base.ControlWord.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2412184912), "ControlWord", 
(::ST151Base.StateWord.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1307193485), "StateWord", 
(::ST151Base.ErrorInfo.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2982181166), "ErrorInfo", 
(::ST151Base.AxError.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(4083589877), "AxError", 
(::ST151Base.ErrorQuit.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(971218924), "ErrorQuit", 
(::ST151Base.HWEnableSoftwareRampdown.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3920155135), "HWEnableSoftwareRampdown", 
(::ST151Base.HWRampdownDeltaFrequency.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(379348510), "HWRampdownDeltaFrequency", 
(::ST151Base.HWRampdownDeltaTime.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3778472805), "HWRampdownDeltaTime", 
(::ST151Base.MaxCurrent.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3107851838), "MaxCurrent", 
(::ST151Base.CurrentOffsetAdjBridge1.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2443390573), "CurrentOffsetAdjBridge1", 
(::ST151Base.CurrentOffsetAdjBridge2.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(145391575), "CurrentOffsetAdjBridge2", 
(::ST151Base.ChopperOffTime.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3473064912), "ChopperOffTime", 
(::ST151Base.ChopperOnTimeMin.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3499641779), "ChopperOnTimeMin", 
(::ST151Base.FastDecayTime.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(4141564292), "FastDecayTime", 
(::ST151Base.FastDecayTimeFallingStep.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(570086078), "FastDecayTimeFallingStep", 
(::ST151Base.EnableSteps.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(936401547), "EnableSteps", 
(::ST151Base.FrequLimitIncrease2to1.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(156681668), "FrequLimitIncrease2to1", 
(::ST151Base.FrequLimitIncrease4to2.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3040136098), "FrequLimitIncrease4to2", 
(::ST151Base.FrequLimitIncrease8to4.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(377606447), "FrequLimitIncrease8to4", 
(::ST151Base.FrequLimitIncrease16to8.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(289430222), "FrequLimitIncrease16to8", 
(::ST151Base.FrequLimitIncrease32to16.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(150956411), "FrequLimitIncrease32to16", 
(::ST151Base.FrequLimitIncrease64to32.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3794381811), "FrequLimitIncrease64to32", 
(::ST151Base.FrequLimitDecrease1to2.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1063566650), "FrequLimitDecrease1to2", 
(::ST151Base.FrequLimitDecrease2to4.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3300046817), "FrequLimitDecrease2to4", 
(::ST151Base.FrequLimitDecrease4to8.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3899630614), "FrequLimitDecrease4to8", 
(::ST151Base.FrequLimitDecrease8to16.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(4256626345), "FrequLimitDecrease8to16", 
(::ST151Base.FrequLimitDecrease16to32.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3588163539), "FrequLimitDecrease16to32", 
(::ST151Base.FrequLimitDecrease32to64.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(4186132840), "FrequLimitDecrease32to64", 
(::ST151Base.RefreshValues.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(246096433), "RefreshValues", 
(::ST151Base.ExtendedStateWord.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(4111536355), "ExtendedStateWord", 
(::ST151Base.HBridgeVoltage.pMeth)$UINT, _CH_CMD$UINT, 2#0000000000000000$UINT, TO_UDINT(3768684583), "HBridgeVoltage", 
(::ST151Base.HBridgeTemperature.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3626779542), "HBridgeTemperature", 
(::ST151Base.ExternalEnable1.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2664104702), "ExternalEnable1", 
(::ST151Base.ExternalEnable2.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(130175812), "ExternalEnable2", 
(::ST151Base.ActRegenResistorLoad.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3798045807), "ActRegenResistorLoad", 
(::ST151Base.VoltageOKEncoder.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2453190080), "VoltageOKEncoder", 
//Clients:
(::ST151Base.InvertEncoder.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(164824020), "InvertEncoder", 
(::ST151Base.InvertZeroPosition.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(2091988656), "InvertZeroPosition", 
(::ST151Base.EncoderSampling.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(1045480734), "EncoderSampling", 
(::ST151Base.EncMode.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(558217510), "EncMode", 
(::ST151Base.LatchType.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(2520966561), "LatchType", 
(::ST151Base.ABCountMode.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(4170972889), "ABCountMode", 
(::ST151Base.StallCurrentReduction.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(1882885897), "StallCurrentReduction", 
(::ST151Base.StallCurrentWindow.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(3355578397), "StallCurrentWindow", 
(::ST151Base.EnableRegenResistor.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(4259712462), "EnableRegenResistor", 
(::ST151Base.RegenResistance.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(953113481), "RegenResistance", 
(::ST151Base.RatedMaxPower.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(3559593992), "RatedMaxPower", 
(::ST151Base.LoadThresholdWarning.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(3691596640), "LoadThresholdWarning", 
(::ST151Base.LoadThresholdBridge.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(665387131), "LoadThresholdBridge", 
(::ST151Base.LoadThresholdResistor.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(957778385), "LoadThresholdResistor", 
(::ST151Base.SteppingHysteresis.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(2451591419), "SteppingHysteresis", 
(::ST151Base.CompModeVST.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(2125313607), "CompModeVST", 
(::ST151Base.UseOszi.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(340861030), "UseOszi", 
(::ST151Base.toFreqLimitTable.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(1778503361), "toFreqLimitTable", 
END_FUNCTION


#define USER_CNT_ST151Base 20

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_ST151Base] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION ST151Base::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
		nCmdSize	: UINT;
	END_VAR

	ret_code	:= SdiasBase::@STD();
	IF ret_code <> C_OK THEN
		RETURN;
	END_IF;
	nCmdSize		:= SdiasBase::ClassState.pMeth^.nCmds$UINT*SIZEOF(pVoid) + CMDMETH.Init;

	_memcpy((#vmt.CmdTable)$^USINT, SdiasBase::ClassState.pMeth, nCmdSize);
	vmt.CmdTable.nCmds		:= nSTDCMD + USER_CNT_ST151Base;
	vmt.CmdTable.Init		:= #Init();
#pragma warning (disable : 74)
	vmt.UserFcts[0]		:= #UpdateRt();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[1]		:= #UpdateRtPostScan();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[3]		:= #UpdateCy();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[4]		:= #AddAccesses();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[5]		:= #ConnectEvent();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[6]		:= #DisconnectEvent();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[7]		:= #InitModule();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[8]		:= #CheckDeviceID();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[9]		:= #ReceiveSDOResponse();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[13]		:= #GetTaskCfg();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[14]		:= #GetDeviceID();

#pragma warning (default : 74)
	SdiasBase::ClassState.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF SdiasBase::ClassState.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	ZPulsLatched.pMeth			:= StoreMethod( #ZPulsLatched::Read(), #M_NO_F() );
	IF ZPulsLatched.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	Input1LatchedRising.pMeth			:= StoreMethod( #Input1LatchedRising::Read(), #M_NO_F() );
	IF Input1LatchedRising.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	Input1LatchedFalling.pMeth			:= StoreMethod( #Input1LatchedFalling::Read(), #M_NO_F() );
	IF Input1LatchedFalling.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	Input2LatchedRising.pMeth			:= StoreMethod( #Input2LatchedRising::Read(), #M_NO_F() );
	IF Input2LatchedRising.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	Input2LatchedFalling.pMeth			:= StoreMethod( #Input2LatchedFalling::Read(), #M_NO_F() );
	IF Input2LatchedFalling.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	Enable.pMeth			:= StoreMethod( #M_RD_DIRECT(), #Enable::Write() );
	IF Enable.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	SetFreqOut.pMeth			:= StoreMethod( #M_RD_DIRECT(), #SetFreqOut::Write() );
	IF SetFreqOut.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	TargetFreqOut.pMeth			:= StoreMethod( #M_RD_DIRECT(), #TargetFreqOut::Write() );
	IF TargetFreqOut.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	CurrentIncrease.pMeth			:= StoreMethod( #M_RD_DIRECT(), #CurrentIncrease::Write() );
	IF CurrentIncrease.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	ControlWord.pMeth			:= StoreMethod( #M_RD_DIRECT(), #ControlWord::Write() );
	IF ControlWord.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	ErrorQuit.pMeth			:= StoreMethod( #M_RD_DIRECT(), #ErrorQuit::Write() );
	IF ErrorQuit.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	HWEnableSoftwareRampdown.pMeth			:= StoreMethod( #M_RD_DIRECT(), #HWEnableSoftwareRampdown::Write() );
	IF HWEnableSoftwareRampdown.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	HWRampdownDeltaFrequency.pMeth			:= StoreMethod( #M_RD_DIRECT(), #HWRampdownDeltaFrequency::Write() );
	IF HWRampdownDeltaFrequency.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	HWRampdownDeltaTime.pMeth			:= StoreMethod( #M_RD_DIRECT(), #HWRampdownDeltaTime::Write() );
	IF HWRampdownDeltaTime.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	MaxCurrent.pMeth			:= StoreMethod( #M_RD_DIRECT(), #MaxCurrent::Write() );
	IF MaxCurrent.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	CurrentOffsetAdjBridge1.pMeth			:= StoreMethod( #M_RD_DIRECT(), #CurrentOffsetAdjBridge1::Write() );
	IF CurrentOffsetAdjBridge1.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	CurrentOffsetAdjBridge2.pMeth			:= StoreMethod( #M_RD_DIRECT(), #CurrentOffsetAdjBridge2::Write() );
	IF CurrentOffsetAdjBridge2.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	ChopperOffTime.pMeth			:= StoreMethod( #M_RD_DIRECT(), #ChopperOffTime::Write() );
	IF ChopperOffTime.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	ChopperOnTimeMin.pMeth			:= StoreMethod( #M_RD_DIRECT(), #ChopperOnTimeMin::Write() );
	IF ChopperOnTimeMin.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	FastDecayTime.pMeth			:= StoreMethod( #M_RD_DIRECT(), #FastDecayTime::Write() );
	IF FastDecayTime.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	FastDecayTimeFallingStep.pMeth			:= StoreMethod( #M_RD_DIRECT(), #FastDecayTimeFallingStep::Write() );
	IF FastDecayTimeFallingStep.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	EnableSteps.pMeth			:= StoreMethod( #M_RD_DIRECT(), #EnableSteps::Write() );
	IF EnableSteps.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	FrequLimitIncrease2to1.pMeth			:= StoreMethod( #M_RD_DIRECT(), #FrequLimitIncrease2to1::Write() );
	IF FrequLimitIncrease2to1.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	FrequLimitIncrease4to2.pMeth			:= StoreMethod( #M_RD_DIRECT(), #FrequLimitIncrease4to2::Write() );
	IF FrequLimitIncrease4to2.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	FrequLimitIncrease8to4.pMeth			:= StoreMethod( #M_RD_DIRECT(), #FrequLimitIncrease8to4::Write() );
	IF FrequLimitIncrease8to4.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	FrequLimitIncrease16to8.pMeth			:= StoreMethod( #M_RD_DIRECT(), #FrequLimitIncrease16to8::Write() );
	IF FrequLimitIncrease16to8.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	FrequLimitIncrease32to16.pMeth			:= StoreMethod( #M_RD_DIRECT(), #FrequLimitIncrease32to16::Write() );
	IF FrequLimitIncrease32to16.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	FrequLimitIncrease64to32.pMeth			:= StoreMethod( #M_RD_DIRECT(), #FrequLimitIncrease64to32::Write() );
	IF FrequLimitIncrease64to32.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	FrequLimitDecrease1to2.pMeth			:= StoreMethod( #M_RD_DIRECT(), #FrequLimitDecrease1to2::Write() );
	IF FrequLimitDecrease1to2.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	FrequLimitDecrease2to4.pMeth			:= StoreMethod( #M_RD_DIRECT(), #FrequLimitDecrease2to4::Write() );
	IF FrequLimitDecrease2to4.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	FrequLimitDecrease4to8.pMeth			:= StoreMethod( #M_RD_DIRECT(), #FrequLimitDecrease4to8::Write() );
	IF FrequLimitDecrease4to8.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	FrequLimitDecrease8to16.pMeth			:= StoreMethod( #M_RD_DIRECT(), #FrequLimitDecrease8to16::Write() );
	IF FrequLimitDecrease8to16.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	FrequLimitDecrease16to32.pMeth			:= StoreMethod( #M_RD_DIRECT(), #FrequLimitDecrease16to32::Write() );
	IF FrequLimitDecrease16to32.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	FrequLimitDecrease32to64.pMeth			:= StoreMethod( #M_RD_DIRECT(), #FrequLimitDecrease32to64::Write() );
	IF FrequLimitDecrease32to64.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	RefreshValues.pMeth			:= StoreMethod( #M_RD_DIRECT(), #RefreshValues::Write() );
	IF RefreshValues.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	_memcpy((#vmt.CmdTable)$^USINT, HBridgeVoltage.pMeth, SIZEOF(CMDMETH));
	vmt.CmdTable.nCmds		:= nSTDCMD;
	HBridgeVoltage.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF HBridgeVoltage.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	ret_code	:= ST151Base();

END_FUNCTION

//{{LSL_IMPLEMENTATION
FUNCTION VIRTUAL GLOBAL ST151Base::Init
  //call base class
  SdiasBase::Init();
  
  if _FirstScan then    
    //initialize CompModeVST to avoid division error if hardware is not ok
    usCompModeVST := 1;
    
    // show deactivated at startup (was init value on server before, but since it has not been written to the module on startup it's a init value here now)
    TargetFreqOut := -1;
  end_if;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL ST151Base::UpdateRt
  VAR
    ui_temp       : UINT;
    si_delta      : INT;
    TempReadData  : t_s_ReadData;
    bsLatchActual : t_bs_IsyncValue;
    TempReadOsziData : t_s_OsziRead;
    usTempCnt : USINT;
    uiActReadLength : UINT;
    uiTempLength : UINT;
    uiToLastEntryLength : UINT;
    bTempBool : BOOL;
    tmpStateWord : DS402_State;
  END_VAR
    
  TempReadData := sAccesses.pReadData^;
  
  ZPuls := TempReadData.StateWord.LatchIncZero;
  
  if TempReadData.StateWord.LatchIncZero = 1 then
    ZPulsLatched := TempReadData.StateWord.LatchIncZero;
  end_if;
  
  //Update Digital Inputs  
  Input1 := TempReadData.StateWord.DigIn1;
  Input2 := TempReadData.StateWord.DigIn2;    
  
  bsLatchActual := ((TempReadData.StateWord shr 9) AND 2#11111)$t_bs_IsyncValue;

  if EncoderSampling & LatchType then
    if bsLatchActual.IncZero then
      sLatchValues.uiISyncIncZeroOldCounter  := uiOldCntEncoder;
      sLatchValues.sdISyncIncZeroOldPosition := EncoderPosition;
    end_if;
    if bsLatchActual.DigIn1Rise then
      sLatchValues.uiISyncDigIn1RiseOldCounter  := uiOldCntEncoder;
      sLatchValues.sdISyncDigIn1RiseOldPosition := EncoderPosition;
    end_if;
    if bsLatchActual.DigIn1Fall then
      sLatchValues.uiISyncDigIn1FallOldCounter  := uiOldCntEncoder;
      sLatchValues.sdISyncDigIn1FallOldPosition := EncoderPosition;
    end_if;
    if bsLatchActual.DigIn2Rise then
      sLatchValues.uiISyncDigIn2RiseOldCounter  := uiOldCntEncoder;
      sLatchValues.sdISyncDigIn2RiseOldPosition := EncoderPosition;
    end_if;
    if bsLatchActual.DigIn2Fall then
      sLatchValues.uiISyncDigIn2FallOldCounter  := uiOldCntEncoder;
      sLatchValues.sdISyncDigIn2FallOldPosition := EncoderPosition;
    end_if;
  else
    //virtual position have no z puls
    if bsLatchActual.IncZero then
      sLatchValues.uiISyncIncZeroOldCounter  := uiOldCntEncoder;
      sLatchValues.sdISyncIncZeroOldPosition := EncoderPosition;
    end_if;
    if bsLatchActual.DigIn1Rise then
      sLatchValues.uiISyncDigIn1RiseOldCounter  := uiOldCntVirtual;
      sLatchValues.sdISyncDigIn1RiseOldPosition := ActPosition;
    end_if;
    if bsLatchActual.DigIn1Fall then
      sLatchValues.uiISyncDigIn1FallOldCounter  := uiOldCntVirtual;
      sLatchValues.sdISyncDigIn1FallOldPosition := ActPosition;
    end_if;
    if bsLatchActual.DigIn2Rise then
      sLatchValues.uiISyncDigIn2RiseOldCounter  := uiOldCntVirtual;
      sLatchValues.sdISyncDigIn2RiseOldPosition := ActPosition;
    end_if;
    if bsLatchActual.DigIn2Fall then
      sLatchValues.uiISyncDigIn2FallOldCounter  := uiOldCntVirtual;
      sLatchValues.sdISyncDigIn2FallOldPosition := ActPosition;
    end_if;
  end_if;  
        
  //actual encoder position
  ui_temp         := TempReadData.IncrementalEncoderValue;
  si_delta        := to_int(ui_temp - uiOldCntEncoder);
  EncoderPosition += to_dint(si_delta);
  uiOldCntEncoder := ui_temp;
  
  //actual virtual position
  ui_temp         := TempReadData.ActPos;
  si_delta        := to_int(ui_temp - uiOldCntVirtual);
  ActPosition     += to_dint(si_delta/usCompModeVST);
  uiOldCntVirtual := ui_temp;
  if si_delta mod usCompModeVST then
    if si_delta > 0 then
      uiOldCntVirtual -= 1;
    else
      uiOldCntVirtual += 1;      
    end_if;
  end_if;
  
  //check for changed latched bits while reading latch counter
  if sLatchValues.bResetActiveSyncValue 
  & bsLatchActual <> sLatchValues.bsValidISyncValue then
    sLatchValues.bsActiveISyncValue    := 0;
    sLatchValues.bResetActiveSyncValue := FALSE; 
  end_if;  
      
  // check for latched bits
  if bsLatchActual | sLatchValues.bsLatchReaded then
  
    //Input1 rising latched
    if ( TempReadData.StateWord.LatchDigIn1Rise ) | sLatchValues.bsLatchReaded.DigIn1Rise then
      sLatchValues.bsLatchReaded.DigIn1Rise := FALSE;
      Input1LatchedRising      := TempReadData.StateWord.LatchDigIn1Rise; //Reset of Bit is done with Read-Access
    end_if;    
    
    //Input1 falling latched
    if ( TempReadData.StateWord.LatchDigIn1Fall ) | sLatchValues.bsLatchReaded.DigIn1Fall then
      sLatchValues.bsLatchReaded.DigIn1Fall := FALSE;
      Input1LatchedFalling     := TempReadData.StateWord.LatchDigIn1Fall; //Reset of Bit is done with Read-Access
    end_if;    
    
    //Input2 rising latched
    if ( TempReadData.StateWord.LatchDigIn2Rise ) | sLatchValues.bsLatchReaded.DigIn2Rise then
      sLatchValues.bsLatchReaded.DigIn2Rise := FALSE;
      Input2LatchedRising      := TempReadData.StateWord.LatchDigIn2Rise; //Reset of Bit is done with Read-Access
    end_if;    
    
    //Input2 falling latched
    if ( TempReadData.StateWord.LatchDigIn2Fall ) | sLatchValues.bsLatchReaded.DigIn2Fall then
      sLatchValues.bsLatchReaded.DigIn2Fall := FALSE;
      Input2LatchedFalling     := TempReadData.StateWord.LatchDigIn2Fall; //Reset of Bit is done with Read-Access
    end_if;    
    
    //Zpuls Latched
    if sLatchValues.bsLatchReaded.IncZero then
      sLatchValues.bsLatchReaded.IncZero := FALSE;
      ZPulsLatched          := TempReadData.StateWord.LatchIncZero;
    end_if;
    
    if bsLatchActual <> sLatchValues.bsActiveISyncValue then
      //save actual latch values to read per sdo.
      sLatchValues.bsActiveISyncValue    := sLatchValues.bsActiveISyncValue or bsLatchActual;
    end_if;      
  end_if;   
  
  tmpStateWord                    := 0;
  tmpStateWord.OperationEnabled   := TempReadData.StateWord.MotorEnabled;
  tmpStateWord.ReadyToSwitchOn    := TempReadData.StateWord.ReadyToSwitchOn;
  bTempBool                       := TempReadData.StateWord.ReadyToSwitchOn AND (TempReadData.StateWord.STOSwitchOff = 0);
  tmpStateWord.SwitchedOn         := bTempBool AND (TempReadData.StateWord.Fault = 0);
  tmpStateWord.Warning            := ( TempReadData.StateWord.TemperatureOK = 0 );
  AxError := tmpStateWord.Fault   := TempReadData.StateWord.Fault;
  ErrorInfo$BINT                  := (TempReadData.StateWord and ST151_ERROR_BITMASK_STATE_WORD) xor 0x0004;
  StateWord                       := tmpStateWord;
  //class is ok
  Online  := 1;
  
  //read oszi data if activated
  if UseOszi then
    TempReadOsziData := sAccessesOszi.pReadHeader^;
    uiActReadLength  := 0;
    case sAccessesOszi.eOsziData of
      //*********************************************************************************************************
      _OsziDataIdle:
      
      //*********************************************************************************************************
      _OsziTriggerStart:
        sAccessesOszi.eOsziData := _OsziResetTrigger;
      
      //*********************************************************************************************************
      _OsziResetTrigger:
        sAccessesOszi.sWriteOszi.ControlOszi.StartTriggering := FALSE;
        udStartWaitTime := ops.tAbsolute;
//        sAccessesOszi.eOsziData := _OsziWait4Reset;
      
      //*********************************************************************************************************
      _OsziWait4Reset:
        if (ops.tAbsolute-udStartWaitTime) >= 5 then
          sAccessesOszi.eOsziData := _OsziWait4Trigger;        
        end_if;
        
      //*********************************************************************************************************
      _OsziWait4Trigger:
        sAccessesOszi.sLastOsziState.StateOszi := TempReadOsziData.StateOszi;
        if TempReadOsziData.StateOszi.Ready & TempReadOsziData.StateOszi.Triggered then
          sAccessesOszi.sLastOsziState       := TempReadOsziData;
          //enable accesses
          for usTempCnt := 0 to ST151_OSZI_MAX_PDOREAD-1 do
            if sAccessesOszi.aReadDataControl[usTempCnt].pControlByte then
              //Start Read-Access to Module (Set ControlWord in DPRam)
              sAccessesOszi.aReadDataControl[usTempCnt].pControlByte^ := TRUE;
              uiActReadLength += ST151_OSZI_ONE_PDOSIZE;
            end_if;
          end_for; 
          sAccessesOszi.eOsziData := _OsziDisableRead;
        end_if;          
          
      //*********************************************************************************************************
      _OsziDisableRead:
        //disable read access
        for usTempCnt := 0 to ST151_OSZI_MAX_PDOREAD-1 do
          if sAccessesOszi.aReadDataControl[usTempCnt].pControlByte then
            //Stop Read-Access to Module (Set ControlWord in DPRam)
            sAccessesOszi.aReadDataControl[usTempCnt].pControlByte^ := FALSE;
            uiActReadLength += ST151_OSZI_ONE_PDOSIZE;
          end_if;
        end_for;
        sAccessesOszi.eOsziData := _OsziWait4Data;        
            
      //*********************************************************************************************************
      _OsziWait4Data:
        sAccessesOszi.eOsziData := _OsziGetData;      
      
      //*********************************************************************************************************
      _OsziGetData:
        for usTempCnt := 0 to ST151_OSZI_MAX_PDOREAD-1 do   
          uiTempLength := (usTempCnt+1)*ST151_OSZI_ONE_PDOSIZE;
          if uiTempLength > ST151_OSZI_BUFFER_SIZE then
            uiTempLength := ST151_OSZI_BUFFER_SIZE - (usTempCnt*ST151_OSZI_ONE_PDOSIZE);
          else
            uiTempLength := ST151_OSZI_ONE_PDOSIZE;
          end_if;     
          _memcpy(ptr1:=#sAccessesOszi.aLastOsziData[(((ST151_OSZI_ONE_PDOSIZE*usTempCnt)/sizeof(UINT)))], ptr2:=sAccessesOszi.apOsziData[usTempCnt], cntr:=uiTempLength);      
        end_for;
        
        uiToLastEntryLength := (sAccessesOszi.sLastOsziState.PointerOnLastSampleData$UINT - ST151_OSZI_READPOINTER_OFFSET + sizeof(UINT));
        sAccessesOszi.pLastEntryOsziData := (#sAccessesOszi.aLastOsziData[0] + uiToLastEntryLength - sizeof(UINT));
        sAccessesOszi.uiDatalength1      := uiToLastEntryLength;      
        
        if uiToLastEntryLength = ST151_OSZI_BUFFER_SIZE then
          sAccessesOszi.pFirstEntryOsziData := #sAccessesOszi.aLastOsziData[0];
          sAccessesOszi.bSplitBuffer        := FALSE;
        else
          sAccessesOszi.uiDatalength2       := ST151_OSZI_BUFFER_SIZE-sAccessesOszi.uiDatalength1;
          sAccessesOszi.pFirstEntryOsziData := (#sAccessesOszi.aLastOsziData+(ST151_OSZI_BUFFER_SIZE-sAccessesOszi.uiDatalength2));
          sAccessesOszi.bSplitBuffer        := TRUE;
        end_if;
        
        //copy data to application
        GetMeasureData(pData:=sAccessesOszi.pToExternData);
        sAccessesOszi.bDataReady := TRUE;
        sAccessesOszi.eOsziData  := _OsziFinished;      
      
      //*********************************************************************************************************
      _OsziFinished:
        sAccessesOszi.eOsziData  := _OsziDataIdle;     
      
    end_case;    
  end_if;
  
END_FUNCTION


FUNCTION VIRTUAL GLOBAL ST151Base::UpdateRtPostScan
    
  sAccesses.sWriteData.ControlWord.HWEnableSofwareRampdownToggleBit := sAccesses.sWriteData.ControlWord.HWEnableSofwareRampdownToggleBit XOR to_BOOL(HWEnableSoftwareRampdown);
  sAccesses.pWriteData^ := sAccesses.sWriteData;
  
  if sAccesses.sWriteData.ControlWord.FaultReset then
    sAccesses.sWriteData.ControlWord.FaultReset := FALSE;
    sAccesses.sWriteData.ControlWord.QuitSTOOff := FALSE;
    sAccesses.sWriteData.ControlWord.RegenResistorFaultReset := FALSE;
    ControlWord.ResetFault := FALSE;
    ErrorQuit              := 0;
  end_if;
  
  if UseOszi then  
    sAccessesOszi.pWriteHeader^ := sAccessesOszi.sWriteOszi;
    if sAccessesOszi.eOsziData = _OsziResetTrigger then
      if sAccessesOszi.sWriteOszi.ControlOszi.CancelTrigger = FALSE then        
        sAccessesOszi.eOsziData := _OsziWait4Reset;
      else
        sAccessesOszi.eOsziData := _OsziFinished;
      end_if;
      sAccessesOszi.sWriteOszi.ControlOszi.StartTriggering := FALSE;
      sAccessesOszi.sWriteOszi.ControlOszi.CancelTrigger := FALSE; 
    end_if;
  end_if;
   
END_FUNCTION


FUNCTION VIRTUAL GLOBAL ST151Base::UpdateCy
  VAR
  	dRetCode : iprStates;
    iDeltaPos : INT;
    pbiTempErrorInfo :^BINT;
    usTempCompMode : USINT;
  END_VAR
  
  //Refresh cyclic values
  if (((ops.tAbsolute - udCyclicRefresh) >= ST151_CYCLICREFRESHDATA_TIME) & (RefreshValues = 1)) then
    udCyclicRefresh := ops.tAbsolute;
    biReqSDOConfigRdWr.ReadConfigSDO4 := TRUE;
  end_if; 
  
  if (sLatchValues.bsActiveISyncValue & sLatchValues.bResetActiveSyncValue = FALSE) then
    biReqSDOConfigRdWr.ReadConfigSDO3 := TRUE;
  end_if;
  
  //read-write sdo data to module
  if biReqSDOConfigRdWr | eActSDOConfigRdWr <> _SDOConfig_Idle then
    dRetCode := SDORdWrData();
    if dRetCode = Ready then
      //all OK
    elsif dRetCode = Error then
      //error occured while read - write sdo
    end_if;
  end_if;  
  
  //new cyclic data is available
  if bsRespSDOConfigRdWr.ReadConfigSDO4 = TRUE then
    if RefreshValues <> 0 then
      ExtendedStateWord    := sReadSDO.SDOData4.ExtendedMotorStateReg1$bd_ExtendedStateWord and 0xFFFFFF;
  //    DC24VOk := sReadSDO.SDOData3.ExtendedMotorStateReg1.Bit8;
      VoltageOKEncoder     := sReadSDO.SDOData4.ExtendedMotorStateReg1.Encoder5VOk;
      HBridgeVoltage       := sReadSDO.SDOData4.HBridgeVoltage;
      HBridgeTemperature   := sReadSDO.SDOData4.HBridgeTemperature;
      ExternalEnable1      := sReadSDO.SDOData4.ExtendedMotorStateReg1.ExternEnableSTO1;
      ExternalEnable2      := sReadSDO.SDOData4.ExtendedMotorStateReg1.ExternEnableSTO2;
      ActRegenResistorLoad  := sReadSDO.SDOData4.ActRegenResistorLoad;
      pbiTempErrorInfo     := (#ErrorInfo+2)$^BINT;
      pbiTempErrorInfo^    := (sReadSDO.SDOData4.ExtendedMotorStateReg1 and ST151_ERROR_BITMASK_EXTENDED_STATE_WORD) xor 0x1C00;
      pbiTempErrorInfo^.1  := sReadSDO.SDOData4.ExtendedMotorStateReg2.LoadWarning;
      pbiTempErrorInfo^.7  := sReadSDO.SDOData4.ExtendedMotorStateReg2.LoadDisableBridge;
      pbiTempErrorInfo^.8  := sReadSDO.SDOData4.ExtendedMotorStateReg2.LoadDisableResistor;
      if RefreshValues = 2 then
        RefreshValues := 0;
      end_if;
    end_if;;
    bsRespSDOConfigRdWr.ReadConfigSDO4 := FALSE;
  end_if;
    
  //new latchposition is available
  if bsRespSDOConfigRdWr.ReadConfigSDO3 = TRUE then
    if sLatchValues.bsValidISyncValue then
      if LatchType = 1 then      
        usTempCompMode := 1;
      else
        usTempCompMode := usCompModeVST;
      end_if;  
        if sLatchValues.bsValidISyncValue.IncZero then
          sLatchValues.uiLatchInputZero := sReadSDO.SDOData3.LatchCntZPuls;
          iDeltaPos := to_int(sLatchValues.uiLatchInputZero - sLatchValues.uiISyncIncZeroOldCounter);
          LatchPositionEncoderZeroPulse := sLatchValues.sdISyncIncZeroOldPosition + to_dint(iDeltaPos);        
        end_if;
        if sLatchValues.bsValidISyncValue.DigIn1Rise & sReadSDO.SDOData3.LatchCntInput1Rising then
          sLatchValues.uiLatchInputDigIn1Rising := sReadSDO.SDOData3.LatchCntInput1Rising;
          iDeltaPos := to_int(sLatchValues.uiLatchInputDigIn1Rising - sLatchValues.uiISyncDigIn1RiseOldCounter)/usTempCompMode;
          LatchPositionInput1Rising := sLatchValues.sdISyncDigIn1RiseOldPosition + to_dint(iDeltaPos);
        end_if;
        if sLatchValues.bsValidISyncValue.DigIn1Fall & sReadSDO.SDOData3.LatchCntInput1Falling then
          sLatchValues.uiLatchInputDigIn1Falling := sReadSDO.SDOData3.LatchCntInput1Falling;
          iDeltaPos := to_int(sLatchValues.uiLatchInputDigIn1Falling - sLatchValues.uiISyncDigIn1FallOldCounter)/usTempCompMode;
          LatchPositionInput1Falling := sLatchValues.sdISyncDigIn1FallOldPosition + to_dint(iDeltaPos);
        end_if;
        if sLatchValues.bsValidISyncValue.DigIn2Rise  & sReadSDO.SDOData3.LatchCntInput2Rising then
          sLatchValues.uiLatchInputDigIn2Rising := sReadSDO.SDOData3.LatchCntInput2Rising;
          iDeltaPos := to_int(sLatchValues.uiLatchInputDigIn2Rising - sLatchValues.uiISyncDigIn2RiseOldCounter)/usTempCompMode;
          LatchPositionInput2Rising := sLatchValues.sdISyncDigIn2RiseOldPosition + to_dint(iDeltaPos);
        end_if;
        if sLatchValues.bsValidISyncValue.DigIn2Fall & sReadSDO.SDOData3.LatchCntInput2Falling then
          sLatchValues.uiLatchInputDigIn2Falling := sReadSDO.SDOData3.LatchCntInput2Falling;
          iDeltaPos := to_int(sLatchValues.uiLatchInputDigIn2Falling - sLatchValues.uiISyncDigIn2FallOldCounter)/usTempCompMode;
          LatchPositionInput2Falling := sLatchValues.sdISyncDigIn2FallOldPosition + to_dint(iDeltaPos);
        end_if;
        
      sLatchValues.bsValidISyncValue := 0;
    end_if;
    bsRespSDOConfigRdWr.ReadConfigSDO3 := FALSE;
  end_if;
  
END_FUNCTION


FUNCTION VIRTUAL GLOBAL ST151Base::ConnectEvent
  
  // start the accesses on the SDIAS (initialize the control byte in the DPRAM)
  //Read Access
  if DefaultAccesses.ReadAccess.pControlByte then
    sAccesses.pReadData := DefaultAccesses.ReadAccess.pData$^t_s_ReadData;
    
    DefaultAccesses.ReadAccess.pControlByte^.EnableDO := TRUE;
  else
    eInitState := _DOHandleInvalid;
    return;
  end_if;
  
  //Write Access
  if DefaultAccesses.WriteAccess.pControlByte then
    sAccesses.pWriteData := DefaultAccesses.WriteAccess.pData$^t_s_WriteData;
    
    DefaultAccesses.WriteAccess.pControlByte^.EnableDO := TRUE;
  else
    eInitState := _DOHandleInvalid;
    return;
  end_if;  
  
  if UseOszi then  
    if sAccessesOszi.ReadHeaderControl.pControlByte then
      //Start Read-Access to Module (Set ControlWord in DPRam)
      sAccessesOszi.ReadHeaderControl.pControlByte^.EnableDO := true;
    else
      //No ControlWord available
      eInitState := _DOHandleInvalid;
      return;
    end_if;
  
    //Write Access
    if sAccessesOszi.WriteHeaderControl.pControlByte then
      //Start Write-Access to Module (Set ControlWord in DPRam)
      sAccessesOszi.WriteHeaderControl.pControlByte^.EnableDO := true;
    else  
      //No ControlWord available
      eInitState := _DOHandleInvalid;
      return;
    end_if;        
  end_if;  
  
  //The writing of the configuration must be deactivated here in order to read the default values of the module first. The desired settings are then written automatically.
  biReqSDOConfigRdWr.WriteConfigSDO1 := FALSE;
  biReqSDOConfigRdWr.WriteConfigSDO2 := FALSE;
  biReqSDOConfigRdWr.WriteConfigSDO3 := FALSE;
  biReqSDOConfigRdWr.WriteConfigSDO4 := FALSE;
  biReqSDOConfigRdWr.WriteConfigSDO5 := FALSE;
  biReqSDOConfigRdWr.WriteConfigSDO6 := FALSE;

  biReqSDOConfigRdWr.ReadConfigSDO1 := TRUE;
  biReqSDOConfigRdWr.ReadConfigSDO2 := TRUE;
  biReqSDOConfigRdWr.ReadConfigSDO3 := TRUE;
  biReqSDOConfigRdWr.ReadConfigSDO4 := TRUE;
  biReqSDOConfigRdWr.ReadConfigSDO5 := TRUE;
  biReqSDOConfigRdWr.ReadConfigSDO6 := TRUE;
  
  usSDORetrys    := 0;
  eInitSSW       := _ReadInitValuesFromModule;
  eInitState     := _NotInitialized;
  eResponseState := _idle;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL ST151Base::CheckDeviceID
	VAR_INPUT
		udID2Check 	: UDINT;
	END_VAR
	VAR_OUTPUT
		bIsOK 	: BOOL;
	END_VAR
  
  if (udID2Check <> DEVICE_ID_ST151) then
    bIsOK := FALSE;
  else
    bIsOK := TRUE;
  end_if;
  
END_FUNCTION


FUNCTION VIRTUAL GLOBAL ST151Base::InitModule
	VAR_OUTPUT
		eModuleInitState 	: iprStates;
	END_VAR
  VAR
  	TmpRetcode      : iprStates;
    hTabAddress : ^UDINT;  
  END_VAR
  
  eModuleInitState := BUSY;
  
  case eInitSSW of
   
//**********************************************************************************************************************************************************  
    _ReadInitValuesFromModule: 
      TmpRetcode := SDORdWrData();
      if TmpRetcode = READY then   
        sWriteSDO := sReadSDO;
        eInitSSW  := _InitVariables;
      elsif TmpRetcode = ERROR then
        LogError("@ZZZZ (ST151Base::InitModule) Failed to add read SDO for configuration");
        eInitSSWErrorStep := eInitSSW;
        eInitSSW          := _InitError;
        eInitState        := _NoMem;
      end_if;      
  
//**********************************************************************************************************************************************************  
    _InitVariables:       
      //Invert Enable Settings  
      Enable.Write(Enable); //--- to ensure function of InvertEnable

      // remember flags for further use
      InvertZeroPosition  := InvertZeroPosition.Read() <> 0;
      InvertEncoder       := InvertEncoder.Read() <> 0;
      EncoderSampling     := EncoderSampling.Read();
      EncMode             := EncMode.Read() <> 0;
      ABCountMode         := ABCountMode.Read() <> 0;
      LatchType           := LatchType.Read() <> 0;
      EncoderSampling     := EncoderSampling.Read();
      
      StallCurrentReduction := StallCurrentReduction.Read();
      StallCurrentWindow    := StallCurrentWindow.Read();
      EnableRegenResistor   := EnableRegenResistor.Read() <> 0;
      RegenResistance       := RegenResistance.Read();
      RatedMaxPower         := RatedMaxPower.Read();
      LoadThresholdWarning  := LoadThresholdWarning.Read();
      LoadThresholdResistor := LoadThresholdResistor.Read();
      LoadThresholdBridge   := LoadThresholdBridge.Read();
      SteppingHysteresis    := SteppingHysteresis.Read();
      CompModeVST           := CompModeVST.Read() <> 0;      
      
      //set value for stepping hysterese
      udLimitsHysteresis := SteppingHysteresis$UDINT;
            
      //Limit Encoder Sampling
      if ( EncoderSampling < 0 ) then
        EncoderSampling := 0;
      elsif ( EncoderSampling > 3 ) then
        EncoderSampling := 3;
      end_if;
            
      //Check for Limits
      if StallCurrentReduction < 0 then
        StallCurrentReduction := 0;
      elsif StallCurrentReduction > ST151_STALL_CURRENT_LIMIT then
        StallCurrentReduction := ST151_STALL_CURRENT_LIMIT;
      end_if;
      
      if StallCurrentWindow > 0 then
        udStallCurrentWindow := StallCurrentWindow$UDINT;
      else
        udStallCurrentWindow := 0;
      end_if;
      
      MaxCurrent.Write(input:=MaxCurrent);
            
      //reset incremental encoder register
      sWriteSDO.SDOData2.IncrementalEncoderSettings := 0;
      //Set Mode of Encoder
      sWriteSDO.SDOData2.IncrementalEncoderSettings.TTL_RS422Mode := EncMode <> 0;
      //set virtual or encoder latch type
      sWriteSDO.SDOData2.IncrementalEncoderSettings.LatchType := LatchType <> 0;
      
      sWriteSDO.SDOData2.IncrementalEncoderSettings.ZeroPosInversion := InvertZeroPosition <> 0;
      sWriteSDO.SDOData2.IncrementalEncoderSettings.PhaseBInversion  := InvertEncoder <> 0;
      //set edge sampling mode
      sWriteSDO.SDOData2.IncrementalEncoderSettings.EdgeSampling1    := EncoderSampling$BOOL;
      sWriteSDO.SDOData2.IncrementalEncoderSettings.EdgeSampling2    := (EncoderSampling shr 1)$BOOL;
      //set A/B count mode 
      sWriteSDO.SDOData2.IncrementalEncoderSettings.ABCountMode := ABCountMode <> 0;
      
      HWRampdownDeltaFrequency.Write(input:=HWRampdownDeltaFrequency);
      HWRampdownDeltaTime.Write(input:=HWRampdownDeltaTime);
      //set compatibilty variable      
      usCompModeVST := CompModeVST$USINT + 1;
            
      ChopperOffTime.Write(input:=ChopperOffTime);
      ChopperOnTimeMin.Write(input:=ChopperOnTimeMin);
      FastDecayTime.Write(input:=FastDecayTime);
      FastDecayTimeFallingStep.Write(input:=FastDecayTimeFallingStep);
      CurrentOffsetAdjBridge1.Write(input:=CurrentOffsetAdjBridge1);
      CurrentOffsetAdjBridge2.Write(input:=CurrentOffsetAdjBridge2);
      
      //initialize frequency limits increase frequency
      FrequLimitIncrease2to1.Write(input:=FrequLimitIncrease2to1);
      FrequLimitIncrease4to2.Write(input:=FrequLimitIncrease4to2);
      FrequLimitIncrease8to4.Write(input:=FrequLimitIncrease8to4);
      FrequLimitIncrease16to8.Write(input:=FrequLimitIncrease16to8);
      FrequLimitIncrease32to16.Write(input:=FrequLimitIncrease32to16);
      FrequLimitIncrease64to32.Write(input:=FrequLimitIncrease64to32);      
      //initialize frequency limits decrease frequency
      FrequLimitDecrease1to2.Write(input:=FrequLimitDecrease1to2);
      FrequLimitDecrease2to4.Write(input:=FrequLimitDecrease2to4);
      FrequLimitDecrease4to8.Write(input:=FrequLimitDecrease4to8);
      FrequLimitDecrease8to16.Write(input:=FrequLimitDecrease8to16);
      FrequLimitDecrease16to32.Write(input:=FrequLimitDecrease16to32);
      FrequLimitDecrease32to64.Write(input:=FrequLimitDecrease32to64); 
      
      if IsClientConnected(#toFreqLimitTable) then
        hTabAddress$DINT := toFreqLimitTable.Read(); 
        if hTabAddress^ = ST151_FREQLIMITS_TABLESIZE then
          hTabAddress += sizeof(UDINT);
          FrequLimitIncrease64to32.Write(input:=hTabAddress^); 
          hTabAddress += sizeof(UDINT);
          FrequLimitDecrease32to64.Write(input:=hTabAddress^); 
          hTabAddress += sizeof(UDINT);
          FrequLimitIncrease32to16.Write(input:=hTabAddress^);
          hTabAddress += sizeof(UDINT);
          FrequLimitDecrease16to32.Write(input:=hTabAddress^);
          hTabAddress += sizeof(UDINT);
          FrequLimitIncrease16to8.Write(input:=hTabAddress^); 
          hTabAddress += sizeof(UDINT);
          FrequLimitDecrease8to16.Write(input:=hTabAddress^);
          hTabAddress += sizeof(UDINT);
          FrequLimitIncrease8to4.Write(input:=hTabAddress^);
          hTabAddress += sizeof(UDINT);
          FrequLimitDecrease4to8.Write(input:=hTabAddress^);
          hTabAddress += sizeof(UDINT);
          FrequLimitIncrease4to2.Write(input:=hTabAddress^);
          hTabAddress += sizeof(UDINT);
          FrequLimitDecrease2to4.Write(input:=hTabAddress^);
          hTabAddress += sizeof(UDINT);
          FrequLimitIncrease2to1.Write(input:=hTabAddress^);
          hTabAddress += sizeof(UDINT);
          FrequLimitDecrease1to2.Write(input:=hTabAddress^);        
        end_if; 
      end_if;
        
      //initialize variable enable
      EnableSteps.Write(input:=EnableSteps+0x800);
      
      CurrentIncrease.Write(input:=CurrentIncrease);
            
      if RatedMaxPower > 0xFFFF then
        RatedMaxPower := 0xFFFF;
      elsif RatedMaxPower < 1 then
        RatedMaxPower := 1;        
      end_if;    
      sWriteSDO.SDOData2.RatedMaximumPowerWatt := RatedMaxPower$UINT;
      
      if RegenResistance > 0xFFFF then
        RegenResistance := 0xFFFF;
      elsif RegenResistance < 1 then
        RegenResistance := 1;        
      end_if;    
      sWriteSDO.SDOData2.RegenResistance := RegenResistance$UINT;
      
      if LoadThresholdWarning > ST151_MAX_ALLOWED_PERCENT then
        LoadThresholdWarning := ST151_MAX_ALLOWED_PERCENT;
      elsif LoadThresholdWarning < 0 then
        LoadThresholdWarning := 0;        
      end_if;      
      sWriteSDO.SDOData2.LoadThresholdWarning := LoadThresholdWarning$USINT;
      
      if LoadThresholdResistor > ST151_MAX_ALLOWED_PERCENT then
        LoadThresholdResistor := ST151_MAX_ALLOWED_PERCENT;
      elsif LoadThresholdResistor < 0 then
        LoadThresholdResistor := 0;        
      end_if;
      sWriteSDO.SDOData2.LoadThresholdDisableResistor := LoadThresholdResistor$USINT;      
      sWriteSDO.SDOData2.BlankingTimeRegister := ST151_BLANKING_TIME;
      
      if LoadThresholdBridge > ST151_MAX_ALLOWED_PERCENT then
        LoadThresholdBridge := ST151_MAX_ALLOWED_PERCENT;
      elsif LoadThresholdBridge < 0 then
        LoadThresholdBridge := 0;        
      end_if;
      sWriteSDO.SDOData2.LoadThresholdDisableBridge := LoadThresholdBridge$USINT;
            
      //frequency is zero at beginning
      eActStepping := Microstepping_64;
                        
      //reset read write request config sdo
      biReqSDOConfigRdWr := 0;
      
      sAccesses.sWriteData.ControlWord.RegenResistorEnable := EnableRegenResistor$BOOL;
      //begin move with reduced current.
      sAccesses.sWriteData.ControlWord.SwitchMaxCurrent    := True;
    
      //Set write of config sdo 1-4, 3 is only read sdo
      biReqSDOConfigRdWr.WriteConfigSDO1 := TRUE;
      biReqSDOConfigRdWr.WriteConfigSDO2 := TRUE;
      biReqSDOConfigRdWr.WriteConfigSDO4 := TRUE;
      biReqSDOConfigRdWr.WriteConfigSDO5 := TRUE;
      biReqSDOConfigRdWr.WriteConfigSDO6 := TRUE;
      
      //load config new
      sWriteSDO.SDOData5.bsControllerControlReg.LoadConfigNew   := FALSE;
      sWriteSDO.sdodata5.bsControllerControlReg.ControllerReset := FALSE;
      eInitSSW   := _WriteConfigSDO;
      
//**********************************************************************************************************************************************************
    _WriteConfigSDO:
      TmpRetcode := SDORdWrData();
      if TmpRetcode = READY then
        //Set read of config sdo 1-4
        biReqSDOConfigRdWr.ReadConfigSDO1 := TRUE;
        biReqSDOConfigRdWr.ReadConfigSDO2 := TRUE;
        biReqSDOConfigRdWr.ReadConfigSDO3 := TRUE;
        biReqSDOConfigRdWr.ReadConfigSDO4 := TRUE;
        biReqSDOConfigRdWr.ReadConfigSDO5 := TRUE;
        biReqSDOConfigRdWr.ReadConfigSDO6 := TRUE;
        eInitSSW := _ReadConfigSDO;
      elsif TmpRetcode = ERROR then
        LogError("@ZZZZ (ST151Base::InitModule) Failed to add write SDO for configuration");
        eInitSSWErrorStep := eInitSSW;
        eInitSSW          := _InitError;
        eInitState        := _NoMem;
      end_if;      
      
//**********************************************************************************************************************************************************
    _ReadConfigSDO:  
      TmpRetcode := SDORdWrData();
      if TmpRetcode = READY then   
        eInitSSW          := _DisablePll;
      elsif TmpRetcode = ERROR then
        LogError("@ZZZZ (ST151Base::InitModule) Failed to add SDO for read configuration");
        eInitSSWErrorStep := eInitSSW;
        eInitSSW          := _InitError;
        eInitState        := _NoMem;
      end_if;
            
//**********************************************************************************************************************************************************
    _DisablePll:    
      case eResponseState of
        //*******************************************************
        _idle:
          sPllRegister.bsStateControlReg := 0;
          TmpRetcode  := StartWriteSDO(hOffset  := ST151_PLL_CONTROL
                                      , usLength:= sizeof(sPllRegister.bsStateControlReg)
                                      , pWriteBuffer:=#sPllRegister.bsStateControlReg$USINT
                                      , eCommand:= SDIAS_SDO_CMD_CTRL_WRITE);
          if TmpRetcode = READY then
            udSDOTimeout  := ops.tAbsolute;
            eResponseState:= _wait; 
          elsif TmpRetcode = ERROR then
            LogError("@ZZZZ (ST151Base::InitModule) Failed to add write SDO for channel configuration, step DisablePll");
            eInitSSWErrorStep := eInitSSW;
            eInitSSW          := _InitError;
          end_if; 
          
        //*******************************************************
        _wait:
          // wait for response
          if ((ops.tAbsolute - udSDOTimeout) > ST151_SDO_RESPONSE_TIMEOUT) then
            LogError("@ZZZZ (ST151Base::InitModule) SDO Response timeout, step DisablePll");
            eInitSSWErrorStep := eInitSSW;
            eInitSSW          := _InitError;
          end_if;
          
        //*******************************************************
        _valid:
          eInitSSW        := _ReadPll;
          eResponseState  := _idle;
      end_case;
              
//**********************************************************************************************************************************************************
    _ReadPll:
      case eResponseState of
        //*******************************************************
        _idle:           
          if sSPIReadData.udReadOffset < sizeof(sPllRegister) then          
            sSPIReadData.udReadLength := sizeof(sPllRegister) - sSPIReadData.udReadOffset;
            if sSPIReadData.udReadLength > SDIAS_MAX_SDO_READ_LENGTH then              
              sSPIReadData.udReadLength := SDIAS_MAX_SDO_READ_LENGTH;
            end_if;           
            TmpRetcode  := StartReadSDO(hOffset   :=ST151_PLL_OFFSET + sSPIReadData.udReadOffset$HINT
                                        , usLength:=sSPIReadData.udReadLength$USINT
                                        , eCommand:=SDIAS_SDO_CMD_CTRL_READ);   
            if TmpRetcode = READY then
              udSDOTimeout      := ops.tAbsolute;
              eResponseState    := _wait; 
            elsif TmpRetcode = ERROR then
              LogError("@ZZZZ (ST151Base::InitModule) Failed to add read SDO to read pll");
              eInitSSWErrorStep := eInitSSW;
              eInitSSW          := _InitError;
            end_if; 
          else
            sSPIReadData.udReadOffset := 0;
            eInitSSW := _Finish;             
          end_if;  
          
        //*******************************************************
        _wait:
          // wait for response
          if ((ops.tAbsolute - udSDOTimeout) > SDIAS_SDO_TIMEOUT*2) then
            LogError("@ZZZZ (ST151Base::InitModule) SDO Response timeout read pll");
            eInitSSWErrorStep := eInitSSW;
            eInitSSW          := _InitError;
          end_if;
          
        //*******************************************************
        _valid:
          sSPIReadData.udReadOffset += sSPIReadData.udReadLength$USINT;
          eResponseState    := _idle;
          eInitSSW          := _SetPll;
      end_case;          
         
//**********************************************************************************************************************************************************
    _SetPll:
      case eResponseState of
        //*******************************************************
        _idle:                
          sSPIWriteData.usWriteOffset         := 0; 
          sPllRegister.udSystemPerTime        := udBusTime / 10;            // convert to 10*ns
          sPllRegister.bsStateControlReg      := 0;
          sPllRegister.bsStateControlReg.Soft_enable  := 1;
          sPllRegister.usSystemPeriodeDividier        := 1;
          //sPllRegister.CompensationDelay // Keep value
          sPLLRegister.SyncOut0.uiOffset         := 0; 
          sPllRegister.SyncOut0.usPeriodMulti    := 1; (*SetPllMultiplier();*)
          sPllRegister.SyncOut0.bsSyncStartDelay := 0;
          sPllRegister.SyncOut0.bsControlState.SyncEnable       := 1;
          sPllRegister.SyncOut0.bsControlState.StartDelayEnable := 0;
          sPllRegister.SyncOut0.bsControlState.SyncSelector     := 1;
          
          TmpRetcode  := StartWriteSDO(hOffset      :=ST151_PLL_OFFSET + sSPIWriteData.usWriteOffset
                                      , usLength    :=sizeof(sPLLRegister)
                                      , pWriteBuffer:=(#sPLLRegister+sSPIWriteData.usWriteOffset)$^USINT
                                      , eCommand    :=SDIAS_SDO_CMD_CTRL_WRITE);
          
          if TmpRetcode = READY then
            udSDOTimeout  := ops.tAbsolute;
            eResponseState:= _wait; 
          elsif TmpRetcode = ERROR then
            LogError("@ZZZZ (ST151Base::InitModul) Failed to add write SDO in step SetPll");
            eInitState        := _PllError;
            eInitSSWErrorStep := eInitSSW;
            eInitSSW          := _InitError;
          end_if;
          
        //*******************************************************
        _wait:
          // wait for response
          if ((ops.tAbsolute - udSDOTimeout) > ST151_SDO_RESPONSE_TIMEOUT) then
            LogError("@ZZZZ (ST151Base::InitModul) SDO Response timeout SetPll");
            eInitSSWErrorStep := eInitSSW;
            eInitSSW          := _InitError;
          end_if;
          
        //*******************************************************
        _valid:
          sSPIReadData.udReadOffset := 0;
          eInitSSW        := _Wait4FPGAReset;
          eResponseState  := _idle;
      end_case; 
          
//**********************************************************************************************************************************************************
    _Wait4FPGAReset:
      eInitSSW      := _ActivateFPGA;
        
//**********************************************************************************************************************************************************
    _ActivateFPGA:
        eInitSSW     := _Finish;
    
//**********************************************************************************************************************************************************
    _Finish:
    //set cyclic server to invalid value
//      DC24VOk              := ST151_INVALID_VALUE$DINT;
      bsRespSDOConfigRdWr.ReadConfigSDO3 := FALSE;
      VoltageOKEncoder     := ST151_INVALID_VALUE$DINT;
      HBridgeVoltage       := ST151_INVALID_VALUE$DINT;
      HBridgeTemperature   := ST151_INVALID_VALUE$DINT;
      ExternalEnable1      := ST151_INVALID_VALUE$DINT;
      ExternalEnable2      := ST151_INVALID_VALUE$DINT;
      ActRegenResistorLoad  := ST151_INVALID_VALUE$DINT;
      eInitSSW             := _InitVariables;
      eModuleInitState     := READY;
      eInitState           := _ClassOk;
      
//**********************************************************************************************************************************************************
    _InitError:
      eModuleInitState := ERROR; 
      if (eInitState <> _InvalidConfguration) then
        eInitState      := _ClientNotready;
      end_if;  
      
//**********************************************************************************************************************************************************

  end_case;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL ST151Base::GetDeviceID
	VAR_OUTPUT
		output 	: UDINT;
	END_VAR
  
  output := DEVICE_ID_ST151;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL ST151Base::Enable::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

  if input & AxError then
    input := 0;
  end_if;
  
  Enable := input;  

  sAccesses.sWriteData.ControlWord.SwitchOn := ControlWord.SwitchOn := ControlWord.EnableOperation := to_bool(input);
  
  if input = 0 then
    SetFreqOut.Write(input:=0);  
  end_if;

  result := Enable;

END_FUNCTION


FUNCTION VIRTUAL ST151Base::ReceiveSDOResponse
	VAR_INPUT
		eCommand 	: t_SDIAS_SDO_Cmd;
		hOffset 	: HINT;
		usLength 	: USINT;
		eResult 	: iprStates;
		pResponseBuffer 	: ^USINT;
		ResponseLength 	: USINT;
	END_VAR
	VAR_OUTPUT
		ret_code 	: iprStates;
	END_VAR
  
  ret_code := SdiasBase::ReceiveSDOResponse(eCommand, hOffset, usLength, eResult, pResponseBuffer, ResponseLength);
  
  // spi access from baseclass                                         
  if bSDOResponseHandle = TRUE then
    return;
  end_if;
  
  if eResult = READY then
    
    case eCommand of
    //**********************************************************************
      SDIAS_SDO_CMD_MEM_WRITE:
        case hOffset of
        //-------------------------------------------------------------
          ST151_ADDR_SDO_1,
          ST151_ADDR_SDO_2,
          ST151_ADDR_SDO_5,
          ST151_ADDR_SDO_6:
            if eResponseState = _wait then
              eResponseState := _valid;
            end_if;           
        end_case;
        
      //**************************************************************************************************************************
      SDIAS_SDO_CMD_MEM_READ:
        case hOffset of
          //***************************************************************************************************
          ST151_ADDR_SDO_1:
            if eResponseState = _wait then
              eResponseState := _valid;
              sReadSDO.SDOData1 := pResponseBuffer^$t_s_ConfigModule1;
            end_if; 
            
          //***************************************************************************************************
          ST151_ADDR_SDO_2:
            if eResponseState = _wait then
              eResponseState := _valid;
              sReadSDO.SDOData2      := pResponseBuffer^$t_s_ConfigModule2;
            end_if;
            
          //***************************************************************************************************
          ST151_ADDR_SDO_3:
            if eResponseState = _wait then
              eResponseState := _valid;
              sReadSDO.SDOData3      := pResponseBuffer^$t_s_ConfigModule3;
            end_if;
            
          //***************************************************************************************************
          ST151_ADDR_SDO_4:
            if eResponseState = _wait then
              eResponseState := _valid;
              sReadSDO.SDOData4      := pResponseBuffer^$t_s_ConfigModule4;
            end_if;
            
          //***************************************************************************************************
          ST151_ADDR_SDO_5:
            if eResponseState = _wait then
              eResponseState := _valid;
              sReadSDO.SDOData5      := pResponseBuffer^$t_s_ConfigModule5;
            end_if;  
            
          //***************************************************************************************************
          ST151_ADDR_SDO_6:
            if eResponseState = _wait then
              eResponseState := _valid;
              sReadSDO.SDOData6      := pResponseBuffer^$t_s_ConfigModule6;
            end_if;                    
        end_case;
       
      //**************************************************************************************************************************
      //Control Read
      SDIAS_SDO_CMD_CTRL_READ:       
        if hOffset >= ST151_PLL_OFFSET 
         & hOffset < (ST151_PLL_OFFSET+sizeof(sPllRegister)) then
          eResponseState := _valid;
          if eResponseState = _wait then          
            _memcpy(ptr1:= (#sPllRegister + sSPIReadData.udReadOffset), ptr2:=pResponseBuffer, cntr:=sSPIReadData.udReadLength);
          end_if;            
        end_if;  
       
      //**************************************************************************************************************************
      //Control write
      SDIAS_SDO_CMD_CTRL_WRITE:        
        if hOffset >= ST151_PLL_OFFSET 
         & hOffset < (ST151_PLL_OFFSET+sizeof(sPllRegister)) then
          if eResponseState = _wait then
            eResponseState := _valid;
          end_if;
        end_if;  
    
    end_case;
    
    if eResponseState <> _valid then
      LogError("@ZZZZ (ST151Base::ReceiveSDOResponse) ERROR in response data of SDO");
      // ERROR was at initialisation
      eInitSSW := _InitError;
    end_if;
    
  else
    case eCommand of
      SDIAS_SDO_CMD_MEM_WRITE:
        LogError("@ZZZZ (ST151Base::ReceiveSDOResponse) ERROR while writing the sdo data");
      SDIAS_SDO_CMD_MEM_READ:
        LogError("@ZZZZ (ST151Base::ReceiveSDOResponse) ERROR while reading the sdo data");
      SDIAS_SDO_CMD_CTRL_READ:  
        LogError("@ZZZZ (ST151Base::ReceiveSDOResponse) Error while reading the pll configuration");
      SDIAS_SDO_CMD_CTRL_WRITE:  
        LogError("@ZZZZ (ST151Base::ReceiveSDOResponse) Error while writing the pll configuration");
    end_case;
    // ERROR was at initialisation
    eInitSSW := _InitError;
  end_if;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL ST151Base::Input1LatchedRising::Read
	VAR_OUTPUT
		output (EAX) 	: DINT;
	END_VAR

  //Return Latch
	output := Input1LatchedRising;
  
  //Reset Latch in next rt-run
  sLatchValues.bsLatchReaded.DigIn1Rise := TRUE;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL ST151Base::Input1LatchedFalling::Read
	VAR_OUTPUT
		output (EAX) 	: DINT;
	END_VAR

  //Return Latch
	output := Input1LatchedFalling;
  
  //Reset Latch in next rt-run
  sLatchValues.bsLatchReaded.DigIn1Fall := TRUE;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL ST151Base::Input2LatchedRising::Read
	VAR_OUTPUT
		output (EAX) 	: DINT;
	END_VAR

  //Return Latch
	output := Input2LatchedRising;
  
  //Reset Latch in next rt-run
  sLatchValues.bsLatchReaded.DigIn2Rise := TRUE;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL ST151Base::Input2LatchedFalling::Read
	VAR_OUTPUT
		output (EAX) 	: DINT;
	END_VAR
  
  //Return Latch
	output := Input2LatchedFalling;
  
  //Reset Latch in next rt-run
  sLatchValues.bsLatchReaded.DigIn2Fall := TRUE;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL ST151Base::ZPulsLatched::Read
	VAR_OUTPUT
		output (EAX) 	: DINT;
	END_VAR
  
  //Return Latch
	output := ZPulsLatched;
  
  //Reset Latch in next rt-run
  sLatchValues.bsLatchReaded.IncZero := TRUE;
  
END_FUNCTION


FUNCTION VIRTUAL GLOBAL ST151Base::DisconnectEvent
  //Reset DO-Data
  if sAccesses.pWriteData then
    _memset(dest := sAccesses.pWriteData, usByte := 0, cntr := sizeof(sAccesses.pWriteData^));
  end_if;
  
  //reset online state
  Online  := 0;
  
  //Call Disconnect of Base-Class
  SdiasBase::DisconnectEvent();
  
END_FUNCTION


FUNCTION ST151Base::ST151Base
	VAR_OUTPUT
		ret_code 	: ConfStates;
	END_VAR
  
	ret_code := C_OK;

END_FUNCTION


FUNCTION VIRTUAL ST151Base::GetTaskCfg
	VAR_OUTPUT
		TaskCfg 	: BDINT;
	END_VAR
  
  TaskCfg := SDIAS_TASK_MASK_RT_PRE OR SDIAS_TASK_MASK_RT_POST OR SDIAS_TASK_MASK_CY;
  
END_FUNCTION


FUNCTION VIRTUAL GLOBAL ST151Base::ErrorQuit::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

  result := ErrorQuit := sAccesses.sWriteData.ControlWord.RegenResistorFaultReset := sAccesses.sWriteData.ControlWord.QuitSTOOff := sAccesses.sWriteData.ControlWord.FaultReset := ControlWord.ResetFault := to_bool(input);

END_FUNCTION


FUNCTION VIRTUAL GLOBAL ST151Base::CurrentIncrease::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

  result := CurrentIncrease := sAccesses.sWriteData.ControlWord.CurrentIncrease := ControlWord.ManufactureSpec1 := to_bool(input);

END_FUNCTION


FUNCTION VIRTUAL GLOBAL ST151Base::ControlWord::Write
	VAR_INPUT
		input (EAX) 	: DS402_Control;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DS402_Control;
	END_VAR

  result := ControlWord := input;
  
  Enable := ControlWord.SwitchOn AND ControlWord.EnableOperation;
  sAccesses.sWriteData.ControlWord.SwitchOn   := to_BOOL(Enable);
  sAccesses.sWriteData.ControlWord.FaultReset := sAccesses.sWriteData.ControlWord.RegenResistorFaultReset := sAccesses.sWriteData.ControlWord.QuitSTOOff := ControlWord.ResetFault;
  CurrentIncrease := sAccesses.sWriteData.ControlWord.CurrentIncrease := ControlWord.ManufactureSpec1;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL ST151Base::SetFreqOut::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR
  VAR
  	dTempInput : DINT;
  END_VAR
   
  if input <> SetFreqOut then //just do something when the value changed
    dTempInput := input * usCompModeVST;
    if dTempInput > ST151_MAXFREQUENCY_OUT then
      dTempInput := ST151_MAXFREQUENCY_OUT;
    elsif dTempInput < -ST151_MAXFREQUENCY_OUT then
      dTempInput := -ST151_MAXFREQUENCY_OUT;
    end_if;
    
    //*****************************************************************************
    SetFreqOut := input;
    
    //Calculate Current
    sAccesses.sWriteData.ControlWord.SwitchMaxCurrent := (abs(input)$UDINT <= udStallCurrentWindow);
    //write act frequency to module
    sAccesses.sWriteData.StepFrequencyReg := dTempInput;
    
  end_if;
  
  result := SetFreqOut;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL ST151Base::TargetFreqOut::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR
  VAR
  	dRetCode : DINT;
  END_VAR
  
  // calculate adaptive microstepping
	TargetFreqOut := input;
  if TargetFreqOut <> -1 then
    //calculate always from zero to target frequency
    dRetCode       := CalcAdaptiveMicroStepping(dTargetFrequency:=TargetFreqOut, dActSetFrequency:=0);
  else
    EnableSteps.Write(input:=EnableSteps+0x800); // +0x800 is just to have a change of the value. It is rejected inside the write()
  end_if;

  if dRetCode = 0 then
    //all ok write setting
  end_if;
	result         := TargetFreqOut;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL ST151Base::HWRampdownDeltaFrequency::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR
  
  sWriteSDO.SDOData2.HWRampdownDeltaFrequency := input$UINT;
  biReqSDOConfigRdWr.WriteConfigSDO2          := TRUE;
  HWRampdownDeltaFrequency := input;
  result                   := HWRampdownDeltaFrequency;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL ST151Base::HWRampdownDeltaTime::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

  sWriteSDO.SDOData2.HWRampdownDeltaTime := input$uint;
  biReqSDOConfigRdWr.WriteConfigSDO2     := TRUE;
  HWRampdownDeltaTime := input;
  result              := HWRampdownDeltaTime;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL ST151Base::HWEnableSoftwareRampdown::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

  HWEnableSoftwareRampdown := input <> 0;
 	result := HWEnableSoftwareRampdown;

END_FUNCTION


FUNCTION ST151Base::SDORdWrData
	VAR_OUTPUT
		dRetCode 	: iprStates;
	END_VAR
  VAR
  	TmpRetcode : iprStates;
  END_VAR

  dRetCode := BUSY;
  
  case eActSDOConfigRdWr of
    //********************************************************************************************************************************
  	t_e_SDOConfig::_SDOConfig_Idle:
      eActSDOConfigRdWr := SetSDORdWrStep(eActStep:=eActSDOConfigRdWr); 
            
    //********************************************************************************************************************************
  	t_e_SDOConfig::_SDOConfig_Write1:   
      case eResponseState of
        _idle:
          biReqSDOConfigRdWr.WriteConfigSDO1  := FALSE;
          bsRespSDOConfigRdWr.WriteConfigSDO1 := FALSE;
          TmpRetcode  := StartWriteSDO(hOffset:=ST151_ADDR_SDO_1, usLength:=sizeof(sWriteSDO.SDOData1), pWriteBuffer:=(#sWriteSDO.SDOData1)$^USINT, eCommand:=SDIAS_SDO_CMD_MEM_WRITE);
          if TmpRetcode = READY then
            udSDOTimeout  := ops.tAbsolute;
            eResponseState:= _wait; 
          elsif TmpRetcode = ERROR then
            LogError("@ZZZZ (ST151Base::SDORdWrData) Failed to add write SDO for configuration");
            eActSDOConfigRdWr := _SDOConfig_Error;
          end_if;
          //*****************************************************
        _wait:
          // wait for response
          if ((ops.tAbsolute - udSDOTimeout) > ST151_SDO_RESPONSE_TIMEOUT) then
            LogError("@ZZZZ (ST151Base::SDORdWrData) SDO Response timeout config module");
            eActSDOConfigRdWr := _SDOConfig_Error;
          end_if;
        //*****************************************************
        _valid:
          eActSDOConfigRdWr := SetSDORdWrStep(eActStep:=eActSDOConfigRdWr);
          bsRespSDOConfigRdWr.WriteConfigSDO1 := TRUE;
          eResponseState                      := _idle;         
        //*****************************************************
      end_case;      
            
    //********************************************************************************************************************************
  	t_e_SDOConfig::_SDOConfig_Write2:
      case eResponseState of
        _idle:
          biReqSDOConfigRdWr.WriteConfigSDO2  := FALSE;
          bsRespSDOConfigRdWr.WriteConfigSDO2 := FALSE;
          TmpRetcode  := StartWriteSDO(hOffset:=ST151_ADDR_SDO_2, usLength:=sizeof(sWriteSDO.SDOData2), pWriteBuffer:=(#sWriteSDO.SDOData2)$^USINT, eCommand:=SDIAS_SDO_CMD_MEM_WRITE);
          if TmpRetcode = READY then
            udSDOTimeout  := ops.tAbsolute;
            eResponseState:= _wait; 
          elsif TmpRetcode = ERROR then
            LogError("@ZZZZ (ST151Base::SDORdWrData) Failed to add write SDO for configuration");
            eActSDOConfigRdWr := _SDOConfig_Error;
          end_if;
          //*****************************************************
        _wait:
          // wait for response
          if ((ops.tAbsolute - udSDOTimeout) > ST151_SDO_RESPONSE_TIMEOUT) then
            LogError("@ZZZZ (ST151Base::SDORdWrData) SDO Response timeout config module");
            eActSDOConfigRdWr := _SDOConfig_Error;
          end_if;
        //*****************************************************
        _valid:
          eActSDOConfigRdWr := SetSDORdWrStep(eActStep:=eActSDOConfigRdWr);
          bsRespSDOConfigRdWr.WriteConfigSDO2 := TRUE;
          eResponseState                      := _idle;           
        //*****************************************************
      end_case;      
    
    //********************************************************************************************************************************
  	t_e_SDOConfig::_SDOConfig_Write3:
      //sdo 3 is only read
//      case eResponseState of
//        _idle:
          biReqSDOConfigRdWr.WriteConfigSDO3  := FALSE;
          bsRespSDOConfigRdWr.WriteConfigSDO3 := FALSE;
//          TmpRetcode  := StartWriteSDO(hOffset:=ST151_ADDR_SDO_3, usLength:=sizeof(sWriteSDO.SDOData3), pWriteBuffer:=(#sWriteSDO.SDOData3)$^USINT, eCommand:=SDIAS_SDO_CMD_MEM_WRITE);
//          if TmpRetcode = READY then
//            udSDOTimeout  := ops.tAbsolute;
//            eResponseState:= _wait; 
//          elsif TmpRetcode = ERROR then
//            LogError("@ZZZZ (ST151Base::SDORdWrData) Failed to add write SDO for configuration");
//            eActSDOConfigRdWr := _SDOConfig_Error;
//          end_if;
//          //*****************************************************
//        _wait:
//          // wait for response
//          if ((ops.tAbsolute - udSDOTimeout) > ST151_SDO_RESPONSE_TIMEOUT) then
//            LogError("@ZZZZ (ST151Base::SDORdWrData) SDO Response timeout config module");
//            eActSDOConfigRdWr := _SDOConfig_Error;
//          end_if;
//        //*****************************************************
//        _valid:
          eActSDOConfigRdWr := SetSDORdWrStep(eActStep:=eActSDOConfigRdWr);
//          bsRespSDOConfigRdWr.WriteConfigSDO3 := TRUE;
//          eResponseState                      := _idle;           
//        //*****************************************************
//      end_case;    
    
    //********************************************************************************************************************************
  	t_e_SDOConfig::_SDOConfig_Write4:
      //sdo 4 is only read
//      case eResponseState of
//        _idle:
          biReqSDOConfigRdWr.WriteConfigSDO4  := FALSE;
          bsRespSDOConfigRdWr.WriteConfigSDO4 := FALSE;
//          TmpRetcode  := StartWriteSDO(hOffset:=ST151_ADDR_SDO_4, usLength:=sizeof(sWriteSDO.SDOData4), pWriteBuffer:=(#sWriteSDO.SDOData4)$^USINT, eCommand:=SDIAS_SDO_CMD_MEM_WRITE);
//          if TmpRetcode = READY then
//            udSDOTimeout  := ops.tAbsolute;
//            eResponseState:= _wait; 
//          elsif TmpRetcode = ERROR then
//            LogError("@ZZZZ (ST151Base::SDORdWrData) Failed to add write SDO for configuration");
//            eActSDOConfigRdWr := _SDOConfig_Error;
//          end_if;
//          //*****************************************************
//        _wait:
//          // wait for response
//          if ((ops.tAbsolute - udSDOTimeout) > ST151_SDO_RESPONSE_TIMEOUT) then
//            LogError("@ZZZZ (ST151Base::SDORdWrData) SDO Response timeout config module");
//            eActSDOConfigRdWr := _SDOConfig_Error;
//          end_if;
//        //*****************************************************
//        _valid:
          eActSDOConfigRdWr := SetSDORdWrStep(eActStep:=eActSDOConfigRdWr);
//          bsRespSDOConfigRdWr.WriteConfigSDO4 := TRUE;
//          eResponseState                      := _idle;           
//        //*****************************************************
//      end_case;    

    //********************************************************************************************************************************
  	t_e_SDOConfig::_SDOConfig_Write5:
      case eResponseState of
        _idle:
          biReqSDOConfigRdWr.WriteConfigSDO5  := FALSE;
          bsRespSDOConfigRdWr.WriteConfigSDO5 := FALSE;
          TmpRetcode  := StartWriteSDO(hOffset:=ST151_ADDR_SDO_5, usLength:=sizeof(sWriteSDO.SDOData5), pWriteBuffer:=(#sWriteSDO.SDOData5)$^USINT, eCommand:=SDIAS_SDO_CMD_MEM_WRITE);
          if TmpRetcode = READY then
            udSDOTimeout  := ops.tAbsolute;
            eResponseState:= _wait; 
          elsif TmpRetcode = ERROR then
            LogError("@ZZZZ (ST151Base::SDORdWrData) Failed to add write SDO for configuration");
            eActSDOConfigRdWr := _SDOConfig_Error;
          end_if;
          //*****************************************************
        _wait:
          // wait for response
          if ((ops.tAbsolute - udSDOTimeout) > ST151_SDO_RESPONSE_TIMEOUT) then
            LogError("@ZZZZ (ST151Base::SDORdWrData) SDO Response timeout config module");
            eActSDOConfigRdWr := _SDOConfig_Error;
          end_if;
        //*****************************************************
        _valid:
          eActSDOConfigRdWr := SetSDORdWrStep(eActStep:=eActSDOConfigRdWr);
          bsRespSDOConfigRdWr.WriteConfigSDO5 := TRUE;
          eResponseState                      := _idle;           
        //*****************************************************
      end_case;      
      
    //********************************************************************************************************************************
  	t_e_SDOConfig::_SDOConfig_Write6:
      case eResponseState of
        _idle:
          biReqSDOConfigRdWr.WriteConfigSDO6  := FALSE;
          bsRespSDOConfigRdWr.WriteConfigSDO6 := FALSE;
          TmpRetcode  := StartWriteSDO(hOffset:=ST151_ADDR_SDO_6, usLength:=sizeof(sWriteSDO.SDOData6), pWriteBuffer:=(#sWriteSDO.SDOData6)$^USINT, eCommand:=SDIAS_SDO_CMD_MEM_WRITE);
          if TmpRetcode = READY then
            udSDOTimeout  := ops.tAbsolute;
            eResponseState:= _wait; 
          elsif TmpRetcode = ERROR then
            LogError("@ZZZZ (ST151Base::SDORdWrData) Failed to add write SDO for configuration");
            eActSDOConfigRdWr := _SDOConfig_Error;
          end_if;
          //*****************************************************
        _wait:
          // wait for response
          if ((ops.tAbsolute - udSDOTimeout) > ST151_SDO_RESPONSE_TIMEOUT) then
            LogError("@ZZZZ (ST151Base::SDORdWrData) SDO Response timeout config module");
            eActSDOConfigRdWr := _SDOConfig_Error;
          end_if;
        //*****************************************************
        _valid:
          eActSDOConfigRdWr := SetSDORdWrStep(eActStep:=eActSDOConfigRdWr);
          bsRespSDOConfigRdWr.WriteConfigSDO6 := TRUE;
          eResponseState                      := _idle;           
        //*****************************************************
      end_case;    
    
    //********************************************************************************************************************************
  	t_e_SDOConfig::_SDOConfig_Read1:
      case eResponseState of
        _idle:
          biReqSDOConfigRdWr.ReadConfigSDO1  := FALSE;
          bsRespSDOConfigRdWr.ReadConfigSDO1 := FALSE;
          TmpRetcode  := StartReadSDO(hOffset:=ST151_ADDR_SDO_1, usLength:=sizeof(sReadSDO.SDOData1), eCommand:=SDIAS_SDO_CMD_MEM_READ);
          if TmpRetcode = READY then
            udSDOTimeout  := ops.tAbsolute;
            eResponseState:= _wait; 
          elsif TmpRetcode = ERROR then
            LogError("@ZZZZ (ST151Base::SDORdWrData) Failed to add SDO for read of configuration");
            eActSDOConfigRdWr := _SDOConfig_Error;
          end_if;
          //*****************************************************
        _wait:
          // wait for response
          if ((ops.tAbsolute - udSDOTimeout) > ST151_SDO_RESPONSE_TIMEOUT) then
            LogError("@ZZZZ (ST151Base::SDORdWrData) SDO Response timeout config module");
            eActSDOConfigRdWr := _SDOConfig_Error;
          end_if;
        //*****************************************************
        _valid:
          eActSDOConfigRdWr := SetSDORdWrStep(eActStep:=eActSDOConfigRdWr);
          bsRespSDOConfigRdWr.ReadConfigSDO1  := TRUE;
          eResponseState                      := _idle;           
        //*****************************************************
      end_case;    
    
    //********************************************************************************************************************************
  	t_e_SDOConfig::_SDOConfig_Read2:
      case eResponseState of
        _idle:
          biReqSDOConfigRdWr.ReadConfigSDO2  := FALSE;
          bsRespSDOConfigRdWr.ReadConfigSDO2 := FALSE;
          TmpRetcode  := StartReadSDO(hOffset:=ST151_ADDR_SDO_2, usLength:=sizeof(sReadSDO.SDOData2), eCommand:=SDIAS_SDO_CMD_MEM_READ);
          if TmpRetcode = READY then
            udSDOTimeout  := ops.tAbsolute;
            eResponseState:= _wait; 
          elsif TmpRetcode = ERROR then
            LogError("@ZZZZ (ST151Base::SDORdWrData) Failed to add SDO for read of configuration");
            eActSDOConfigRdWr := _SDOConfig_Error;
          end_if;
          //*****************************************************
        _wait:
          // wait for response
          if ((ops.tAbsolute - udSDOTimeout) > ST151_SDO_RESPONSE_TIMEOUT) then
            LogError("@ZZZZ (ST151Base::SDORdWrData) SDO Response timeout config module");
            eActSDOConfigRdWr := _SDOConfig_Error;
          end_if;
        //*****************************************************
        _valid:
          eActSDOConfigRdWr := SetSDORdWrStep(eActStep:=eActSDOConfigRdWr);
          bsRespSDOConfigRdWr.ReadConfigSDO2  := TRUE;
          eResponseState                      := _idle;        
        //*****************************************************
      end_case;    
    
    //********************************************************************************************************************************
  	t_e_SDOConfig::_SDOConfig_Read3:
      case eResponseState of
        _idle:
          biReqSDOConfigRdWr.ReadConfigSDO3  := FALSE;
          bsRespSDOConfigRdWr.ReadConfigSDO3 := FALSE;
          TmpRetcode  := StartReadSDO(hOffset:=ST151_ADDR_SDO_3, usLength:=sizeof(sReadSDO.SDOData3), eCommand:=SDIAS_SDO_CMD_MEM_READ);
          if TmpRetcode = READY then
            //save the actual latched values
            sLatchValues.bsValidISyncValue     := sLatchValues.bsActiveISyncValue;
            sLatchValues.bResetActiveSyncValue := TRUE;
            udSDOTimeout  := ops.tAbsolute;
            eResponseState:= _wait; 
          elsif TmpRetcode = ERROR then
            LogError("@ZZZZ (ST151Base::SDORdWrData) Failed to add SDO for read of configuration");
            eActSDOConfigRdWr := _SDOConfig_Error;
          end_if;
          //*****************************************************
        _wait:
          // wait for response 
          if ((ops.tAbsolute - udSDOTimeout) > ST151_SDO_RESPONSE_TIMEOUT) then
            LogError("@ZZZZ (ST151Base::SDORdWrData) SDO Response timeout config module");
            eActSDOConfigRdWr := _SDOConfig_Error;
          end_if;
        //*****************************************************
        _valid:
          eActSDOConfigRdWr := SetSDORdWrStep(eActStep:=eActSDOConfigRdWr);
          bsRespSDOConfigRdWr.ReadConfigSDO3  := TRUE;
          eResponseState                      := _idle; 
        //*****************************************************
      end_case;    
      
      
    //********************************************************************************************************************************
  	t_e_SDOConfig::_SDOConfig_Read4:
      case eResponseState of
        _idle:
          biReqSDOConfigRdWr.ReadConfigSDO4  := FALSE;
          bsRespSDOConfigRdWr.ReadConfigSDO4 := FALSE;
          TmpRetcode  := StartReadSDO(hOffset:=ST151_ADDR_SDO_4, usLength:=sizeof(sReadSDO.SDOData4), eCommand:=SDIAS_SDO_CMD_MEM_READ);
          if TmpRetcode = READY then
            //save the actual latched values
            sLatchValues.bsValidISyncValue     := sLatchValues.bsActiveISyncValue;
            sLatchValues.bResetActiveSyncValue := TRUE;
            udSDOTimeout  := ops.tAbsolute;
            eResponseState:= _wait; 
          elsif TmpRetcode = ERROR then
            LogError("@ZZZZ (ST151Base::SDORdWrData) Failed to add SDO for read of configuration");
            eActSDOConfigRdWr := _SDOConfig_Error;
          end_if;
          //*****************************************************
        _wait:
          // wait for response 
          if ((ops.tAbsolute - udSDOTimeout) > ST151_SDO_RESPONSE_TIMEOUT) then
            LogError("@ZZZZ (ST151Base::SDORdWrData) SDO Response timeout config module");
            eActSDOConfigRdWr := _SDOConfig_Error;
          end_if;
        //*****************************************************
        _valid:
          eActSDOConfigRdWr := SetSDORdWrStep(eActStep:=eActSDOConfigRdWr);
          bsRespSDOConfigRdWr.ReadConfigSDO4  := TRUE;
          eResponseState                      := _idle; 
        //*****************************************************
      end_case;
    
    //********************************************************************************************************************************
  	t_e_SDOConfig::_SDOConfig_Read5:
      case eResponseState of
        _idle:
          biReqSDOConfigRdWr.ReadConfigSDO5  := FALSE;
          bsRespSDOConfigRdWr.ReadConfigSDO5 := FALSE;
          TmpRetcode  := StartReadSDO(hOffset:=ST151_ADDR_SDO_5, usLength:=sizeof(sReadSDO.SDOData5), eCommand:=SDIAS_SDO_CMD_MEM_READ);
          if TmpRetcode = READY then
            udSDOTimeout  := ops.tAbsolute;
            eResponseState:= _wait; 
          elsif TmpRetcode = ERROR then
            LogError("@ZZZZ (ST151Base::SDORdWrData) Failed to add SDO for read of configuration");
            eActSDOConfigRdWr := _SDOConfig_Error;
          end_if;
          //*****************************************************
        _wait:
          // wait for response
          if ((ops.tAbsolute - udSDOTimeout) > ST151_SDO_RESPONSE_TIMEOUT) then
            LogError("@ZZZZ (ST151Base::SDORdWrData) SDO Response timeout config module");
            eActSDOConfigRdWr := _SDOConfig_Error;
          end_if;          
        //*****************************************************
        _valid:
          eActSDOConfigRdWr := SetSDORdWrStep(eActStep:=eActSDOConfigRdWr);
          bsRespSDOConfigRdWr.ReadConfigSDO5  := TRUE;
          eResponseState                      := _idle; 
        //*****************************************************
      end_case;      
      
    //********************************************************************************************************************************
  	t_e_SDOConfig::_SDOConfig_Read6:
      case eResponseState of
        _idle:
          biReqSDOConfigRdWr.ReadConfigSDO6  := FALSE;
          bsRespSDOConfigRdWr.ReadConfigSDO6 := FALSE;
          TmpRetcode  := StartReadSDO(hOffset:=ST151_ADDR_SDO_6, usLength:=sizeof(sReadSDO.SDOData6), eCommand:=SDIAS_SDO_CMD_MEM_READ);
          if TmpRetcode = READY then
            udSDOTimeout  := ops.tAbsolute;
            eResponseState:= _wait; 
          elsif TmpRetcode = ERROR then
            LogError("@ZZZZ (ST151Base::SDORdWrData) Failed to add SDO for read of configuration");
            eActSDOConfigRdWr := _SDOConfig_Error;
          end_if;
          //*****************************************************
        _wait:
          // wait for response
          if ((ops.tAbsolute - udSDOTimeout) > ST151_SDO_RESPONSE_TIMEOUT) then
            LogError("@ZZZZ (ST151Base::SDORdWrData) SDO Response timeout config module");
            eActSDOConfigRdWr := _SDOConfig_Error;
          end_if;          
        //*****************************************************
        _valid:
          eActSDOConfigRdWr := SetSDORdWrStep(eActStep:=eActSDOConfigRdWr);
          bsRespSDOConfigRdWr.ReadConfigSDO6  := TRUE;
          eResponseState                      := _idle; 
        //*****************************************************
      end_case;      
      
    //********************************************************************************************************************************
  	t_e_SDOConfig::_SDOConfig_Finished:
      //all ok sdo config is finished
      dRetCode          := READY;
      usSDORetrys       := 0;
      eActSDOConfigRdWr := _SDOConfig_Idle;      
    
    //********************************************************************************************************************************
  	t_e_SDOConfig::_SDOConfig_Error:
      dRetCode          := ERROR;
      usSDORetrys       += 1;
      if usSDORetrys < ST151_SDO_MAX_RETRYS then
        eActSDOConfigRdWr := _SDOConfig_Idle;        
      end_if;
      eResponseState    := _idle;
      
  end_case;  

END_FUNCTION


FUNCTION VIRTUAL GLOBAL ST151Base::FrequLimitIncrease2to1::Write
	VAR_INPUT
		input (EAX) 	: UDINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: UDINT;
	END_VAR
  VAR
    siActArrayEntry : SINT;
  END_VAR
  
  siActArrayEntry := 0;
  //calculate compatibility mode if client is set
  input *= usCompModeVST;
  
   // Check for max frequency limit 
  if input > ST151_MAXFREQUENCY_OUT then
    input := ST151_MAXFREQUENCY_OUT;
  end_if;
  
  if aFrequencyLimit[siActArrayEntry].LimitIncrease <> input then //do we have a new value?
    //Save Input
    FrequLimitIncrease2to1 := input / usCompModeVST;
    
    aFrequencyLimit[siActArrayEntry].LimitIncrease := input;
    FrequLimitDecrease1to2.Write(input:=FrequLimitDecrease1to2);
    
    if aFrequencyLimit[siActArrayEntry].LimitIncrease <> sWriteSDO.SDOData1.FrequLimitRising2 then //do we have a new value?  
      //Set new Limit
      sWriteSDO.SDOData1.FrequLimitRising2 := aFrequencyLimit[siActArrayEntry].LimitIncrease;
      biReqSDOConfigRdWr.WriteConfigSDO1   := TRUE;
    end_if;  
  end_if;  

  result := FrequLimitIncrease2to1;  
  
END_FUNCTION


FUNCTION VIRTUAL GLOBAL ST151Base::FrequLimitIncrease4to2::Write
	VAR_INPUT
		input (EAX) 	: UDINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: UDINT;
	END_VAR
  VAR
    siActArrayEntry : SINT;
  END_VAR
  
  siActArrayEntry := 1;
  //calculate compatibility mode if client is set
  input *= usCompModeVST;

   // Check for max frequency limit 
  if input > ST151_MAXFREQUENCY_OUT then
    input := ST151_MAXFREQUENCY_OUT;
  end_if;
  
  if aFrequencyLimit[siActArrayEntry].LimitIncrease <> input then //do we have a new value?
    //Save Input
    FrequLimitIncrease4to2 := input / usCompModeVST;
    
    aFrequencyLimit[siActArrayEntry].LimitIncrease := input;
    FrequLimitDecrease2to4.Write(input:=FrequLimitDecrease2to4);
    
    if aFrequencyLimit[siActArrayEntry].LimitIncrease <> sWriteSDO.SDOData1.FrequLimitRising4 then //do we have a new value?  
      //Set new Limit
      sWriteSDO.SDOData1.FrequLimitRising4 := aFrequencyLimit[siActArrayEntry].LimitIncrease;
      biReqSDOConfigRdWr.WriteConfigSDO1   := TRUE;
    end_if;        
  end_if;

  result := FrequLimitIncrease4to2;  
  
END_FUNCTION


FUNCTION VIRTUAL GLOBAL ST151Base::FrequLimitIncrease8to4::Write
	VAR_INPUT
		input (EAX) 	: UDINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: UDINT;
	END_VAR
  VAR
    siActArrayEntry : SINT;
  END_VAR
  
  siActArrayEntry := 2;
  //calculate compatibility mode if client is set
  input *= usCompModeVST;

   // Check for max frequency limit 
  if input > ST151_MAXFREQUENCY_OUT then
    input := ST151_MAXFREQUENCY_OUT;
  end_if;
  
  if aFrequencyLimit[siActArrayEntry].LimitIncrease <> input then //do we have a new value?
    //Save Input
    FrequLimitIncrease8to4 := input / usCompModeVST;
    
    aFrequencyLimit[siActArrayEntry].LimitIncrease := input;
    FrequLimitDecrease4to8.Write(input:=FrequLimitDecrease4to8);
    
    if aFrequencyLimit[siActArrayEntry].LimitIncrease <> sWriteSDO.SDOData1.FrequLimitRising8 then //do we have a new value?  
      //Set new Limit
      sWriteSDO.SDOData1.FrequLimitRising8 := aFrequencyLimit[siActArrayEntry].LimitIncrease;
      biReqSDOConfigRdWr.WriteConfigSDO1   := TRUE;
    end_if;        
  end_if;

  result := FrequLimitIncrease8to4;  
  
END_FUNCTION


FUNCTION VIRTUAL GLOBAL ST151Base::FrequLimitIncrease16to8::Write
	VAR_INPUT
		input (EAX) 	: UDINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: UDINT;
	END_VAR
  VAR
    siActArrayEntry : SINT;
  END_VAR
  
  siActArrayEntry := 3;
  //calculate compatibility mode if client is set
  input *= usCompModeVST;

   // Check for max frequency limit 
  if input > ST151_MAXFREQUENCY_OUT then
    input := ST151_MAXFREQUENCY_OUT;
  end_if;
  
  if aFrequencyLimit[siActArrayEntry].LimitIncrease <> input then //do we have a new value?
    //Save Input
    FrequLimitIncrease16to8 := input / usCompModeVST;
    
    aFrequencyLimit[siActArrayEntry].LimitIncrease := input;
    FrequLimitDecrease8to16.Write(input:=FrequLimitDecrease8to16);
    
    if aFrequencyLimit[siActArrayEntry].LimitIncrease <> sWriteSDO.SDOData1.FrequLimitRising16 then //do we have a new value?  
      //Set new Limit
      sWriteSDO.SDOData1.FrequLimitRising16 := aFrequencyLimit[siActArrayEntry].LimitIncrease;
      biReqSDOConfigRdWr.WriteConfigSDO1    := TRUE;
    end_if;        
  end_if;

  result := FrequLimitIncrease16to8;  
  
END_FUNCTION


FUNCTION VIRTUAL GLOBAL ST151Base::FrequLimitIncrease32to16::Write
	VAR_INPUT
		input (EAX) 	: UDINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: UDINT;
	END_VAR
  VAR
    siActArrayEntry : SINT;
  END_VAR
  
  siActArrayEntry := 4;
  //calculate compatibility mode if client is set
  input *= usCompModeVST;

   // Check for max frequency limit 
  if input > ST151_MAXFREQUENCY_OUT then
    input := ST151_MAXFREQUENCY_OUT;
  end_if;
  
  if aFrequencyLimit[siActArrayEntry].LimitIncrease <> input then //do we have a new value?
    //Save Input
    FrequLimitIncrease32to16 := input / usCompModeVST;
    
    aFrequencyLimit[siActArrayEntry].LimitIncrease := input;
    FrequLimitDecrease16to32.Write(input:=FrequLimitDecrease16to32);
    
    if aFrequencyLimit[siActArrayEntry].LimitIncrease <> sWriteSDO.SDOData1.FrequLimitRising32 then //do we have a new value?  
      //Set new Limit
      sWriteSDO.SDOData1.FrequLimitRising32 := aFrequencyLimit[siActArrayEntry].LimitIncrease;
      biReqSDOConfigRdWr.WriteConfigSDO1    := TRUE;
    end_if;        
  end_if;

  result := FrequLimitIncrease32to16;  
  
END_FUNCTION


FUNCTION VIRTUAL GLOBAL ST151Base::FrequLimitIncrease64to32::Write
	VAR_INPUT
		input (EAX) 	: UDINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: UDINT;
	END_VAR
  VAR
    siActArrayEntry : SINT;
  END_VAR
  
  siActArrayEntry := 5;
  //calculate compatibility mode if client is set
  input *= usCompModeVST;

   // Check for max frequency limit 
  if input > ST151_MAXFREQUENCY_OUT then
    input := ST151_MAXFREQUENCY_OUT;
  end_if;
  
  if aFrequencyLimit[siActArrayEntry].LimitIncrease <> input then //do we have a new value?
    //Save Input
    FrequLimitIncrease64to32 := input / usCompModeVST;
    
    aFrequencyLimit[siActArrayEntry].LimitIncrease := input;
    FrequLimitDecrease32to64.Write(input:=FrequLimitDecrease32to64);
    
    if aFrequencyLimit[siActArrayEntry].LimitIncrease <> sWriteSDO.SDOData1.FrequLimitRising64 then //do we have a new value?  
      //Set new Limit
      sWriteSDO.SDOData1.FrequLimitRising64 := aFrequencyLimit[siActArrayEntry].LimitIncrease;
      biReqSDOConfigRdWr.WriteConfigSDO1    := TRUE;
    end_if;        
  end_if;

  result := FrequLimitIncrease64to32;  
  
END_FUNCTION


FUNCTION VIRTUAL GLOBAL ST151Base::FrequLimitDecrease1to2::Write
	VAR_INPUT
		input (EAX) 	: UDINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: UDINT;
	END_VAR
  VAR
    siActArrayEntry : SINT;
  END_VAR
  
  siActArrayEntry := 0;
  //calculate compatibility mode if client is set
  input *= usCompModeVST;

   // Check for max frequency limit 
  if input > ST151_MAXFREQUENCY_OUT then
    input := ST151_MAXFREQUENCY_OUT;
  end_if;
  //Save Input
  FrequLimitDecrease1to2 := input / usCompModeVST;
  
  if input <> ST151_AUTOSET_FREQUENCYLIMIT then
    aFrequencyLimit[siActArrayEntry].LimitDecrease := input;
  else
    CalcSimpleMode();
  end_if;
  
  if aFrequencyLimit[siActArrayEntry].LimitDecrease <> sWriteSDO.SDOData5.FrequLimitFalling1to2 then //do we have a new value?  
    //Set new Limit
    sWriteSDO.SDOData5.FrequLimitFalling1to2 := aFrequencyLimit[siActArrayEntry].LimitDecrease;
    biReqSDOConfigRdWr.WriteConfigSDO5       := TRUE;
  end_if;
  
  result := FrequLimitDecrease1to2;  

END_FUNCTION


FUNCTION VIRTUAL GLOBAL ST151Base::FrequLimitDecrease2to4::Write
	VAR_INPUT
		input (EAX) 	: UDINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: UDINT;
	END_VAR
  VAR
    siActArrayEntry : SINT;
  END_VAR
  
  siActArrayEntry := 1;
  //calculate compatibility mode if client is set
  input *= usCompModeVST;
  
   // Check for max frequency limit 
  if input > ST151_MAXFREQUENCY_OUT then
    input := ST151_MAXFREQUENCY_OUT;
  end_if;
  //Save Input
  FrequLimitDecrease2to4 := input / usCompModeVST; 
  
  if input <> ST151_AUTOSET_FREQUENCYLIMIT then
    aFrequencyLimit[siActArrayEntry].LimitDecrease := input;
  else
    CalcSimpleMode();
  end_if;
  if aFrequencyLimit[siActArrayEntry].LimitDecrease <> sWriteSDO.SDOData5.FrequLimitFalling2to4 then //do we have a new value?  
    //Set new Limit
    sWriteSDO.SDOData5.FrequLimitFalling2to4 := aFrequencyLimit[siActArrayEntry].LimitDecrease;
    biReqSDOConfigRdWr.WriteConfigSDO5       := TRUE;
  end_if;
  
  result := FrequLimitDecrease2to4; 

END_FUNCTION


FUNCTION VIRTUAL GLOBAL ST151Base::FrequLimitDecrease4to8::Write
	VAR_INPUT
		input (EAX) 	: UDINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: UDINT;
	END_VAR
  VAR
    siActArrayEntry : SINT;
  END_VAR
  
  siActArrayEntry := 2;
  //calculate compatibility mode if client is set
  input *= usCompModeVST;
  
   // Check for max frequency limit 
  if input > ST151_MAXFREQUENCY_OUT then
    input := ST151_MAXFREQUENCY_OUT;
  end_if;
  //Save Input
  FrequLimitDecrease4to8 := input / usCompModeVST;
  
  if input <> ST151_AUTOSET_FREQUENCYLIMIT then
    aFrequencyLimit[siActArrayEntry].LimitDecrease := input;
  else
    CalcSimpleMode();
  end_if;
  if aFrequencyLimit[siActArrayEntry].LimitDecrease <> sWriteSDO.SDOData5.FrequLimitFalling4to8 then //do we have a new value?  
    //Set new Limit
    sWriteSDO.SDOData5.FrequLimitFalling4to8 := aFrequencyLimit[siActArrayEntry].LimitDecrease;
    biReqSDOConfigRdWr.WriteConfigSDO5       := TRUE;
  end_if;
  
  result := FrequLimitDecrease4to8; 

END_FUNCTION


FUNCTION VIRTUAL GLOBAL ST151Base::FrequLimitDecrease8to16::Write
	VAR_INPUT
		input (EAX) 	: UDINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: UDINT;
	END_VAR
  VAR
    siActArrayEntry : SINT;
  END_VAR
  
  siActArrayEntry := 3;
  //calculate compatibility mode if client is set
  input *= usCompModeVST;
  
   // Check for max frequency limit 
  if input > ST151_MAXFREQUENCY_OUT then
    input := ST151_MAXFREQUENCY_OUT;
  end_if;
  //Save Input
  FrequLimitDecrease8to16 := input / usCompModeVST;
  
  if input <> ST151_AUTOSET_FREQUENCYLIMIT then
    aFrequencyLimit[siActArrayEntry].LimitDecrease := input;
  else
    CalcSimpleMode();
  end_if;
  if aFrequencyLimit[siActArrayEntry].LimitDecrease <> sWriteSDO.SDOData5.FrequLimitFalling8to16 then //do we have a new value?  
    //Set new Limit
    sWriteSDO.SDOData5.FrequLimitFalling8to16 := aFrequencyLimit[siActArrayEntry].LimitDecrease;
    biReqSDOConfigRdWr.WriteConfigSDO5        := TRUE;
  end_if;
  
  result := FrequLimitDecrease8to16; 

END_FUNCTION


FUNCTION VIRTUAL GLOBAL ST151Base::FrequLimitDecrease16to32::Write
	VAR_INPUT
		input (EAX) 	: UDINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: UDINT;
	END_VAR
  VAR
    siActArrayEntry : SINT;
  END_VAR
  
  siActArrayEntry := 4;
  //calculate compatibility mode if client is set
  input *= usCompModeVST;
  
   // Check for max frequency limit 
  if input > ST151_MAXFREQUENCY_OUT then
    input := ST151_MAXFREQUENCY_OUT;
  end_if;
  //Save Input
  FrequLimitDecrease16to32 := input / usCompModeVST;
  
  if input <> ST151_AUTOSET_FREQUENCYLIMIT then
    aFrequencyLimit[siActArrayEntry].LimitDecrease := input;
  else
    CalcSimpleMode();
  end_if;
  if aFrequencyLimit[siActArrayEntry].LimitDecrease <> sWriteSDO.SDOData5.FrequLimitFalling16to32 then //do we have a new value?  
    //Set new Limit
    sWriteSDO.SDOData5.FrequLimitFalling16to32 := aFrequencyLimit[siActArrayEntry].LimitDecrease;
    biReqSDOConfigRdWr.WriteConfigSDO5         := TRUE;
  end_if;
  
  result := FrequLimitDecrease16to32; 

END_FUNCTION


FUNCTION VIRTUAL GLOBAL ST151Base::FrequLimitDecrease32to64::Write
	VAR_INPUT
		input (EAX) 	: UDINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: UDINT;
	END_VAR
  VAR
    siActArrayEntry : SINT;
  END_VAR
  
  siActArrayEntry := 5;
  //calculate compatibility mode if client is set
  input *= usCompModeVST;
  
   // Check for max frequency limit 
  if input > ST151_MAXFREQUENCY_OUT then
    input := ST151_MAXFREQUENCY_OUT;
  end_if;
  //Save Input
  FrequLimitDecrease32to64 := input / usCompModeVST;
  
  if input <> ST151_AUTOSET_FREQUENCYLIMIT then
    aFrequencyLimit[siActArrayEntry].LimitDecrease := input;
  else
    CalcSimpleMode();
  end_if;
  if aFrequencyLimit[siActArrayEntry].LimitDecrease <> sWriteSDO.SDOData5.FrequLimitFalling32to64 then //do we have a new value?  
    //Set new Limit
    sWriteSDO.SDOData5.FrequLimitFalling32to64 := aFrequencyLimit[siActArrayEntry].LimitDecrease;
    biReqSDOConfigRdWr.WriteConfigSDO5         := TRUE;
  end_if;
  
  result := FrequLimitDecrease32to64; 

END_FUNCTION


FUNCTION ST151Base::CalcAdaptiveMicroStepping
	VAR_INPUT
		dTargetFrequency 	: DINT;
		dActSetFrequency 	: DINT;
	END_VAR
	VAR_OUTPUT
		dRetCode 	: DINT;
	END_VAR
  VAR
    usTempLimitCnt : USINT;
    bDesiredSteppingMode : BOOL;
    udActLowFrequency : UDINT;
    tempActiveSteps : bd_EnabledFreqLimit;
  END_VAR
  
  dRetCode          := 0;
  udActLowFrequency := 0;
  tempActiveSteps   := 0;
  bDesiredSteppingMode := FALSE;  
  //search for needed steps
  if abs(dTargetFrequency) > abs(dActSetFrequency) then
    //acceleration
    sStepsNeeded.IncreaseFreq := 0;
    sAdaptiveStepping.usIncreaseActStepsActivated := 0;
        
    for usTempLimitCnt := 0  to ST151_MAXSTEPPING_MODES-1 do
      //step is needed if desired frequency is higher than frequency limit      
      if abs(dTargetFrequency)$UDINT >= aFrequencyLimit[usTempLimitCnt].LimitIncrease then
        sStepsNeeded.IncreaseFreq := sStepsNeeded.IncreaseFreq or (1 shl (usTempLimitCnt));
        bDesiredSteppingMode      := TRUE;
        if abs(dActSetFrequency)$UDINT <= aFrequencyLimit[usTempLimitCnt].LimitIncrease then          
          sStepsNeeded.IncreaseFreq := sStepsNeeded.IncreaseFreq or (1 shl (usTempLimitCnt+1));
        end_if;
      end_if; 
    end_for;
    
    //activate 64 stepping mode if desired frequence is lower then this limit
    if bDesiredSteppingMode = FALSE then
      sStepsNeeded.IncreaseFreq := sStepsNeeded.IncreaseFreq or (1 shl usTempLimitCnt-1);
      sAdaptiveStepping.aIncreaseLimitsArrayEntry[sAdaptiveStepping.usIncreaseActStepsActivated] := usTempLimitCnt;
      sAdaptiveStepping.usIncreaseActStepsActivated += 1;
    else  
      //delete bits if start frequence is higher than stepping mode
      for usTempLimitCnt := 0  to ST151_MAXSTEPPING_MODES do   
        if abs(dActSetFrequency)$UDINT > aFrequencyLimit[usTempLimitCnt].LimitIncrease
        & (sStepsNeeded.IncreaseFreq shr usTempLimitCnt+1) and 0x01 then
          sStepsNeeded.IncreaseFreq := sStepsNeeded.IncreaseFreq xor (1 shl usTempLimitCnt+1);
        end_if;
  
        if (sStepsNeeded.IncreaseFreq shr usTempLimitCnt) and 0x01 
        & (EnableSteps shr usTempLimitCnt) and 0x01 then
          sAdaptiveStepping.aIncreaseLimitsArrayEntry[sAdaptiveStepping.usIncreaseActStepsActivated] := usTempLimitCnt;
          sAdaptiveStepping.usIncreaseActStepsActivated += 1;
        end_if;
      end_for;
    end_if;
    
    //remove disabled steps
    sStepsNeeded.IncreaseFreq := sStepsNeeded.IncreaseFreq and EnableSteps;
    if sAdaptiveStepping.usIncreaseActStepsActivated > 2 then
      udActLowFrequency       := aFrequencyLimit[sAdaptiveStepping.aIncreaseLimitsArrayEntry[0]].LimitDecrease;
      //search for needed steppings for adaptive mode
      for usTempLimitCnt := 1 to sAdaptiveStepping.usIncreaseActStepsActivated-2 do
        if aFrequencyLimit[sAdaptiveStepping.aIncreaseLimitsArrayEntry[usTempLimitCnt]].LimitIncrease < udActLowFrequency then
          //step before must be activated
          tempActiveSteps := tempActiveSteps or (1 shl sAdaptiveStepping.aIncreaseLimitsArrayEntry[usTempLimitCnt]);
          udActLowFrequency := aFrequencyLimit[sAdaptiveStepping.aIncreaseLimitsArrayEntry[usTempLimitCnt]].LimitDecrease;
        end_if;      
      end_for;    
    end_if;
    //step for desired frequency is always needed
    tempActiveSteps := tempActiveSteps or (1 shl sAdaptiveStepping.aIncreaseLimitsArrayEntry[0]);
    //step of start frequency is always needed
    tempActiveSteps := tempActiveSteps or (1 shl sAdaptiveStepping.aIncreaseLimitsArrayEntry[sAdaptiveStepping.usIncreaseActStepsActivated-1]);    
  
  else
    //decceleration
    sStepsNeeded.DecreaseFreq := 0;
    sAdaptiveStepping.usDecreaseActStepsActivated := 0;
       
    for usTempLimitCnt := 0  to ST151_MAXSTEPPING_MODES-1 do
      //step is needed if desired frequency is higher than frequency limit      
      if abs(dActSetFrequency)$UDINT >= aFrequencyLimit[usTempLimitCnt].LimitIncrease then
        sStepsNeeded.DecreaseFreq := sStepsNeeded.DecreaseFreq or (1 shl usTempLimitCnt);
        bDesiredSteppingMode      := TRUE;
        if abs(dTargetFrequency)$UDINT <= aFrequencyLimit[usTempLimitCnt].LimitIncrease then          
          sStepsNeeded.DecreaseFreq := sStepsNeeded.DecreaseFreq or (1 shl usTempLimitCnt+1);
        end_if;
      end_if; 
    end_for;
    
    //activate 64 stepping mode if desired frequence is lower then this limit
    if bDesiredSteppingMode = FALSE then
      sStepsNeeded.DecreaseFreq := sStepsNeeded.DecreaseFreq or (1 shl usTempLimitCnt-1);
      sAdaptiveStepping.aDecreaseLimitsArrayEntry[sAdaptiveStepping.usDecreaseActStepsActivated] := usTempLimitCnt;
      sAdaptiveStepping.usDecreaseActStepsActivated += 1;
    else  
      //delete bits if start frequence is higher than stepping mode
      for usTempLimitCnt := 0  to ST151_MAXSTEPPING_MODES do   
        if abs(dTargetFrequency)$UDINT > aFrequencyLimit[usTempLimitCnt].LimitIncrease
        & (sStepsNeeded.DecreaseFreq shr usTempLimitCnt+1) and 0x01 then
          sStepsNeeded.DecreaseFreq := sStepsNeeded.DecreaseFreq xor (1 shl usTempLimitCnt+1);
        end_if;
  
        if (sStepsNeeded.DecreaseFreq shr usTempLimitCnt) and 0x01 
        & (EnableSteps shr usTempLimitCnt) and 0x01 then
          sAdaptiveStepping.aDecreaseLimitsArrayEntry[sAdaptiveStepping.usDecreaseActStepsActivated] := usTempLimitCnt;
          sAdaptiveStepping.usDecreaseActStepsActivated += 1;
        end_if;
      end_for;
    end_if;
    
    //remove disabled steps
    sStepsNeeded.DecreaseFreq := sStepsNeeded.DecreaseFreq and EnableSteps;
    if sAdaptiveStepping.usDecreaseActStepsActivated > 2 then
      udActLowFrequency       := aFrequencyLimit[sAdaptiveStepping.aDecreaseLimitsArrayEntry[0]].LimitDecrease;
      //search for needed steppings for adaptive mode
      for usTempLimitCnt := 1 to sAdaptiveStepping.usDecreaseActStepsActivated-2 do
        if aFrequencyLimit[sAdaptiveStepping.aDecreaseLimitsArrayEntry[usTempLimitCnt]].LimitIncrease < udActLowFrequency then
          //step before must be activated
          tempActiveSteps := tempActiveSteps or (1 shl sAdaptiveStepping.aDecreaseLimitsArrayEntry[usTempLimitCnt]);
          udActLowFrequency := aFrequencyLimit[sAdaptiveStepping.aDecreaseLimitsArrayEntry[usTempLimitCnt]].LimitDecrease;
        end_if;      
      end_for;    
    end_if;
    //step for desired frequency is always needed
    tempActiveSteps := tempActiveSteps or (1 shl sAdaptiveStepping.aDecreaseLimitsArrayEntry[0]);
    //step of start frequency is always needed
    tempActiveSteps := tempActiveSteps or (1 shl sAdaptiveStepping.aDecreaseLimitsArrayEntry[sAdaptiveStepping.usDecreaseActStepsActivated-1]);    
   
  end_if;
  
  //write activated steppings to module
  sAccesses.sWriteData.ControlWord.EnableFullStep  := tempActiveSteps.FullStep;
  sAccesses.sWriteData.ControlWord.EnableHalfStep  := tempActiveSteps.HalfStep;
  sAccesses.sWriteData.ControlWord.EnableStep4  := tempActiveSteps.MicroStepping4;
  sAccesses.sWriteData.ControlWord.EnableStep8  := tempActiveSteps.MicroStepping8;
  sAccesses.sWriteData.ControlWord.EnableStep16 := tempActiveSteps.MicroStepping16;
  sAccesses.sWriteData.ControlWord.EnableStep32 := tempActiveSteps.MicroStepping32;
  sAccesses.sWriteData.ControlWord.EnableStep64 := tempActiveSteps.MicroStepping64;    
  
END_FUNCTION


FUNCTION VIRTUAL GLOBAL ST151Base::RefreshValues::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR
  
  if input <> RefreshValues then  
    RefreshValues := input;
    case RefreshValues of
      0: //refreshing of values is deactivated
      
      1: //refresh values cyclic
//        biReqSDOConfigRdWr.ReadConfigSDO4 := TRUE;
      
      2: //refresh value one time
        biReqSDOConfigRdWr.ReadConfigSDO4 := TRUE;
      
    else
      //wrong value input
    end_case;

    result := RefreshValues;
  
  end_if;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL ST151Base::EnableSteps::Write
	VAR_INPUT
		input (EAX) 	: ST151Base::bd_EnabledFreqLimit;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: ST151Base::bd_EnabledFreqLimit;
	END_VAR
  VAR
  	biControlWord  : t_ControlWord;
  END_VAR
  
  if EnableSteps <> input then
    if usCompModeVST = 2 then
      //deactivate microstep mode 64 if vst comp mode is active
      input.MicroStepping64 := 0;
    end_if;    
    EnableSteps := input and 0x7F;
    //initialize variable
    biControlWord := sAccesses.sWriteData.ControlWord;
    biControlWord.EnableStep64 := EnableSteps.MicroStepping64; // 
    biControlWord.EnableStep32 := EnableSteps.MicroStepping32; //  
    biControlWord.EnableStep16 := EnableSteps.MicroStepping16; //  
    biControlWord.EnableStep8  := EnableSteps.MicroStepping8; //
    biControlWord.EnableStep4  := EnableSteps.MicroStepping4; //   
    biControlWord.EnableHalfStep := EnableSteps.HalfStep; //
    biControlWord.EnableFullStep := EnableSteps.FullStep := TRUE; // full step can not be deactivated!
    sAccesses.sWriteData.ControlWord := biControlWord;  
    //calculate decrease steps again
    FrequLimitDecrease1to2.Write(input:=FrequLimitDecrease1to2);  
    FrequLimitDecrease2to4.Write(input:=FrequLimitDecrease2to4);
    FrequLimitDecrease4to8.Write(input:=FrequLimitDecrease4to8); 
    FrequLimitDecrease8to16.Write(input:=FrequLimitDecrease8to16);  
    FrequLimitDecrease16to32.Write(input:=FrequLimitDecrease16to32);  
    FrequLimitDecrease32to64.Write(input:=FrequLimitDecrease32to64);  
  end_if;
	result := EnableSteps;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL ST151Base::AddAccesses
	VAR_OUTPUT
		eModuleInitState 	: iprStates;
	END_VAR
  VAR
  	usTempCnt : USINT;
    uiTempLength : UINT;
  END_VAR

  eModuleInitState := READY;

  UseOszi := UseOszi.Read();

  if UseOszi then  
    if AddWrAccess(hOffset              := ST151_OSZI_ADDR_WRITE
                 , uLength              := sizeof(t_s_OsziWrite)
                 , ppData               := #sAccessesOszi.pWriteHeader
                 , ppStateByte          := #sAccessesOszi.WriteHeaderControl.pStateByte
                 , ppControlByte        := #sAccessesOszi.WriteHeaderControl.pControlByte
                 , pAccessHandle        := #sAccessesOszi.WriteHeaderControl.AccessHandle
                 ) <> READY then
      LogError(pMsg:="@ZZZZ (ST151Base::AddAccesses) Adding write far memory access for oszi function failed! Update OS and/or fpga and/or SdiasManager-class.");
      //only deactivate oszi funktion
      UseOszi := 0;
      return;
    end_if;

    if AddRdAccess(hOffset              := ST151_OSZI_ADDR_READ
                 , uLength              := sizeof(t_s_OsziRead)
                 , ppData               := #sAccessesOszi.pReadHeader
                 , ppStateByte          := #sAccessesOszi.ReadHeaderControl.pStateByte
                 , ppControlByte        := #sAccessesOszi.ReadHeaderControl.pControlByte
                 , pAccessHandle        := #sAccessesOszi.ReadHeaderControl.AccessHandle
                 ) <> READY then
      LogError(pMsg:="@ZZZZ (ST151Base::AddAccesses) Adding read far memory access for oszi function failed! Update OS and/or fpga and/or SdiasManager-class.");
      //only deactivate oszi funktion
      UseOszi := 0;
      return;
    end_if;
    
    for usTempCnt := 0 to ST151_OSZI_MAX_PDOREAD-1 do
      uiTempLength := (usTempCnt+1)*ST151_OSZI_ONE_PDOSIZE;
      if uiTempLength > ST151_OSZI_BUFFER_SIZE then
        uiTempLength := ST151_OSZI_BUFFER_SIZE - (usTempCnt*ST151_OSZI_ONE_PDOSIZE);
      else
        uiTempLength := ST151_OSZI_ONE_PDOSIZE;
      end_if;

      if AddRdAccess(hOffset              := ST151_OSZI_ADDR_DATA + (sizeof(a_uiOsziValues)*usTempCnt)
                   , uLength              := uiTempLength
                   , ppData               := #sAccessesOszi.apOsziData[usTempCnt]
                   , ppStateByte          := #sAccessesOszi.aReadDataControl[usTempCnt].pStateByte
                   , ppControlByte        := #sAccessesOszi.aReadDataControl[usTempCnt].pControlByte
                   , pAccessHandle        := #sAccessesOszi.aReadDataControl[usTempCnt].AccessHandle
                   ) <> READY then
        LogError(pMsg:="@ZZZZ (ST151Base::AddAccesses) Adding read far memory access for oszi function failed! Update OS and/or fpga and/or SdiasManager-class.");
        //only deactivate oszi funktion
        UseOszi := 0;
        return;
      end_if;
    end_for;
  end_if;

END_FUNCTION


FUNCTION GLOBAL ST151Base::StartMeasure
	VAR_INPUT
		pData 	: ^void;
		uiTriggerLevel 	: UINT;
		uiSamplePrescaler 	: UINT;
		bStartStopMeasure 	: BOOL;
		usTriggerSetting 	: USINT;
		usTriggerOffset 	: USINT;
	END_VAR
	VAR_OUTPUT
		dRetCode 	: DINT;
	END_VAR
    
  dRetCode := 0;
  
  if UseOszi = 0 then
    dRetCode := -1;
    return;
  end_if;
  
  if pData = NIL then
    dRetCode := -2;
    return;      
  end_if;   
  
  sAccessesOszi.sWriteOszi.TriggerLevel        := uiTriggerLevel;
  sAccessesOszi.sWriteOszi.SampleTimePrescaler := uiSamplePrescaler;
  
  case usTriggerSetting of
    0:  sAccessesOszi.sWriteOszi.ControlOszi.RisingEdge  := TRUE;
        sAccessesOszi.sWriteOszi.ControlOszi.FallingEdge := FALSE;
        sAccessesOszi.sWriteOszi.ControlOszi.Force       := FALSE;
        
    1:  sAccessesOszi.sWriteOszi.ControlOszi.RisingEdge  := FALSE;
        sAccessesOszi.sWriteOszi.ControlOszi.FallingEdge := TRUE;
        sAccessesOszi.sWriteOszi.ControlOszi.Force       := FALSE;        
        
    2:  sAccessesOszi.sWriteOszi.ControlOszi.RisingEdge  := FALSE;
        sAccessesOszi.sWriteOszi.ControlOszi.FallingEdge := FALSE;
        sAccessesOszi.sWriteOszi.ControlOszi.Force       := TRUE;
  else
    dRetCode := -3;
    return;
  end_case;
  
  case usTriggerOffset of
    0: sAccessesOszi.usOsziTriggerOffset := 0;  
       sAccessesOszi.uiSamplesAfterTrigger := ST151_OSZI_MAX_SAMPLES;
       sAccessesOszi.uiSamplesBeforeTrigger  := 0;
    1: sAccessesOszi.usOsziTriggerOffset := 25;
       sAccessesOszi.uiSamplesAfterTrigger := ((ST151_OSZI_MAX_SAMPLES/4)*3);
       sAccessesOszi.uiSamplesBeforeTrigger  := (ST151_OSZI_MAX_SAMPLES/4);
    2: sAccessesOszi.usOsziTriggerOffset := 50;
       sAccessesOszi.uiSamplesAfterTrigger := (ST151_OSZI_MAX_SAMPLES/2);
       sAccessesOszi.uiSamplesBeforeTrigger  := (ST151_OSZI_MAX_SAMPLES/2);
    3: sAccessesOszi.usOsziTriggerOffset := 75;
       sAccessesOszi.uiSamplesAfterTrigger := (ST151_OSZI_MAX_SAMPLES/4);
       sAccessesOszi.uiSamplesBeforeTrigger  := ((ST151_OSZI_MAX_SAMPLES/4)*3);
    
  else
    dRetCode := -4;
    return;
  end_case;  
  
  sAccessesOszi.sWriteOszi.SamplesAfterTrigger := sAccessesOszi.uiSamplesAfterTrigger-1; 
  sAccessesOszi.bDataReady                     := FALSE;
  
  if bStartStopMeasure then  
    if sAccessesOszi.eOsziData <> _OsziDataIdle then
      //other trigger is at progress
      dRetCode := -5;
      return;    
    end_if;
    sAccessesOszi.pToExternData := pData;
    sAccessesOszi.sWriteOszi.ControlOszi.CancelTrigger   := FALSE;
    sAccessesOszi.sWriteOszi.ControlOszi.StartTriggering := TRUE;
    sAccessesOszi.bMeasureStarted                        := TRUE;
  else  
    sAccessesOszi.sWriteOszi.ControlOszi.CancelTrigger   := TRUE;
    sAccessesOszi.sWriteOszi.ControlOszi.StartTriggering := FALSE;
    sAccessesOszi.bMeasureStarted                        := FALSE;
  end_if;
  //reset last oszi state
  sAccessesOszi.sLastOsziState.StateOszi := 0;
  sAccessesOszi.eOsziData := _OsziTriggerStart;
  
END_FUNCTION


FUNCTION ST151Base::GetMeasureData
	VAR_INPUT
		pData 	: ^void;
	END_VAR
  VAR
  	uiCopiedData : UINT;
  END_VAR
      
  uiCopiedData := 0;
  if sAccessesOszi.bSplitBuffer = FALSE then
    _memcpy(ptr1:=pData, ptr2:=sAccessesOszi.pFirstEntryOsziData, cntr:=sAccessesOszi.uiDatalength1);
  else
    //buffer data is splitted
    _memcpy(ptr1:=pData, ptr2:=sAccessesOszi.pFirstEntryOsziData, cntr:=sAccessesOszi.uiDatalength2);
    
    _memcpy(ptr1:=(pData+sAccessesOszi.uiDatalength2), ptr2:=#sAccessesOszi.aLastOsziData, cntr:=sAccessesOszi.uiDatalength1);    
  end_if;

END_FUNCTION


FUNCTION GLOBAL ST151Base::GetMeasureState
	VAR_INPUT
		pbTriggered 	: ^BOOL;(* := NIL *)
	END_VAR
	VAR_OUTPUT
		dRetCode 	: DINT;
	END_VAR
  
  //get data is busy
  dRetCode := 1;
    
  if pbTriggered <> NIL then
    pbTriggered^ := sAccessesOszi.sLastOsziState.StateOszi.Triggered;
  end_if; 
  
  if sAccessesOszi.bMeasureStarted = FALSE then    
    dRetCode := -1;
    return;    
  end_if;
  
  if sAccessesOszi.bDataReady then
    //data is available
    dRetCode := 0;
  end_if;

END_FUNCTION


FUNCTION GLOBAL ST151Base::GetActFreqLimits
	VAR_INPUT
		usValueIncDec 	: USINT;
		usArrayEntry 	: USINT;
		pusActCompMode 	: ^USINT;
	END_VAR
	VAR_OUTPUT
		udData 	: UDINT;
	END_VAR
  
  if usValueIncDec = 0 & usArrayEntry < ST151_MAXSTEPPING_MODES then
    udData := aFrequencyLimit[usArrayEntry].LimitIncrease;
  else
    udData := aFrequencyLimit[usArrayEntry].LimitDecrease;    
  end_if;
  
  pusActCompMode^ := usCompModeVST;
  
END_FUNCTION


FUNCTION ST151Base::CalcSimpleMode
  VAR
    siTempCnt : SINT;
    udTempDecreaseLimit : UDINT;
    pFrequLimitData : ^UDINT;
    pSDOFrequLimit  : ^UDINT;
  END_VAR
  
  pFrequLimitData := #FrequLimitDecrease32to64.dData;
  pSDOFrequLimit  := #sWriteSDO.SDOData5.FrequLimitFalling32to64;
  udTempDecreaseLimit := 0;
  for siTempCnt := ST151_MAXSTEPPING_MODES-1 to 0 by -1 do
    if ((EnableSteps shr siTempCnt+1) and 0x01) = TRUE then
      udTempDecreaseLimit := aFrequencyLimit[siTempCnt].LimitIncrease;
      if udTempDecreaseLimit > udLimitsHysteresis  then
        udTempDecreaseLimit -= udLimitsHysteresis;
      else
        udTempDecreaseLimit := 0;
      end_if;
    end_if;
    //check if step is activated and limit is set to automatically
    if pFrequLimitData^ = 0 
    & ((EnableSteps shr siTempCnt) and 0x01) = TRUE then
      aFrequencyLimit[siTempCnt].LimitDecrease := udTempDecreaseLimit;
    end_if;      
    pSDOFrequLimit^ := aFrequencyLimit[siTempCnt].LimitDecrease;
    pFrequLimitData -= sizeof(SvrCh);
    pSDOFrequLimit += sizeof(UDINT);
  end_for;
  //write sdo data again for decreasing limits
  biReqSDOConfigRdWr.WriteConfigSDO5 := TRUE;
  
END_FUNCTION


FUNCTION VIRTUAL GLOBAL ST151Base::ChopperOffTime::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

  if input < ST151_MIN_ALLOWED_CHOPPEROFFTIME then
    input := ST151_MIN_ALLOWED_CHOPPEROFFTIME;
  elsif input > ST151_MAX_ALLOWED_CHOPPEROFFTIME then
    input := ST151_MAX_ALLOWED_CHOPPEROFFTIME;
  end_if;

  ChopperOffTime := input;
  if ChopperOffTime <> sWriteSDO.SDOData1.ChopperOffTime then
    sWriteSDO.SDOData1.ChopperOffTime  := ChopperOffTime$UINT;
    biReqSDOConfigRdWr.WriteConfigSDO1 := TRUE;  
  end_if;
	result := ChopperOffTime;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL ST151Base::FastDecayTime::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR
  
  if input > ChopperOffTime then
    input := ChopperOffTime;
  elsif input < 0 then
    input := 0;
  end_if;

  FastDecayTime := input;
  if FastDecayTime <> sWriteSDO.SDOData1.FastDecayTime then
    sWriteSDO.SDOData1.FastDecayTime   := FastDecayTime$UINT;
    biReqSDOConfigRdWr.WriteConfigSDO1 := TRUE;  
  end_if;
	result := FastDecayTime;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL ST151Base::ChopperOnTimeMin::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

  if input > ST151_MAX_ALLOWED_CHOPPEROFFTIME then
    input := ST151_MAX_ALLOWED_CHOPPEROFFTIME;
  elsif input < 0 then
    input := 0;
  end_if;
  
  ChopperOnTimeMin := input;
  if ChopperOffTime <> sWriteSDO.SDOData5.ChopperOnTimeMin then
    sWriteSDO.SDOData5.ChopperOnTimeMin  := ChopperOnTimeMin$UINT;
    biReqSDOConfigRdWr.WriteConfigSDO5 := TRUE;  
  end_if;
	result := ChopperOnTimeMin;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL ST151Base::FastDecayTimeFallingStep::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR
  
  if input > ChopperOffTime then
    input := ChopperOffTime;
  elsif input < 0 then
    input := 0;
  end_if;

  FastDecayTimeFallingStep := input;
  if FastDecayTimeFallingStep <> sWriteSDO.SDOData5.FastDecayTimeFallingStep then
    sWriteSDO.SDOData5.FastDecayTimeFallingStep := FastDecayTimeFallingStep$UINT;
    biReqSDOConfigRdWr.WriteConfigSDO5 := TRUE;  
  end_if;
	result := FastDecayTimeFallingStep;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL ST151Base::MaxCurrent::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR
  VAR
  	uiTmpReducedCurrent : UINT;
  END_VAR

  //Check Limit
  if input < 0 then
    input := 0;
  elsif input > ST151_MAX_ALLOWED_CURRENT then
    input := ST151_MAX_ALLOWED_CURRENT;
  end_if;
  
	MaxCurrent := input;  
  uiTmpReducedCurrent := to_uint(MaxCurrent - ((MaxCurrent * StallCurrentReduction) / ST151_STALL_CURRENT_LIMIT));
  //check for changed values
  if MaxCurrent <> sWriteSDO.SDOData2.MaximumCurrentReg 
  | uiTmpReducedCurrent <> sWriteSDO.SDOData2.ReducedCurrentReg then
    sWriteSDO.SDOData2.MaximumCurrentReg := MaxCurrent$UINT;
    sWriteSDO.SDOData2.ReducedCurrentReg := uiTmpReducedCurrent;   
    biReqSDOConfigRdWr.WriteConfigSDO2 := TRUE;
  end_if;
	result := MaxCurrent;

END_FUNCTION

FUNCTION ST151Base::SetSDORdWrStep
	VAR_INPUT
		eActStep 	: t_e_SDOConfig;
	END_VAR
	VAR_OUTPUT
		eNextStep 	: t_e_SDOConfig;
	END_VAR
  VAR
  	biTmpActiveStep : t_bi_ReqSDOConfig;
  END_VAR
  
  case eActStep of
  	t_e_SDOConfig::_SDOConfig_Idle:   biTmpActiveStep := biReqSDOConfigRdWr;  
  	t_e_SDOConfig::_SDOConfig_Write1: biTmpActiveStep := biReqSDOConfigRdWr and 0xFFFE;
  	t_e_SDOConfig::_SDOConfig_Write2: biTmpActiveStep := biReqSDOConfigRdWr and 0xFFFC;
  	t_e_SDOConfig::_SDOConfig_Write3: biTmpActiveStep := biReqSDOConfigRdWr and 0xFFF8;
  	t_e_SDOConfig::_SDOConfig_Write4: biTmpActiveStep := biReqSDOConfigRdWr and 0xFFF0;
  	t_e_SDOConfig::_SDOConfig_Write5: biTmpActiveStep := biReqSDOConfigRdWr and 0xFFE0;
  	t_e_SDOConfig::_SDOConfig_Write6: biTmpActiveStep := biReqSDOConfigRdWr and 0xFFC0;
  	t_e_SDOConfig::_SDOConfig_Read1: biTmpActiveStep := biReqSDOConfigRdWr and 0xFE00;
  	t_e_SDOConfig::_SDOConfig_Read2: biTmpActiveStep := biReqSDOConfigRdWr and 0xFC00;
  	t_e_SDOConfig::_SDOConfig_Read3: biTmpActiveStep := biReqSDOConfigRdWr and 0xF800;
  	t_e_SDOConfig::_SDOConfig_Read4: biTmpActiveStep := biReqSDOConfigRdWr and 0xF000;
  	t_e_SDOConfig::_SDOConfig_Read5: biTmpActiveStep := biReqSDOConfigRdWr and 0xC000;
  	t_e_SDOConfig::_SDOConfig_Read6: biTmpActiveStep := biReqSDOConfigRdWr and 0xE000;
  	t_e_SDOConfig::_SDOConfig_Finished:
  	t_e_SDOConfig::_SDOConfig_Error:
  end_case;

  if biTmpActiveStep.WriteConfigSDO1 then
    eNextStep  := _SDOConfig_Write1;
  elsif biTmpActiveStep.WriteConfigSDO2 then
    eNextStep  := _SDOConfig_Write2;
  elsif biTmpActiveStep.WriteConfigSDO3 then
    eNextStep  := _SDOConfig_Write3;
  elsif biTmpActiveStep.WriteConfigSDO4 then
    eNextStep  := _SDOConfig_Write4;
  elsif biTmpActiveStep.WriteConfigSDO5 then
    eNextStep  := _SDOConfig_Write5;
  elsif biTmpActiveStep.WriteConfigSDO6 then
    eNextStep  := _SDOConfig_Write6;
  elsif biTmpActiveStep.ReadConfigSDO1 then
    eNextStep  := _SDOConfig_Read1;
  elsif biTmpActiveStep.ReadConfigSDO2 then
    eNextStep  := _SDOConfig_Read2;
  elsif biTmpActiveStep.ReadConfigSDO3 then
    eNextStep  := _SDOConfig_Read3;
  elsif biTmpActiveStep.ReadConfigSDO4 then
    eNextStep  := _SDOConfig_Read4;
  elsif biTmpActiveStep.ReadConfigSDO5 then
    eNextStep  := _SDOConfig_Read5;
  elsif biTmpActiveStep.ReadConfigSDO6 then
    eNextStep  := _SDOConfig_Read6;
  else
    eNextStep  := _SDOConfig_Finished; 
  end_if;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL ST151Base::CurrentOffsetAdjBridge1::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

  if input > ST151_CURRENTOFFSETADJUST_MAX then
    input := ST151_CURRENTOFFSETADJUST_MAX;
  elsif input < ST151_CURRENTOFFSETADJUST_MIN then
    input := ST151_CURRENTOFFSETADJUST_MIN;
  end_if;

  CurrentOffsetAdjBridge1 := input;
  if CurrentOffsetAdjBridge1 <> sWriteSDO.SDOData6.CurrentOffsetAdjBridge1 then
    sWriteSDO.SDOData6.CurrentOffsetAdjBridge1 := CurrentOffsetAdjBridge1$INT;
    biReqSDOConfigRdWr.WriteConfigSDO6 := TRUE;  
  end_if;
	result := CurrentOffsetAdjBridge1;  

END_FUNCTION


FUNCTION VIRTUAL GLOBAL ST151Base::CurrentOffsetAdjBridge2::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

  if input > ST151_CURRENTOFFSETADJUST_MAX then
    input := ST151_CURRENTOFFSETADJUST_MAX;
  elsif input < ST151_CURRENTOFFSETADJUST_MIN then
    input := ST151_CURRENTOFFSETADJUST_MIN;
  end_if;

  CurrentOffsetAdjBridge2 := input;
  if CurrentOffsetAdjBridge2 <> sWriteSDO.SDOData6.CurrentOffsetAdjBridge2 then
    sWriteSDO.SDOData6.CurrentOffsetAdjBridge2 := CurrentOffsetAdjBridge2$INT;
    biReqSDOConfigRdWr.WriteConfigSDO6 := TRUE;  
  end_if;
	result := CurrentOffsetAdjBridge2;
  
END_FUNCTION