//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)
//{{LSL_DECLARATION
#include "..\..\Class\_DriveMngBase\SDDDefinitions.h"

(*!
<Class
	Name               = "_DriveAxisSet"
	Revision           = "1.20"
	GUID               = "{EDF12091-F02E-45AF-90DB-21527D7AAE51}"
	RealtimeTask       = "false"
	CyclicTask         = "false"
	BackgroundTask     = "false"
	Sigmatek           = "true"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	IconPath           = ".\Class\_DriveMngBase\Drive.ico"
	SharedCommandTable = "true"
	Objectsize         = "(586,120)"
	Comment            = "internal class for the Drive&#13;&#10;(does the file- and parameterhandling)">
	<Channels>
		<Server Name="Server0" GUID="{818AD4D9-9CEC-4FC6-BD25-D4B3C1BBDE46}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Client Name="coLinker" Required="false" Internal="false" Comment="object channel to the class _Linker"/>
		<Client Name="coMerkerEx" Required="true" Internal="false" Comment="object channel to the class MerkerEx (local drive parameter)"/>
		<Client Name="coRamEx" Required="true" Internal="false" Comment="object channel to the class RamEx(drive parameter in the SRAM)"/>
		<Client Name="FileHandle" Required="false" Internal="false" Comment="command client to the class _DriveFileHandling&#13;&#10;The client has to be connected to use the RAMFILE for the drive parameters&#13;&#10;or to export the drive parameter into an excel formated file."/>
		<Client Name="OverwriteMotorPara" Required="false" Internal="false" DefValue="0" Comment="This client is just important for EnDat or Hiperface:&#13;&#10;&#13;&#10;0  .. no M-Parameter will be overwritten&#13;&#10;1  .. all M-Parameter except M-ROFF will be overwritten&#13;&#10;99 .. all M-Parameter will be overwritten"/>
		<Client Name="ParaSaveType" Required="false" Internal="false" Comment="Save/Use Type of the drive parameter handling :&#13;&#10;&#13;&#10;0.. User table &#13;&#10;The client ParaTab have to connected to an object of the class _DriveParaTab.&#13;&#10;Is no connection available, the default settings of the drive will be send.&#13;&#10;No parameter changes by an user will be saved.&#13;&#10;&#13;&#10;1.. Lasal2 table&#13;&#10;A Lasal2 table must be connected to a _DriveAxis Object, by selecting the _DriveAxis Object &#13;&#10;in the properties of the xml-File. (see _DriveAxis Documentation).&#13;&#10;Is the Lasal2 drive table not available, the system looks if an user table for the axis exists.(See ParaSaveType = 0)&#13;&#10;No parameter changes by an user will be saved.&#13;&#10;&#13;&#10;2.. drive parameter saved in the SRAM&#13;&#10;In this case the parameter will be saved in the SRAM. The first time of the system start-up, we get the drive parameters of the Lasal2 table.&#13;&#10;(See ParaSaveType = 1). At the second time of the system start-up,the parameters are loaded from the SRAM into the drive&#13;&#10;Any parameter changes by an user will be saved in the SRAM.&#13;&#10;&#13;&#10;3.. drive parameter saved in the RAMFILE&#13;&#10;In this case the parameter will be saved in a RAMFILE if the client cFileHandle is connected to the class _DriveFileHandling.&#13;&#10;This type can only used if a file system is available.&#13;&#10;The first time of the system start-up, we get the drive parameters of the Lasal2 table and save the parameter into the file.&#13;&#10;(See ParaSaveType = 1). At the second time of the system start-up,the parameters are loaded from the file into the drive&#13;&#10;Any parameter changes by an user will be saved in the file.&#13;&#10;&#13;&#10;"/>
		<Client Name="ParaTab" Required="false" Internal="false" Comment="client for connecting a _DriveParaTab"/>
		<Client Name="TableIndex" Required="false" Internal="false" Comment="With the value from this client, the specific Lasal2 Table is used for parameterizing the axis.&#13;&#10;(Only available for ParaSaveType = 1)"/>
	</Channels>
	<Dependencies>
		<Files>
			<File Path=".\Class\_DriveMngBase\SDDDefinitions.h" Include="true"/>
		</Files>
	</Dependencies>
	<RevDoku>
		<Owner Company="Sigmatek" Author="HasHan"/>
		<Dokumentation Revision="1.20" Date="06.03.2013" Author="RamAnd" Company="Sigmatek" Description="If a _DriveAxis has been placed in a complex network, the table name could not be generated since the last correction in the _DriveAxisSet class."/>
		<Dokumentation Revision="1.10" Date="05.11.2012" Author="ObeChr" Company="Sigmatek" Description="The Paramterfile for the axis can now be selected by index"/>
		<Dokumentation Revision="1.2" Date="10.02.2012" Author="ZoePat" Company="Sigmatek" Description="Added headerfile SDDDefinitions.h to prevent errors with projectversion V5"/>
		<Dokumentation Revision="1.1" Date="22.11.2010" Author="RamAnd" Company="Sigmatek" Description="Removed restriction for user tables. Now it&apos;s possible to use a table from user memory."/>
		<Dokumentation Revision="1.0" Date="05.08.2009" Author="HasHan" Company="Sigmatek" Description="Creation"/>
	</RevDoku>
</Class>
*)
_DriveAxisSet : CLASS
  //Servers:
	Server0 	: SvrChCmd_DINT;
  //Clients:
	ParaSaveType 	: CltCh_DINT;
	coMerkerEx 	: CltChCmd_MerkerEx;
	coRamEx 	: CltChCmd_RAMex;
	coLinker 	: CltChCmd__Linker;
	OverwriteMotorPara 	: CltCh_DINT;
	ParaTab 	: CltCh_DINT;
	FileHandle 	: CltChCmd_DINT;
	TableIndex 	: CltCh_UDINT;
  //Variables:
  //Functions:
	
	FUNCTION GLOBAL GetInitType
		VAR_OUTPUT
			InitType 	: DINT;
		END_VAR;
	
	FUNCTION GLOBAL GetUserTab
		VAR_INPUT
			bMotorPara 	: BOOL;
			pTabLength 	: ^DINT;
		END_VAR
		VAR_OUTPUT
			TabAddress 	: ^DINT;
		END_VAR;
	
	FUNCTION GLOBAL GetL2Tab
		VAR_INPUT
			pThis 	: ^void;
			bMotorPara 	: BOOL;
			pTabLength 	: ^DINT;
		END_VAR
		VAR_OUTPUT
			TabAddress 	: ^DINT;
		END_VAR;
	
	FUNCTION GetFnctName
		VAR_INPUT
			pFnctName 	: ^CHAR;
		END_VAR
		VAR_OUTPUT
			pFct 	: ^void;
		END_VAR;
	
	FUNCTION GLOBAL GetMemPtr
		VAR_OUTPUT
			pData 	: ^void;
		END_VAR;
	
	FUNCTION GLOBAL GetRamExLength
		VAR_OUTPUT
			udLength 	: UDINT;
		END_VAR;
	
	FUNCTION GLOBAL SaveRamExData
		VAR_INPUT
			pData 	: ^void;
			udLen 	: UDINT;
			udOffset 	: UDINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION GLOBAL CpyRamExMem
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION ChkL2TabVersion;
	
	FUNCTION GLOBAL ChkFileHandle
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION GLOBAL GetRamFileLen
		VAR_OUTPUT
			udLen 	: UDINT;
		END_VAR;
	
	FUNCTION GLOBAL SaveRamFileData
		VAR_INPUT
			pData 	: ^void;
			udLen 	: UDINT;
			udOffset 	: UDINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION GLOBAL CpyRamFileMem
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION RamFileSetSize
		VAR_INPUT
			udLen 	: UDINT;
		END_VAR
		VAR_OUTPUT
			ret_code 	: ConfStates;
		END_VAR;
	
	FUNCTION RamFileSetDataAt
		VAR_INPUT
			pData 	: ^USINT;
			udLen 	: UDINT;
			udOffset 	: UDINT;
		END_VAR;
	
	FUNCTION RamFileGetDataAt
		VAR_INPUT
			pData 	: ^USINT;
			udLen 	: UDINT;
			udOffset 	: UDINT;
		END_VAR;
	
	FUNCTION GLOBAL SetUserSSDCmd
		VAR_INPUT
			UserCmd 	: _SDDUSERCMD;
			pData 	: ^_DriveAxisBase::_SDDMEMHEADER;
		END_VAR;
	
	FUNCTION GLOBAL GetUserSSDCmd
		VAR_OUTPUT
			UserCmd 	: _SDDUSERCMD;
		END_VAR;
	
	FUNCTION GLOBAL GetFeedBackInfo
		VAR_OUTPUT
			GetFB 	: DINT;
		END_VAR;
	
	FUNCTION GLOBAL CalcCRC32
		VAR_INPUT
			pData 	: ^UDINT;
			udLen 	: UDINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: UDINT;
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

#pragma usingLtd _Linker
#pragma usingLtd MerkerEx
#pragma usingLtd RAMex


//}}LSL_DECLARATION


FUNCTION GLOBAL TAB _DriveAxisSet::@CT_
0$UINT,
2#0100000000000000$UINT, //TY__DRIVEAXISSET
1$UINT, 20$UINT, (SIZEOF(::_DriveAxisSet))$UINT, 
1$UINT, 8$UINT, 0$UINT, 
TO_UDINT(833307860), "_DriveAxisSet", //Class
TO_UDINT(0), 0, 0$UINT, 0$UINT, //Baseclass
//Servers:
(::_DriveAxisSet.Server0.pMeth)$UINT, _CH_CMD$UINT, 2#0000000000000000$UINT, TO_UDINT(2759080719), "Server0", 
//Clients:
(::_DriveAxisSet.ParaSaveType.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(3430860999), "ParaSaveType", 
(::_DriveAxisSet.coMerkerEx.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(1991140626), "coMerkerEx", TO_UDINT(2225119864), "MerkerEx", 1$UINT, 22$UINT, 
(::_DriveAxisSet.coRamEx.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(3875985349), "coRamEx", TO_UDINT(933570811), "RAMex", 1$UINT, 17$UINT, 
(::_DriveAxisSet.coLinker.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(1382361455), "coLinker", TO_UDINT(1793552568), "_Linker", 0$UINT, 4$UINT, 
(::_DriveAxisSet.OverwriteMotorPara.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(100162029), "OverwriteMotorPara", 
(::_DriveAxisSet.ParaTab.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(29594727), "ParaTab", 
(::_DriveAxisSet.FileHandle.pCh)$UINT, _CH_CLT_CMD$UINT, 2#0000000000000000$UINT, TO_UDINT(3131334989), "FileHandle", 
(::_DriveAxisSet.TableIndex.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(2619296494), "TableIndex", 
END_FUNCTION


#define USER_CNT__DriveAxisSet 0

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT__DriveAxisSet] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION _DriveAxisSet::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR

	ret_code := C_OK;

END_FUNCTION

//{{LSL_IMPLEMENTATION
FUNCTION GLOBAL _DriveAxisSet::GetInitType
	VAR_OUTPUT
		InitType 	: DINT;
	END_VAR
	
	InitType := ParaSaveType := ParaSaveType.read();

END_FUNCTION 


FUNCTION GLOBAL _DriveAxisSet::GetUserTab
	VAR_INPUT
		bMotorPara 	: BOOL;
		pTabLength 	: ^DINT;
	END_VAR
	VAR_OUTPUT
		TabAddress 	: ^DINT;
	END_VAR
  VAR
    NewOffset   : DINT;
    hTabAddress : ^DINT;
  END_VAR

	TabAddress := NIL;
	
		if IsClientConnected(#ParaTab) then
			TabAddress$DINT := ParaTab.read();
      if TabAddress <> NIL then
        if bMotorPara = TRUE then
          TabAddress += sizeof(UDINT) + sizeof(UDINT); // um die tatsächliche Länge der Daten zu bekommen
          pTabLength^ := TabAddress^;
          TabAddress += sizeof(UDINT);  // um die eigentlichen Daten zu bekommen
        else
          // get the address without the motorparameter
          NewOffset := (TabAddress + sizeof(UDINT) + sizeof(UDINT))^;
          hTabAddress := TabAddress + sizeof(UDINT) + SizeOf(UDINT) + SizeOf(UDINT) + NewOffset;
          hTabAddress += sizeof(UDINT); // die 4 Byte für die nächste Längenberechnung müssen dazuaddiert werden
          hTabAddress += sizeof(USINT) + sizeof(UDINT); // der nächste Eintrag ist der Offset für die Motorparameter
          hTabAddress += sizeof(USINT); // Länge für die Gruppennummer dazuaddieren
          NewOffset := hTabAddress^;
          
          // calculate the new length
          hTabAddress := TabAddress + sizeof(UDINT) + sizeof(UDINT);
          pTabLength^:= hTabAddress^ - (NewOffset - 3* sizeof(UDINT));
          // set the new address
          TabAddress += NewOffset;
        end_if;        
      end_if; 
		end_if;

END_FUNCTION


FUNCTION GLOBAL _DriveAxisSet::GetL2Tab
	VAR_INPUT
		pThis 	: ^void;
		bMotorPara 	: BOOL;
		pTabLength 	: ^DINT;
	END_VAR
	VAR_OUTPUT
		TabAddress 	: ^DINT;
	END_VAR
  VAR
    szTabName		: ARRAY[0..99] of CHAR;
    retcode     : BOOL;
    szObjName   : ARRAY[0..99] of CHAR;
    udStrLen    : UDINT;
    NewOffset   : DINT;
    hTabAddress : ^DINT;
    tmpDigits   : USINT;
    tmpLoop     : UDINT;
    x           : UDINT;
  END_VAR
  
  TabAddress := NIL;
  retcode := FALSE;
  
  if pThis <> NIL then
    
    // get the object name of the this pointer
    udStrLen := _GetObjName(pThis$^VirtualBase, #szObjName[0]);
    
    // convert the sign '/' to '_' in the object name (complex)
    if udStrLen > 0 then
    
      for x := 0 to (udStrLen - 1) do
        if szObjName[x] = '\' then
          szObjName[x] := '_';
        end_if;
      end_for;
    
      TableIndex := TableIndex.Read();

      //If only one Parameterfile is available, we don't need the extension for the index
      //****************************************************************************************************
      _strcpy(#szTabName[0], STDL2TABLENAME);
      _strcat(#szTabName[0], "_");
      _strcat(#szTabName[0], #szObjName[0]);
      
      //Get Pointer to Lasal2 Table
      TabAddress$pVoid := GetFnctName(#szTabName[0]);
      
      //Get table by selected index
      //****************************************************************************************************      
      if TabAddress = NIL then
      
        _strcpy(#szTabName[0], STDL2TABLENAME);
        _strcat(#szTabName[0], "_");
        _strcat(#szTabName[0], #szObjName[0]);
        _strcat(#szTabName[0], "_");
        
        //Get Digits of TableIndex
        tmpLoop   := TableIndex;
        tmpDigits := 0;
        
        //TableIndex <> 0
        if tmpLoop then
        
          while tmpLoop do
            tmpLoop  /= 10;
            tmpDigits     += 1;
          end_while;
          
          //Convert Number to String
          tmpLoop := TableIndex;
          
          szObjName[tmpDigits] := 0;
          tmpDigits -= 1;
          
          while tmpLoop do
            szObjName[tmpDigits] := ('0' + tmpLoop mod 10)$CHAR;
            tmpLoop   /= 10;
            tmpDigits -= 1;
          end_while;
          
          _strcat(#szTabName[0], #szObjName[0]);
        
        else
          _strcat(#szTabName[0], "0");
        end_if;
        
        //Get Pointer to Lasal2 Table
        TabAddress$pVoid := GetFnctName(#szTabName[0]);
      
      end_if;

      if TabAddress <> NIL then
        // *****************************
        // now get the parameter data
        // *****************************
        // add the whole length of the table and the version number of the table to the address
        //check the version
        ChkL2TabVersion();
        if bMotorPara = TRUE then
          TabAddress += sizeof(UDINT) + sizeof(UDINT); // um die tatsächliche Länge der Daten zu bekommen
          pTabLength^ := TabAddress^;
          TabAddress += sizeof(UDINT);  // um die eigentlichen Daten zu bekommen
        else
          // get the address without the motorparameter
          NewOffset := (TabAddress + sizeof(UDINT) + sizeof(UDINT))^;
          hTabAddress := TabAddress + sizeof(UDINT) + SizeOf(UDINT) + SizeOf(UDINT) + NewOffset;
          hTabAddress += sizeof(UDINT); // die 4 Byte für die nächste Längenberechnung müssen dazuaddiert werden
          hTabAddress += sizeof(USINT) + sizeof(UDINT); // der nächste Eintrag ist der Offset für die Motorparameter
          hTabAddress += sizeof(USINT); // Länge für die Gruppennummer dazuaddieren
          NewOffset := hTabAddress^;
          
          // calculate the new length
          hTabAddress := TabAddress + sizeof(UDINT) + sizeof(UDINT);
          pTabLength^:= hTabAddress^ - (NewOffset - 3* sizeof(UDINT));
          // set the new address
          TabAddress += NewOffset;
        end_if;
      end_if;

    end_if; 
    
  end_if;

END_FUNCTION //GLOBAL SDDSettings::GetL2Tab
//[#ENGLISH]
// *************************************************************************
//                BIN to ASCII converter
//  The input variables of this function have to be a
//  pointer  on a  Char-String, the value you want to convert(DINT)
//  and a scheme(BINT). In the scheme you must define the number
//	of digits to convert, the position of the decimal point,
//	hasty zeros or not and if the descendant zeros should be
//	deleted or not.
//
//	-------------scheme------------------------------
//
//       xxxx xx00 0000 0000
//       .... .... .... ****	no. of digits
//       .... .... **** ....    pos. of decimal point (from lowest sign.)
//       .... ...* .... ....    reminding digits fill with hasty zeros
//		 .... ..*. .... ....	delete descendant zeros
//
//
// 		  16#0224$BINT
//   		  |||........   no. of digits
//   		  ||.........   pos. of decimal point
//    		  |..........   0 without hasty zeros
//                    		1 with hasty zeros
//                   		2 delete descendant zeros (the
//							  digits have to be the real number
//							  of digits, without the deleted
//							  zeros! f.e.: 
//							  12.900 => 12.9 that means 3 digits!)
//
//
//	If an error occures during the conversion, the first CHAR in
//	your string will be set to '?' (this f.e. could be the result
// 	of a wrong number of digits). The status of all other CHAR in
//	the String is undefined!
//
//
//[>pt]pointer at CHAR-String
//[>value]value to convert
//[>format]scheme for the conversion
//
//[#DEUTSCH]
// *************************************************************************
//                BIN to ASCII Konverter
//  
// 	Übergeben Sie der Funktion einen Pointer auf ein CHAR-Feld, die
//	Zahl die in ASCII gewandelt werden soll (vom Typ DINT) und das
//	Format nach welchem die Zahl gewandelt wird. Im Format muss
//	folgendes angegeben werden: die Anzahl der Stellen, die 
// 	Position des Kommas, ob Vornullen verwendet werden und ob 
//	Nachnullen gelöscht werden sollen. 
//
//	-------------Format------------------------------
//
//       xxxx xx00 0000 0000
//       .... .... .... ****	Anz. der Stellen
//       .... .... **** ....    pos. des Komma (von hinten)
//       .... ...* .... ....    restlichen Stellen mit Vornullen auffüllen
//		 .... ..*. .... ....	Nachnullen löschen
//
//
// 		  16#0224$BINT
//   		  |||........   Anz. der Stellen
//   		  ||.........   pos. des Komma (von hinten)
//    		  |..........   0 ohne Vornullen
//                    		1 mit Vornullen auffüllen
//                   		2 Nachnullen löschen (die Anz. der
//							  Stellen muss genau der Anz. der
//							  Gewandelten entsprechen, ohne 
//							  Nachnullen! z.B.:
//							  12.900 => 12.9 d.h. 3 Stellen!)		
//
//	Wenn bei der Wandlung ein Fehler aufgetreten ist, wir das 
//	erste Zeichen im CHAR-String auf '?' gesetzt (könnte z.B.
//  durch eine falsche Anzahl Stellen auftreten). Alle Anderen
//	haben einen nicht definierten Zustand!
//
//

// xxxx 0000 0000 0000 format
//      .... .... **** no of digits
//      .... **** .... position decimalpoint
//      ...* .... .... preceding zeros
//      ..*. .... .... descendant zeros
//      .*.. .... .... vorzeichen unmittelbar vor wert (-3 ansonsten -  3)
//      *... .... .... anzahl der stellen automatisch ermitteln

//[>pt]Pointer auf CHAR-String
//[>value]zu konvertierende Zahl
//[>format]das Format
 //GLOBAL SDDSettings::Bin2Ascii


FUNCTION _DriveAxisSet::GetFnctName
	VAR_INPUT
		pFnctName 	: ^CHAR;
	END_VAR
	VAR_OUTPUT
		pFct 	: ^void;
	END_VAR
VAR	
	isExe			: Char;
END_VAR
	
	pFct$UDINT := coLinker.GetAddressFunction(pFnctName, (#IsExe)$^CHAR);

END_FUNCTION


FUNCTION GLOBAL _DriveAxisSet::GetMemPtr
	VAR_OUTPUT
		pData 	: ^void;
	END_VAR
	
	if coMerkerEx.GetSize() <> SDDMAXMEM then
		coMerkerEx.SetSize(SDDMAXMEM);
	end_if;

	pData := coMerkerEx.GetDataPtr();

END_FUNCTION


FUNCTION GLOBAL _DriveAxisSet::GetRamExLength
	VAR_OUTPUT
		udLength 	: UDINT;
	END_VAR
	
	udLength := coRamEx.read();

END_FUNCTION


FUNCTION GLOBAL _DriveAxisSet::SaveRamExData
	VAR_INPUT
		pData 	: ^void;
		udLen 	: UDINT;
		udOffset 	: UDINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: BOOL;
	END_VAR
VAR
	udActLen		: UDINT;
  ret_code    : ConfStates;
END_VAR

	udActLen := coRamEx.Read();
  retcode := TRUE;
  
  if udActLen < (udLen + udOffset) then
    if udLen + udOffset > SDDMAXMEM then
      // ERROR
      Trace("SDDManager :: maximal memory for the parameters reached!!");
      retcode := FALSE;
      return;
    end_if;
    ret_code := coRamEx.SetSize(udLen + udOffset);
    if ret_code <> C_OK then
      retcode := FALSE;
    end_if;
	end_if;
  
  if retcode = TRUE then
  		coRamEx.SetDataAt(pData$^USINT, udLen, udOffset);
  end_if;
  
END_FUNCTION


FUNCTION GLOBAL _DriveAxisSet::CpyRamExMem
	VAR_OUTPUT
		retcode 	: BOOL;
	END_VAR	
VAR
	udLen	 : UDINT;
	pData		: ^USINT;
END_VAR
	retcode := FALSE;

	// copy data from RAMEX to MEMORY
	udLen := GetRamExLength();
	if udLen > SDDMAXMEM then
		coMerkerEx.SetSize(udLen);
	end_if;
	pData := coRamEx.GetDataPtr();
	if pData <> NIL then
		coMerkerEx.SetDataAt(pData, udLen, 0);
		retcode := TRUE;
	end_if;

END_FUNCTION


FUNCTION _DriveAxisSet::ChkL2TabVersion
   
   // not used at the  moment
   
END_FUNCTION


FUNCTION GLOBAL _DriveAxisSet::ChkFileHandle
	VAR_OUTPUT
		retcode 	: BOOL;
	END_VAR
  VAR
    UserCmdStruct : CmdStruct;
    UserResult    : Results;
  END_VAR
  
  retcode := FALSE;
  
  if IsClientConnected(#FileHandle) then
    // check if the right class is connected
    UserCmdStruct.uiCmd := 199;
    _memset(#UserResult, 16#00, sizeof(Results));
    FileHandle.NewInst(#UserCmdStruct, #UserResult);
    if UserResult.aData[2] = 16#FE then
      retcode := TRUE;
    end_if;
    
  end_if;
  
END_FUNCTION


FUNCTION GLOBAL _DriveAxisSet::GetRamFileLen
	VAR_OUTPUT
		udLen 	: UDINT;
	END_VAR
  VAR
    UserCmdStruct   : CmdStruct;
    UserResults     : Results;
  END_VAR
  
  _memset(#UserResults, 16#00, sizeof(Results));
  // get the actual length of the ramfile
  UserCmdStruct.uiCmd := 0;
  FileHandle.NewInst(#UserCmdStruct, #UserResults);
  udLen := UserResults.aData[0]$UDINT;
  
END_FUNCTION


FUNCTION GLOBAL _DriveAxisSet::SaveRamFileData
	VAR_INPUT
		pData 	: ^void;
		udLen 	: UDINT;
		udOffset 	: UDINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: BOOL;
	END_VAR
  VAR
    udActLen		: UDINT;
    ret_code    : ConfStates;
  END_VAR

	udActLen := GetRamFileLen();
  retcode := TRUE;
  
  if udActLen < (udLen + udOffset) then
    if udLen + udOffset > SDDMAXMEM then
      // ERROR
      Trace("SDDManager :: maximal memory for the parameters reached!!");
      retcode := FALSE;
      return;
    end_if;
    ret_code := RamFileSetSize(udLen + udOffset);
    if ret_code <> C_OK then
      retcode := FALSE;
    end_if;
	end_if;
  
  if retcode = TRUE then
    RamFileSetDataAt(pData$^USINT, udLen, udOffset);
  end_if;

END_FUNCTION


FUNCTION GLOBAL _DriveAxisSet::CpyRamFileMem
	VAR_OUTPUT
		retcode 	: BOOL;
	END_VAR	
  VAR
    udLen	 : UDINT;
    pData		: ^USINT;
  END_VAR

	retcode := FALSE;

	// copy data from RAMFILE to MEMORY
	udLen := GetRamFileLen();
	if udLen > SDDMAXMEM then
		coMerkerEx.SetSize(udLen);
	end_if;
	
  pData := coMerkerEx.GetDataPtr();
	if pData <> NIL then
    RamfileGetDataAt(pData, udLen, 0);
		retcode := TRUE;
	end_if;

END_FUNCTION


FUNCTION _DriveAxisSet::RamFileSetSize
	VAR_INPUT
		udLen 	: UDINT;
	END_VAR
	VAR_OUTPUT
		ret_code 	: ConfStates;
	END_VAR
  VAR
    UserCmdStruct   : CmdStruct;
    UserResults     : Results;
  END_VAR
  
  _memset(#UserResults, 16#00, sizeof(Results));
  // set the size of the ramfile
  UserCmdStruct.uiCmd := 1;
  UserCmdStruct.aPara[0] := udLen$DINT;
  
  FileHandle.NewInst(#UserCmdStruct, #UserResults);
  
  ret_code := UserResults.aData[0]$ConfStates;
  
END_FUNCTION


FUNCTION _DriveAxisSet::RamFileSetDataAt
	VAR_INPUT
		pData 	: ^USINT;
		udLen 	: UDINT;
		udOffset 	: UDINT;
	END_VAR
  VAR
    UserCmdStruct   : CmdStruct;
    UserResults     : Results;
  END_VAR
  
  _memset(#UserResults, 16#00, sizeof(Results));
  // set the data into the ramfile
  UserCmdStruct.uiCmd := 2;
  UserCmdStruct.aPara[0] := pData$DINT;
  UserCmdStruct.aPara[1] := udLen$DINT;
  UserCmdStruct.aPara[2] := udOffset$DINT;
  
  FileHandle.NewInst(#UserCmdStruct, #UserResults);
  
END_FUNCTION


FUNCTION _DriveAxisSet::RamFileGetDataAt
	VAR_INPUT
		pData 	: ^USINT;
		udLen 	: UDINT;
		udOffset 	: UDINT;
	END_VAR
  VAR
    UserCmdStruct   : CmdStruct;
    UserResults     : Results;
  END_VAR
  
  _memset(#UserResults, 16#00, sizeof(Results));
  // get the data into the ramfile
  UserCmdStruct.uiCmd := 3;
  UserCmdStruct.aPara[0] := pData$DINT;
  UserCmdStruct.aPara[1] := udLen$DINT;
  UserCmdStruct.aPara[2] := udOffset$DINT;
  
  FileHandle.NewInst(#UserCmdStruct, #UserResults);
  
END_FUNCTION



FUNCTION GLOBAL _DriveAxisSet::SetUserSSDCmd
	VAR_INPUT
		UserCmd 	: _SDDUSERCMD;
		pData 	: ^_DriveAxisBase::_SDDMEMHEADER;
	END_VAR
  VAR
    UserCmdStruct   : CmdStruct;
    UserResults     : Results;
  END_VAR
  
  _memset(#UserResults, 16#00, sizeof(Results));
  // Set the user command to the file handler
  UserCmdStruct.uiCmd := 4;
  UserCmdStruct.aPara[0] := UserCmd$DINT;
  UserCmdStruct.aPara[1] := pData$DINT;
  
  FileHandle.NewInst(#UserCmdStruct, #UserResults);

END_FUNCTION


FUNCTION GLOBAL _DriveAxisSet::GetUserSSDCmd
	VAR_OUTPUT
		UserCmd 	: _SDDUSERCMD;
	END_VAR
  VAR
    UserCmdStruct   : CmdStruct;
    UserResults     : Results;
  END_VAR
  
  _memset(#UserResults, 16#00, sizeof(Results));
  // Set the user command to the file handler
  UserCmdStruct.uiCmd := 5;
  
  FileHandle.NewInst(#UserCmdStruct, #UserResults);
  
  UserCmd := UserResults.aData[0]$_SDDUSERCMD;

END_FUNCTION


FUNCTION GLOBAL _DriveAxisSet::GetFeedBackInfo
	VAR_OUTPUT
		GetFB 	: DINT;
	END_VAR
  
  GetFB := OverwriteMotorPara := OverwriteMotorPara.read();

END_FUNCTION


FUNCTION GLOBAL _DriveAxisSet::CalcCRC32
	VAR_INPUT
		pData 	: ^UDINT;
		udLen 	: UDINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: UDINT;
	END_VAR
  
  retcode := coLinker.CRC32(crc:=0, buf:=pData$^void, length:=udLen);

END_FUNCTION
