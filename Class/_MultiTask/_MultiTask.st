//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)
//{{LSL_DECLARATION

(*!
<Class
	Name               = "_MultiTask"
	Revision           = "1.1"
	GUID               = "{F4B8A4A1-72EF-11D6-83FE-000374890932}"
	RealtimeTask       = "false"
	CyclicTask         = "false"
	BackgroundTask     = "false"
	Sigmatek           = "true"
	OSInterface        = "true"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	SharedCommandTable = "true"
	Objectsize         = "(284,120)"
	Comment            = "For a detailed description of Multitasking, Semaphore- and Mailbox-Handling and some examples have a look at the documentation &apos;LASAL OS API Multitask.doc&apos;.">
	<Channels>
		<Server Name="Server0" GUID="{F4B8A4A2-72EF-11D6-83FE-000374890932}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false"/>
	</Channels>
	<Dependencies>
		<Files>
			<File Path=".\Source\code\OsiBaseNew.st"/>
			<File Path=".\Source\code\OsiBaseNew.h" Include="false"/>
			<File Path=".\MultiTaskTypes.h" Include="false"/>
		</Files>
	</Dependencies>
	<RevDoku>
		<Owner Company="Sigmatek GmbH &amp; Co KG" Author="strgue"/>
		<Dokumentation Revision="1.1" Date="2015-10-22" Author="strgue" Company="Sigmatek GmbH &amp; Co KG" Description="Function MT_DelayUS added"/>
	</RevDoku>
</Class>
*)
_MultiTask : CLASS
	TYPE
	  LSL_MT_TYPE : STRUCT  //! <Type Comment="MultiTask API List" Name="LSL_MT_TYPE"/>
	    version : UDINT;
	    GetLastError : pVoid;
	    GetTime : pVoid;
	    CreateThread : pVoid;
	    TerminateTask : pVoid;
	    Suspend : pVoid;
	    Resume : pVoid;
	    CurrentTaskHandle : pVoid;
	    GetTaskState : pVoid;
	    SetPriority : pVoid;
	    GetTaskPrio : pVoid;
	    GetTaskStack : pVoid;
	    GetMinStack : pVoid;
	    _Delay : pVoid;
	    DelayUntil : pVoid;
	    Send : pVoid;
	    SendCond : pVoid;
	    SendTimed : pVoid;
	    Receive : pVoid;
	    ReceiveCond : pVoid;
	    ReceiveTimed : pVoid;
	    CreateSemaphore : pVoid;
	    DeleteSemaphore : pVoid;
	    SemaValue : pVoid;
	    ResourceOwner : pVoid;
	    Signal : pVoid;
	    Pulse : pVoid;
	    Wait : pVoid;
	    WaitCond : pVoid;
	    WaitTimed : pVoid;
	    ResetEvent : pVoid;
	    CreateMailbox : pVoid;
	    DeleteMailbox : pVoid;
	    ClearMailbox : pVoid;
	    Messages : pVoid;
	    Put : pVoid;
	    PutFront : pVoid;
	    Get : pVoid;
	    PutCond : pVoid;
	    PutFrontCond : pVoid;
	    GetCond : pVoid;
	    NextCond : pVoid;
	    PutTimed : pVoid;
	    PutFrontTimed : pVoid;
	    GetTimed : pVoid;
	    GetTaskPrioByID : pVoid;
	    DelayUS : pVoid;
	  END_STRUCT;
	END_TYPE
  //Servers:
	Server0 	: SvrChCmd_DINT;
  //Clients:
  //Variables:
  //Functions:
	
	FUNCTION _MultiTask
		VAR_OUTPUT
			ret_code 	: ConfStates;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL GETVERSION;
				//! <Function Comment="Returns last error code.&#10;&#10;Following codes are implemented: &#10;* MTERROR_NONE &#10;* MTERROR_NOMEM &#10;* MTERROR_NOFCT &#10;* MTERROR_FCTNOTINMEM &#10;* MTERROR_WRONGPRIOR &#10;* MTERROR_STACK &#10;* MTERROR_NAME &#10;* MTERROR_NAMEUSED &#10;* MTERROR_HANDLE &#10;* MTERROR_NOTALLOWED &#10;* MTERROR_MESSAGESIZE &#10;* MTERROR_DATA &#10;* MTERROR_PTR &#10;* MTERROR_TASKID &#10;* MTERROR_NOTASK &#10;* MTERROR_NOIFFNC. &#10;&#10;For more details please read the OS Interface (-&gt; b_MulitTask class -&gt; GETLASTERROR) documentation!" Name="GETLASTERROR"/>
	FUNCTION __CDECL VIRTUAL GLOBAL GETLASTERROR
		VAR_OUTPUT
			ret0 (EAX) 	: DINT;			//! <Variable Comment="Is the last error code." Name="GETLASTERROR.ret0"/>
		END_VAR;
				//! <Function Comment="Can be used to read LASAL-OS Kernel clock." Name="GETTIME"/>
	FUNCTION __CDECL VIRTUAL GLOBAL GETTIME
		VAR_OUTPUT
			ret0 (EAX) 	: UDINT;			//! <Variable Comment="Is the current time of LASAL-OS internal Kernel clock in milliseconds." Name="GETTIME.ret0"/>
		END_VAR;
				//! <Function Comment="Any task in a program can create other tasks using this function." Name="CREATETHREAD"/>
	FUNCTION __CDECL VIRTUAL GLOBAL CREATETHREAD
		VAR_INPUT
			taskfunction0 	: pVoid;			//! <Variable Comment="A Lasal function with __cdecl or Lasal Class calling conventions and a single pVoid parameter. It contains the code to be executed by the new task." Name="CREATETHREAD.taskfunction0"/>
			priority0 	: UDINT;			//! <Variable Comment="The base priority of the new task as an integer between MT_MIN_PRIORITY (1) and MT_MAX_PRIORITY (64)." Name="CREATETHREAD.priority0"/>
			stackSize0 	: UDINT;			//! <Variable Comment="The net stack required by the new task (in bytes)." Name="CREATETHREAD.stackSize0"/>
			flags0 	: UDINT;			//! <Variable Comment="Can be used to select options for the new task.&#10;&#10;The following values for parameter flags0 are currently defined: &#10;* MT_TASK_SUSPENDED &#10;* MT_TASK_MATH_CONTEXT &#10;* MT_TASK_NO_MATH_CONTEXT &#10;* MT_TASK_SAVETHIS &#10;&#10;For more details please read the OS Interface (-&gt; _MultiTask class -&gt;CREATETHREAD) documentation!" Name="CREATETHREAD.flags0"/>
			parameter0 	: pVoid;			//! <Variable Comment="Parameter passed to the task&apos;s function." Name="CREATETHREAD.parameter0"/>
			name0 	: ^CHAR;			//! <Variable Comment="Pointer to the name of the task." Name="CREATETHREAD.name0"/>
		END_VAR
		VAR_OUTPUT
			ret0 (EAX) 	: MT_TASKHANDLE;			//! <Variable Comment="LASAL MT task handle (MT_TASKHANDLE). It is a reference to the newly created task." Name="CREATETHREAD.ret0"/>
		END_VAR;
				//! <Function Comment="Terminates a task." Name="TERMINATETASK"/>
	FUNCTION __CDECL VIRTUAL GLOBAL TERMINATETASK
		VAR_INPUT
			handle0 	: MT_TASKHANDLE;			//! <Variable Comment="A pointer to a task handle identifying the task to be terminated." Name="TERMINATETASK.handle0"/>
		END_VAR
		VAR_OUTPUT
			ret0 (EAX) 	: DINT;			//! <Variable Comment="MTERROR_NONE if no error occurred or an error code." Name="TERMINATETASK.ret0"/>
		END_VAR;
				//! <Function Comment="Can be used to deactivate a task." Name="SUSPEND"/>
	FUNCTION __CDECL VIRTUAL GLOBAL SUSPEND
		VAR_INPUT
			handle0 	: MT_TASKHANDLE;			//! <Variable Comment="References the task to deactivate." Name="SUSPEND.handle0"/>
		END_VAR
		VAR_OUTPUT
			ret0 (EAX) 	: DINT;			//! <Variable Comment="MTERROR_NONE if no error occurred or an error code." Name="SUSPEND.ret0"/>
		END_VAR;
				//! <Function Comment="Reactivates a suspended task." Name="RESUME"/>
	FUNCTION __CDECL VIRTUAL GLOBAL RESUME
		VAR_INPUT
			handle0 	: MT_TASKHANDLE;			//! <Variable Comment="References the task to reactivate." Name="RESUME.handle0"/>
		END_VAR
		VAR_OUTPUT
			ret0 (EAX) 	: DINT;			//! <Variable Comment="MTERROR_NONE if no error occurred or an error code." Name="RESUME.ret0"/>
		END_VAR;
				//! <Function Comment="Returns the handle of the currently running task." Name="CURRENTTASKHANDLE"/>
	FUNCTION __CDECL VIRTUAL GLOBAL CURRENTTASKHANDLE
		VAR_OUTPUT
			ret0 (EAX) 	: MT_TASKHANDLE;			//! <Variable Comment="The handle of the currently running task or NULL if function is called in LASAL TASK level: RTWork, CyWork, etc..." Name="CURRENTTASKHANDLE.ret0"/>
		END_VAR;
				//! <Function Comment="Returns the current state of a task.&#10;&#10;One of the following values can be returned:&#10;* MTASKSTATE_READY &#10;* MTASKSTATE_CURRENT &#10;* MTASKSTATE_SUSPENDED &#10;* MTASKSTATE_DELAYING &#10;* MTASKSTATE_BLOCKED_WAIT &#10;* MTASKSTATE_TIMED_WAIT &#10;* MTASKSTATE_BLOCKED_PUT &#10;* MTASKSTATE_BLOCKED_GET &#10;* MTASKSTATE_TIMED_PUT &#10;* MTASKSTATE_TIMED_GET &#10;* MTASKSTATE_BLOCKED_SEND &#10;* MTASKSTATE_BLOCKED_RECEIVE &#10;* MTASKSTATE_TIMED_SEND &#10;* MTASKSTATE_TIMED_RECEIVE &#10;* MTASKSTATE_DEADLOCKED &#10;* MTASKSTATE_ILLEGAL &#10;* MTASKSTATE_TERMINATED &#10;&#10;For more details please read the OS Interface (-&gt; _MultiTask class -&gt; GETTASKSTATE) documentation!" Name="GETTASKSTATE"/>
	FUNCTION __CDECL VIRTUAL GLOBAL GETTASKSTATE
		VAR_INPUT
			handle0 	: MT_TASKHANDLE;
		END_VAR
		VAR_OUTPUT
			ret0 (EAX) 	: LSL_MT_TASKSTATE;			//! <Variable Comment="Is of enumeration type LSL_MT_TASKSTATE." Name="GETTASKSTATE.ret0"/>
		END_VAR;
				//! <Function Comment="Change a task&apos;s priority." Name="SETPRIORITY"/>
	FUNCTION __CDECL VIRTUAL GLOBAL SETPRIORITY
		VAR_INPUT
			handle0 	: MT_TASKHANDLE;			//! <Variable Comment="References the task whose priority to change." Name="SETPRIORITY.handle0"/>
			priority0 	: UDINT;			//! <Variable Comment="The new base priority of the task." Name="SETPRIORITY.priority0"/>
		END_VAR
		VAR_OUTPUT
			ret0 (EAX) 	: DINT;			//! <Variable Comment="MTERROR_NONE if no error occurred or an error code." Name="SETPRIORITY.ret0"/>
		END_VAR;
				//! <Function Comment="Returns the current execution priority of a task." Name="GETTASKPRIO"/>
	FUNCTION __CDECL VIRTUAL GLOBAL GETTASKPRIO
		VAR_INPUT
			handle0 	: MT_TASKHANDLE;			//! <Variable Comment="References the task whose priority to enquire." Name="GETTASKPRIO.handle0"/>
		END_VAR
		VAR_OUTPUT
			ret0 (EAX) 	: UDINT;			//! <Variable Comment="Between MIN_PRIOR and MAX_PRIOR if no error or -1 if an error occurred." Name="GETTASKPRIO.ret0"/>
		END_VAR;
				//! <Function Comment="Returns the remaining free stack space of a task." Name="GETTASKSTACK"/>
	FUNCTION __CDECL VIRTUAL GLOBAL GETTASKSTACK
		VAR_INPUT
			handle0 	: MT_TASKHANDLE;			//! <Variable Comment="References the task whose stack to enquire." Name="GETTASKSTACK.handle0"/>
		END_VAR
		VAR_OUTPUT
			ret0 (EAX) 	: UDINT;			//! <Variable Comment="The free stack space or -1 if an error occurred." Name="GETTASKSTACK.ret0"/>
		END_VAR;
				//! <Function Comment="Returns the least number of bytes that has been free on a task&apos;s stack since it was created." Name="GETMINSTACK"/>
	FUNCTION __CDECL VIRTUAL GLOBAL GETMINSTACK
		VAR_INPUT
			handle0 	: MT_TASKHANDLE;			//! <Variable Comment="References the task whose stack to enquire." Name="GETMINSTACK.handle0"/>
		END_VAR
		VAR_OUTPUT
			ret0 (EAX) 	: UDINT;			//! <Variable Comment="The minimum free stack space or -1 if an error occurred." Name="GETMINSTACK.ret0"/>
		END_VAR;
				//! <Function Comment="Blocks the calling task for the specified time span and allows other tasks to run." Name="TASKDELAY"/>
	FUNCTION __CDECL VIRTUAL GLOBAL TASKDELAY
		VAR_INPUT
			timeout0 	: UDINT;			//! <Variable Comment="Specifies the time in milliseconds, the task must be blocked." Name="TASKDELAY.timeout0"/>
		END_VAR
		VAR_OUTPUT
			ret0 (EAX) 	: DINT;			//! <Variable Comment="MTERROR_NONE if no error occurred or an error code." Name="TASKDELAY.ret0"/>
		END_VAR;
				//! <Function Comment="Tasks that want to continue running at a certain time can use DELAYUNTIL." Name="DELAYUNTIL"/>
	FUNCTION __CDECL VIRTUAL GLOBAL DELAYUNTIL
		VAR_INPUT
			timeout0 	: UDINT;			//! <Variable Comment="Specifies the time in milliseconds for the task to continue." Name="DELAYUNTIL.timeout0"/>
		END_VAR
		VAR_OUTPUT
			ret0 (EAX) 	: DINT;			//! <Variable Comment="MTERROR_NONE if no error occurred or an error code." Name="DELAYUNTIL.ret0"/>
		END_VAR;
				//! <Function Comment="Sends data to another task." Name="SEND"/>
	FUNCTION __CDECL VIRTUAL GLOBAL SEND
		VAR_INPUT
			handle0 	: MT_TASKHANDLE;			//! <Variable Comment="The handle of the task to receive the data." Name="SEND.handle0"/>
			data0 	: pVoid;			//! <Variable Comment="Points to the data to send." Name="SEND.data0"/>
		END_VAR
		VAR_OUTPUT
			ret0 (EAX) 	: DINT;			//! <Variable Comment="MTERROR_NONE if no error occurred or an error code." Name="SEND.ret0"/>
		END_VAR;
				//! <Function Comment="Sends data to another task." Name="SENDCOND"/>
	FUNCTION __CDECL VIRTUAL GLOBAL SENDCOND
		VAR_INPUT
			handle0 	: MT_TASKHANDLE;			//! <Variable Comment="The handle of the receiving task." Name="SENDCOND.handle0"/>
			data0 	: pVoid;			//! <Variable Comment="Points to the data to send." Name="SENDCOND.data0"/>
		END_VAR
		VAR_OUTPUT
			ret0 (EAX) 	: DINT;			//! <Variable Comment="TRUE if the data transfer has been successfully completed, otherwise an error code." Name="SENDCOND.ret0"/>
		END_VAR;
				//! <Function Comment="Sends data to another task." Name="SENDTIMED"/>
	FUNCTION __CDECL VIRTUAL GLOBAL SENDTIMED
		VAR_INPUT
			handle0 	: MT_TASKHANDLE;			//! <Variable Comment="The handle of the receiving task." Name="SENDTIMED.handle0"/>
			data0 	: pVoid;			//! <Variable Comment="Points to the data to send." Name="SENDTIMED.data0"/>
			timeout0 	: UDINT;			//! <Variable Comment="Timeout for waiting until the receiving task becomes ready to accept data (in milliseconds)." Name="SENDTIMED.timeout0"/>
		END_VAR
		VAR_OUTPUT
			ret0 (EAX) 	: DINT;			//! <Variable Comment="TRUE if the data transfer has been successfully completed, otherwise an error code." Name="SENDTIMED.ret0"/>
		END_VAR;
				//! <Function Comment="Receives data from any other task." Name="RECEIVE"/>
	FUNCTION __CDECL VIRTUAL GLOBAL RECEIVE
		VAR_INPUT
			data0 	: pVoid;			//! <Variable Comment="Points to the variable to store the received data in." Name="RECEIVE.data0"/>
			datalengt0 	: UDINT;			//! <Variable Comment="The length of the expected data." Name="RECEIVE.datalengt0"/>
		END_VAR
		VAR_OUTPUT
			ret0 (EAX) 	: DINT;			//! <Variable Comment="MTERROR_NONE if no error occurred or an error code." Name="RECEIVE.ret0"/>
		END_VAR;
				//! <Function Comment="Receives data from any task." Name="RECEIVECOND"/>
	FUNCTION __CDECL VIRTUAL GLOBAL RECEIVECOND
		VAR_INPUT
			data0 	: pVoid;			//! <Variable Comment="Points to the variable to store the received data in." Name="RECEIVECOND.data0"/>
			datalengt0 	: UDINT;			//! <Variable Comment="The length of the expected data." Name="RECEIVECOND.datalengt0"/>
		END_VAR
		VAR_OUTPUT
			ret0 (EAX) 	: DINT;			//! <Variable Comment="TRUE if the data transfer has been successfully completed, otherwise an error code." Name="RECEIVECOND.ret0"/>
		END_VAR;
				//! <Function Comment="Receives data from any task." Name="RECEIVETIMED"/>
	FUNCTION __CDECL VIRTUAL GLOBAL RECEIVETIMED
		VAR_INPUT
			data0 	: pVoid;			//! <Variable Comment="Points to the variable to store the received data in." Name="RECEIVETIMED.data0"/>
			datalengt0 	: UDINT;			//! <Variable Comment="The length of the expected data." Name="RECEIVETIMED.datalengt0"/>
			timeout0 	: UDINT;			//! <Variable Comment="The timeout for waiting until the receiving task becomes ready to accept data (in milliseconds)." Name="RECEIVETIMED.timeout0"/>
		END_VAR
		VAR_OUTPUT
			ret0 (EAX) 	: DINT;			//! <Variable Comment="TRUE if the data transfer has been successfully completed, otherwise an error code." Name="RECEIVETIMED.ret0"/>
		END_VAR;
				//! <Function Comment="Creates and initializes a semaphore." Name="CREATESEMAPHORE"/>
	FUNCTION __CDECL VIRTUAL GLOBAL CREATESEMAPHORE
		VAR_INPUT
			type0 	: LSL_MT_SEMATYPE;			//! <Variable Comment="The desired semaphore type." Name="CREATESEMAPHORE.type0"/>
			init0 	: UDINT;			//! <Variable Comment="Must be valid for the chosen semaphore type." Name="CREATESEMAPHORE.init0"/>
			flags0 	: UDINT;			//! <Variable Comment="Specifies whether and how the function should search for an existing semaphore." Name="CREATESEMAPHORE.flags0"/>
			name0 	: ^CHAR;			//! <Variable Comment="Pointer to the name of the semaphore." Name="CREATESEMAPHORE.name0"/>
		END_VAR
		VAR_OUTPUT
			ret0 (EAX) 	: MT_SEMAHANDLE;			//! <Variable Comment="A valid handle or NIL if the function fails." Name="CREATESEMAPHORE.ret0"/>
		END_VAR;
				//! <Function Comment="Deallocates and invalidates an existing semaphore." Name="DELETESEMAPHORE"/>
	FUNCTION __CDECL VIRTUAL GLOBAL DELETESEMAPHORE
		VAR_INPUT
			handle0 	: MT_SEMAHANDLE;			//! <Variable Comment="Must point to a valid semaphore." Name="DELETESEMAPHORE.handle0"/>
		END_VAR
		VAR_OUTPUT
			ret0 (EAX) 	: DINT;			//! <Variable Comment="MTERROR_NONE if no error occurred or an error code." Name="DELETESEMAPHORE.ret0"/>
		END_VAR;
				//! <Function Comment="The number of events stored in a semaphore can be enquired." Name="SEMAVALUE"/>
	FUNCTION __CDECL VIRTUAL GLOBAL SEMAVALUE
		VAR_INPUT
			handle0 	: MT_SEMAHANDLE;			//! <Variable Comment="References the semaphore to enquire." Name="SEMAVALUE.handle0"/>
		END_VAR
		VAR_OUTPUT
			ret0 (EAX) 	: UDINT;			//! <Variable Comment="The number of events or an error code." Name="SEMAVALUE.ret0"/>
		END_VAR;
				//! <Function Comment="Can be used to enquire which task currently occupies a resource or mutex semaphore." Name="RESOURCEOWNER"/>
	FUNCTION __CDECL VIRTUAL GLOBAL RESOURCEOWNER
		VAR_INPUT
			handle0 	: MT_SEMAHANDLE;			//! <Variable Comment="References the resource or mutex semaphore to enquire." Name="RESOURCEOWNER.handle0"/>
		END_VAR
		VAR_OUTPUT
			ret0 (EAX) 	: MT_TASKHANDLE;			//! <Variable Comment="If the semaphore is free the return value is NIL, otherwise the task handle." Name="RESOURCEOWNER.ret0"/>
		END_VAR;
				//! <Function Comment="Stores an event in a semaphore." Name="SIGNAL"/>
	FUNCTION __CDECL VIRTUAL GLOBAL SIGNAL
		VAR_INPUT
			handle0 	: MT_SEMAHANDLE;			//! <Variable Comment="References the semaphore to store the event." Name="SIGNAL.handle0"/>
		END_VAR
		VAR_OUTPUT
			ret0 (EAX) 	: DINT;			//! <Variable Comment="MTERROR_NONE if no error occurred or an error code." Name="SIGNAL.ret0"/>
		END_VAR;
				//! <Function Comment="Releases all tasks waiting at an event semaphore and immediately resets the semaphore." Name="PULSE"/>
	FUNCTION __CDECL VIRTUAL GLOBAL PULSE
		VAR_INPUT
			handle0 	: MT_SEMAHANDLE;			//! <Variable Comment="All tasks currently waiting at handle0 are made ready." Name="PULSE.handle0"/>
		END_VAR
		VAR_OUTPUT
			ret0 (EAX) 	: DINT;			//! <Variable Comment="MTERROR_NONE if no error occurred or an error code." Name="PULSE.ret0"/>
		END_VAR;
				//! <Function Comment="Retrieves an event from a semaphore." Name="WAIT"/>
	FUNCTION __CDECL VIRTUAL GLOBAL WAIT
		VAR_INPUT
			handle0 	: MT_SEMAHANDLE;			//! <Variable Comment="References the semaphore from which to retrieve the event." Name="WAIT.handle0"/>
		END_VAR
		VAR_OUTPUT
			ret0 (EAX) 	: DINT;			//! <Variable Comment="MTERROR_NONE if no error occurred or an error code." Name="WAIT.ret0"/>
		END_VAR;
				//! <Function Comment="Retrieves an event from a semaphore." Name="WAITCOND"/>
	FUNCTION __CDECL VIRTUAL GLOBAL WAITCOND
		VAR_INPUT
			handle0 	: MT_SEMAHANDLE;			//! <Variable Comment="References the semaphore from which to retrieve the event." Name="WAITCOND.handle0"/>
		END_VAR
		VAR_OUTPUT
			ret0 (EAX) 	: DINT;			//! <Variable Comment="TRUE if a signal was retrieved, otherwise an error code." Name="WAITCOND.ret0"/>
		END_VAR;
				//! <Function Comment="A timeout for the occurrence of an event can be specified." Name="WAITTIMED"/>
	FUNCTION __CDECL VIRTUAL GLOBAL WAITTIMED
		VAR_INPUT
			handle0 	: MT_SEMAHANDLE;			//! <Variable Comment="References the semaphore to wait at." Name="WAITTIMED.handle0"/>
			timeout0 	: UDINT;			//! <Variable Comment="The maximum time (in milliseconds) to wait for the occurrence of an event." Name="WAITTIMED.timeout0"/>
		END_VAR
		VAR_OUTPUT
			ret0 (EAX) 	: DINT;			//! <Variable Comment="TRUE if an event was retrieved. Otherwise, no event was available and the timeout has expired." Name="WAITTIMED.ret0"/>
		END_VAR;
				//! <Function Comment="Sets the value of an event semaphore to 0." Name="RESETEVENT"/>
	FUNCTION __CDECL VIRTUAL GLOBAL RESETEVENT
		VAR_INPUT
			handle0 	: MT_SEMAHANDLE;			//! <Variable Comment="References the semaphore to reset." Name="RESETEVENT.handle0"/>
		END_VAR
		VAR_OUTPUT
			ret0 (EAX) 	: DINT;			//! <Variable Comment="MTERROR_NONE if no error occurred or an error code." Name="RESETEVENT.ret0"/>
		END_VAR;
				//! <Function Comment="Creates and initializes a mailbox." Name="CREATEMAILBOX"/>
	FUNCTION __CDECL VIRTUAL GLOBAL CREATEMAILBOX
		VAR_INPUT
			messagelen0 	: UDINT;			//! <Variable Comment="The length of the mailboxes&apos; messages in bytes." Name="CREATEMAILBOX.messagelen0"/>
			messageslots0 	: UDINT;			//! <Variable Comment="The maximum number of messages the mailbox can store." Name="CREATEMAILBOX.messageslots0"/>
			name0 	: ^CHAR;			//! <Variable Comment="Points to the name of the mailbox." Name="CREATEMAILBOX.name0"/>
		END_VAR
		VAR_OUTPUT
			ret0 (EAX) 	: MT_MAILBOX;			//! <Variable Comment="Reference to the new mailbox or NIL if an error occurred." Name="CREATEMAILBOX.ret0"/>
		END_VAR;
				//! <Function Comment="Releases the storage used by a mailbox." Name="DELETEMAILBOX"/>
	FUNCTION __CDECL VIRTUAL GLOBAL DELETEMAILBOX
		VAR_INPUT
			mbhandle0 	: MT_MAILBOX;			//! <Variable Comment="References the mailbox to delete." Name="DELETEMAILBOX.mbhandle0"/>
		END_VAR
		VAR_OUTPUT
			ret0 (EAX) 	: DINT;			//! <Variable Comment="MTERROR_NONE if no error occurred or an error code." Name="DELETEMAILBOX.ret0"/>
		END_VAR;
				//! <Function Comment="Clears the contents of a mailbox." Name="CLEARMAILBOX"/>
	FUNCTION __CDECL VIRTUAL GLOBAL CLEARMAILBOX
		VAR_INPUT
			mbhandle0 	: MT_MAILBOX;			//! <Variable Comment="References the mailbox to clear." Name="CLEARMAILBOX.mbhandle0"/>
		END_VAR
		VAR_OUTPUT
			ret0 (EAX) 	: DINT;			//! <Variable Comment="MTERROR_NONE if no error occurred or an error code." Name="CLEARMAILBOX.ret0"/>
		END_VAR;
				//! <Function Comment="Returns the number of messages currently stored in a mailbox." Name="MESSAGES"/>
	FUNCTION __CDECL VIRTUAL GLOBAL MESSAGES
		VAR_INPUT
			mbhandle0 	: MT_MAILBOX;			//! <Variable Comment="Specifies the mailbox to enquire." Name="MESSAGES.mbhandle0"/>
		END_VAR
		VAR_OUTPUT
			ret0 (EAX) 	: UDINT;			//! <Variable Comment="The return value will always lie between 0 and the value of parameter messageslots0 passed to CREATEMAILBOX when the mailbox was created." Name="MESSAGES.ret0"/>
		END_VAR;
				//! <Function Comment="Stores a message in a mailbox." Name="PUT"/>
	FUNCTION __CDECL VIRTUAL GLOBAL PUT
		VAR_INPUT
			mbhandle0 	: MT_MAILBOX;			//! <Variable Comment="The mailbox to store the message in." Name="PUT.mbhandle0"/>
			data0 	: pVoid;			//! <Variable Comment="Is stored in the mailbox." Name="PUT.data0"/>
		END_VAR
		VAR_OUTPUT
			ret0 (EAX) 	: DINT;			//! <Variable Comment="MTERROR_NONE if no error occurred or an error code." Name="PUT.ret0"/>
		END_VAR;
				//! <Function Comment="PUTFRONT corresponds to PUT, but inserts the message at the start of the mailbox queue rather than at the end." Name="PUTFRONT"/>
	FUNCTION __CDECL VIRTUAL GLOBAL PUTFRONT
		VAR_INPUT
			mbhandle0 	: MT_MAILBOX;			//! <Variable Comment="The mailbox to store the message in." Name="PUTFRONT.mbhandle0"/>
			data0 	: pVoid;			//! <Variable Comment="Is stored in the mailbox." Name="PUTFRONT.data0"/>
		END_VAR
		VAR_OUTPUT
			ret0 (EAX) 	: DINT;			//! <Variable Comment="MTERROR_NONE if no error occurred or an error code." Name="PUTFRONT.ret0"/>
		END_VAR;
				//! <Function Comment="Retrieves a message from a mailbox." Name="GET"/>
	FUNCTION __CDECL VIRTUAL GLOBAL GET
		VAR_INPUT
			mbhandle0 	: MT_MAILBOX;			//! <Variable Comment="The mailbox from which to retrieve the message." Name="GET.mbhandle0"/>
			data0 	: pVoid;			//! <Variable Comment="Points to the variable to store the message in." Name="GET.data0"/>
		END_VAR
		VAR_OUTPUT
			ret0 (EAX) 	: DINT;			//! <Variable Comment="MTERROR_NONE if no error occurred or an error code." Name="GET.ret0"/>
		END_VAR;
				//! <Function Comment="Stores a message in a mailbox." Name="PUTCOND"/>
	FUNCTION __CDECL VIRTUAL GLOBAL PUTCOND
		VAR_INPUT
			mbhandle0 	: MT_MAILBOX;			//! <Variable Comment="The mailbox to store the message in." Name="PUTCOND.mbhandle0"/>
			data0 	: pVoid;			//! <Variable Comment="Is stored in the mailbox." Name="PUTCOND.data0"/>
		END_VAR
		VAR_OUTPUT
			ret0 (EAX) 	: DINT;			//! <Variable Comment="TRUE if the message has been successfully stored, otherwise an error code." Name="PUTCOND.ret0"/>
		END_VAR;
				//! <Function Comment="PUTFRONTCOND corresponds to PUTCOND, but inserts the message at the start of the mailbox queue rather than at the end." Name="PUTFRONTCOND"/>
	FUNCTION __CDECL VIRTUAL GLOBAL PUTFRONTCOND
		VAR_INPUT
			mbhandle0 	: MT_MAILBOX;			//! <Variable Comment="The mailbox to store the message in." Name="PUTFRONTCOND.mbhandle0"/>
			data0 	: pVoid;			//! <Variable Comment="Is stored in the mailbox." Name="PUTFRONTCOND.data0"/>
		END_VAR
		VAR_OUTPUT
			ret0 (EAX) 	: DINT;			//! <Variable Comment="TRUE if the message has been successfully stored, otherwise an error code." Name="PUTFRONTCOND.ret0"/>
		END_VAR;
				//! <Function Comment="Retrieves a message from a mailbox." Name="GETCOND"/>
	FUNCTION __CDECL VIRTUAL GLOBAL GETCOND
		VAR_INPUT
			mbhandle0 	: MT_MAILBOX;			//! <Variable Comment="The mailbox from which to retrieve the message." Name="GETCOND.mbhandle0"/>
			data0 	: pVoid;			//! <Variable Comment="Points to the variable to store the message in." Name="GETCOND.data0"/>
		END_VAR
		VAR_OUTPUT
			ret0 (EAX) 	: DINT;			//! <Variable Comment="TRUE if the message has been successfully retrieved, otherwise an error code." Name="GETCOND.ret0"/>
		END_VAR;
				//! <Function Comment="Enquires the next message." Name="NEXTCOND"/>
	FUNCTION __CDECL VIRTUAL GLOBAL NEXTCOND
		VAR_INPUT
			mbhandle0 	: MT_MAILBOX;			//! <Variable Comment="The mailbox from which to enquire the message." Name="NEXTCOND.mbhandle0"/>
			data0 	: pVoid;			//! <Variable Comment="Points to the variable to store the message in." Name="NEXTCOND.data0"/>
		END_VAR
		VAR_OUTPUT
			ret0 (EAX) 	: DINT;			//! <Variable Comment="TRUE if at least one message is available in the mailbox and data0 contains a copy of the message, otherwise an error code." Name="NEXTCOND.ret0"/>
		END_VAR;
				//! <Function Comment="Stores a message in a mailbox if space becomes available within a certain time span." Name="PUTTIMED"/>
	FUNCTION __CDECL VIRTUAL GLOBAL PUTTIMED
		VAR_INPUT
			mbhandle0 	: MT_MAILBOX;			//! <Variable Comment="The mailbox to store the message in." Name="PUTTIMED.mbhandle0"/>
			data0 	: pVoid;			//! <Variable Comment="Is stored in the mailbox." Name="PUTTIMED.data0"/>
			timeout0 	: UDINT;			//! <Variable Comment="The timeout (in milliseconds) for waiting until space becomes available in the mailbox." Name="PUTTIMED.timeout0"/>
		END_VAR
		VAR_OUTPUT
			ret0 (EAX) 	: DINT;			//! <Variable Comment="TRUE if the message has been successfully stored, otherwise an error code." Name="PUTTIMED.ret0"/>
		END_VAR;
				//! <Function Comment="PUTFRONTTIMED corresponds to PUTTIMED, but inserts the message at the start of the mailbox queue rather than at the end." Name="PUTFRONTTIMED"/>
	FUNCTION __CDECL VIRTUAL GLOBAL PUTFRONTTIMED
		VAR_INPUT
			mbhandle0 	: MT_MAILBOX;			//! <Variable Comment="The mailbox to store the message in." Name="PUTFRONTTIMED.mbhandle0"/>
			data0 	: pVoid;			//! <Variable Comment="Is stored in the mailbox." Name="PUTFRONTTIMED.data0"/>
			timeout0 	: UDINT;			//! <Variable Comment="The timeout (in milliseconds) for waiting until space becomes available in the mailbox." Name="PUTFRONTTIMED.timeout0"/>
		END_VAR
		VAR_OUTPUT
			ret0 (EAX) 	: DINT;			//! <Variable Comment="TRUE if the message has been successfully stored, otherwise an error code." Name="PUTFRONTTIMED.ret0"/>
		END_VAR;
				//! <Function Comment="Retrieves a message from a mailbox if a message becomes available within a certain time." Name="GETTIMED"/>
	FUNCTION __CDECL VIRTUAL GLOBAL GETTIMED
		VAR_INPUT
			mbhandle0 	: MT_MAILBOX;			//! <Variable Comment="The mailbox from which to retrieve the message." Name="GETTIMED.mbhandle0"/>
			data0 	: pVoid;			//! <Variable Comment="Points to the variable to store the message in." Name="GETTIMED.data0"/>
			timeout0 	: UDINT;			//! <Variable Comment="Is the timeout (in milliseconds) for waiting until a message becomes available in the mailbox." Name="GETTIMED.timeout0"/>
		END_VAR
		VAR_OUTPUT
			ret0 (EAX) 	: DINT;			//! <Variable Comment="TRUE if the message has been successfully retrieved, otherwise an error code." Name="GETTIMED.ret0"/>
		END_VAR;
	
	FUNCTION __CDECL VIRTUAL GLOBAL GETTASKPRIOBYID
		VAR_INPUT
			udTaskID 	: UDINT;
		END_VAR
		VAR_OUTPUT
			ret0 (EAX) 	: DINT;
		END_VAR;
				//! <Function Comment="Blocks the calling task for the specified time span and allows other tasks to run." Name="TASKDELAYUS"/>
	FUNCTION __CDECL VIRTUAL GLOBAL TASKDELAYUS
		VAR_INPUT
			timeout0 	: UDINT;			//! <Variable Comment="Specifies the time in microseconds, the task must be blocked." Name="TASKDELAYUS.timeout0"/>
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

//}}LSL_DECLARATION


FUNCTION GLOBAL TAB _MultiTask::@CT_
0$UINT,
2#0100000000001000$UINT, //TY__MULTITASK
1$UINT, 1$UINT, (SIZEOF(::_MultiTask))$UINT, 
1$UINT, 0$UINT, 0$UINT, 
TO_UDINT(2641766936), "_MultiTask", //Class
TO_UDINT(0), 0, 0$UINT, 0$UINT, //Baseclass
//Servers:
(::_MultiTask.Server0.pMeth)$UINT, _CH_CMD$UINT, 2#0000000000000000$UINT, TO_UDINT(2759080719), "Server0", 
//Clients:
END_FUNCTION


#define USER_CNT__MultiTask 47

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT__MultiTask] OF ^Void;
	END_STRUCT;
END_TYPE



//{{LSL_IMPLEMENTATION


//*********************Inserted from <.\OS Interface\code\_MultiTask_00_00.st>*********************



 



#include <Rtos_interfaces.h> // we need this for the SysCIL functions
#include "..\..\Source\code\OsiBaseNew.h"

#define METH_GETVERSION         0000
#define METH_GETLASTERROR       0001
#define METH_GETTIME            0002
#define METH_CREATETHREAD       0003
#define METH_TERMINATETASK      0004
#define METH_SUSPEND            0005
#define METH_RESUME             0006
#define METH_CURRENTTASKHANDLE  0007
#define METH_GETTASKSTATE       0008
#define METH_SETPRIORITY        0009
#define METH_GETTASKPRIO        0010
#define METH_GETTASKSTACK       0011
#define METH_GETMINSTACK        0012
#define METH_DELAY              0013
#define METH_DELAYUNTIL         0014
#define METH_SEND               0015
#define METH_SENDCOND           0016
#define METH_SENDTIMED          0017
#define METH_RECEIVE            0018
#define METH_RECEIVECOND        0019
#define METH_RECEIVETIMED       0020
#define METH_CREATESEMAPHORE    0021
#define METH_DELETESEMAPHORE    0022
#define METH_SEMAVALUE          0023
#define METH_RESOURCEOWNER      0024
#define METH_SIGNAL             0025
#define METH_PULSE              0026
#define METH_WAIT               0027
#define METH_WAITCOND           0028
#define METH_WAITTIMED          0029
#define METH_RESETEVENT         0030
#define METH_CREATEMAILBOX      0031
#define METH_DELETEMAILBOX      0032
#define METH_CLEARMAILBOX       0033
#define METH_MESSAGES           0034
#define METH_PUT                0035
#define METH_PUTFRONT           0036
#define METH_GET                0037
#define METH_PUTCOND            0038
#define METH_PUTFRONTCOND       0039
#define METH_GETCOND            0040
#define METH_NEXTCOND           0041
#define METH_PUTTIMED           0042
#define METH_PUTFRONTTIMED      0043
#define METH_GETTIMED           0044
#define METH_GETTASKPRIOBYID    0045
#define METH_TASKDELAYUS        0046

#define METH_MAXNUMBER          0047

#if METH_MAXNUMBER <> USER_CNT__MultiTask
#pragma message ("Die Anzahl der definierten Methoden ist: " USER_CNT__MultiTask " nicht " METH_MAXNUMBER)
#endif

VAR_PRIVATE
   API_Version:UDINT;
END_VAR



FUNCTION _GetVersion
VAR_OUTPUT
   ret0:UDINT;
END_VAR   
   ret0 := API_Version;
END_FUNCTION
FUNCTION __CDECL MT_Dummy
VAR_OUTPUT
   ret0:DINT;
END_VAR   
   ret0 := MTERROR_NOIFFNC;
END_FUNCTION

#pragma warning (disable:73)

FUNCTION __CDECL TASKDELAYUS_Dummy
VAR_INPUT
	timeout0 	: UDINT;
END_VAR
	TRACE("ERROR: Function not available with this version/platform!");
END_FUNCTION

#pragma warning (default:73)

FUNCTION  _MultiTask::_MultiTask
VAR_OUTPUT
   ret_code    : CONFSTATES;
END_VAR
VAR
   MT_API   : ^LSL_MT_TYPE;
   aMeths  : ARRAY[0..USER_CNT__MultiTask] OF ^void;
   retv    : SYS_ERROR;
END_VAR;

   retv := OS_CILGet("LSL_MULTITASK", #MT_API$void);
   IF retv <> SYS_ERR_NONE THEN

      TRACE("ERROR: MULTITASK Interface not available with this version/platform!");
      ret_code := C_UNKNOWN_CONSTR;
      RETURN;

   END_IF;

       API_Version := MT_API^.version;

       aMeths[METH_GETVERSION]        := #_GetVersion();
       aMeths[METH_GETLASTERROR]      := MT_API^.GETLASTERROR;
       aMeths[METH_GETTIME]           := MT_API^.GETTIME;
       aMeths[METH_CREATETHREAD]      := MT_API^.CREATETHREAD;
       aMeths[METH_TERMINATETASK]     := MT_API^.TERMINATETASK;
       aMeths[METH_SUSPEND]           := MT_API^.SUSPEND;
       aMeths[METH_RESUME]            := MT_API^.RESUME;
       aMeths[METH_CURRENTTASKHANDLE] := MT_API^.CURRENTTASKHANDLE;
       aMeths[METH_GETTASKSTATE]      := MT_API^.GETTASKSTATE;
       aMeths[METH_SETPRIORITY]       := MT_API^.SETPRIORITY;
       aMeths[METH_GETTASKPRIO]       := MT_API^.GETTASKPRIO;
       aMeths[METH_GETTASKSTACK]      := MT_API^.GETTASKSTACK;
       aMeths[METH_GETMINSTACK]       := MT_API^.GETMINSTACK;
       aMeths[METH_DELAY]             := MT_API^._DELAY;
       aMeths[METH_DELAYUNTIL]        := MT_API^.DELAYUNTIL;
       aMeths[METH_SEND]              := MT_API^.SEND;
       aMeths[METH_SENDCOND]          := MT_API^.SENDCOND;
       aMeths[METH_SENDTIMED]         := MT_API^.SENDTIMED;
       aMeths[METH_RECEIVE]           := MT_API^.RECEIVE;
       aMeths[METH_RECEIVECOND]       := MT_API^.RECEIVECOND;
       aMeths[METH_RECEIVETIMED]      := MT_API^.RECEIVETIMED;
       aMeths[METH_CREATESEMAPHORE]   := MT_API^.CREATESEMAPHORE;
       aMeths[METH_DELETESEMAPHORE]   := MT_API^.DELETESEMAPHORE;
       aMeths[METH_SEMAVALUE]         := MT_API^.SEMAVALUE;
       aMeths[METH_RESOURCEOWNER]     := MT_API^.RESOURCEOWNER;
       aMeths[METH_SIGNAL]            := MT_API^.SIGNAL;
       aMeths[METH_PULSE]             := MT_API^.PULSE;
       aMeths[METH_WAIT]              := MT_API^.WAIT;
       aMeths[METH_WAITCOND]          := MT_API^.WAITCOND;
       aMeths[METH_WAITTIMED]         := MT_API^.WAITTIMED;
       aMeths[METH_RESETEVENT]        := MT_API^.RESETEVENT;
       aMeths[METH_CREATEMAILBOX]     := MT_API^.CREATEMAILBOX;
       aMeths[METH_DELETEMAILBOX]     := MT_API^.DELETEMAILBOX;
       aMeths[METH_CLEARMAILBOX]      := MT_API^.CLEARMAILBOX;
       aMeths[METH_MESSAGES]          := MT_API^.MESSAGES;
       aMeths[METH_PUT]               := MT_API^.PUT;
       aMeths[METH_PUTFRONT]          := MT_API^.PUTFRONT;
       aMeths[METH_GET]               := MT_API^.GET;
       aMeths[METH_PUTCOND]           := MT_API^.PUTCOND;
       aMeths[METH_PUTFRONTCOND]      := MT_API^.PUTFRONTCOND;
       aMeths[METH_GETCOND]           := MT_API^.GETCOND;
       aMeths[METH_NEXTCOND]          := MT_API^.NEXTCOND;
       aMeths[METH_PUTTIMED]          := MT_API^.PUTTIMED;
       aMeths[METH_PUTFRONTTIMED]     := MT_API^.PUTFRONTTIMED;
       aMeths[METH_GETTIMED]          := MT_API^.GETTIMED;

	   IF (API_Version >= 0x00010002) THEN

  		 aMeths[METH_GETTASKPRIOBYID] := MT_API^.GETTASKPRIOBYID;
       ELSE
	     
		 aMeths[METH_GETTASKPRIOBYID] := #MT_Dummy();
	   END_IF;
     
     IF (API_Version >= 0x00010004) THEN
       aMeths[METH_TASKDELAYUS] := MT_API^.DELAYUS;
     ELSE
       aMeths[METH_TASKDELAYUS] := #TASKDELAYUS_Dummy();
     END_IF;

       ret_code  := InitOsiM_new(#aMeths[0]$void, USER_CNT__MultiTask);

END_FUNCTION //  _MultiTask::_MultiTask
