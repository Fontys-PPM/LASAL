//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)
//{{LSL_DECLARATION

(*!
<Class
	Name               = "MoveController"
	Revision           = "0.0"
	GUID               = "{4CCE7D61-1241-4401-9247-E713ACA7A0B9}"
	RealtimeTask       = "true"
	DefRealtime        = "1 ms"
	CyclicTask         = "false"
	BackgroundTask     = "false"
	Sigmatek           = "false"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	SharedCommandTable = "true"
	Objectsize         = "(284,120)">
	<Channels>
		<Server Name="sPower" GUID="{35C57A0D-055C-4F87-9F38-0A086F78AAB4}" Visualized="false" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="State" GUID="{14E0D100-AEE2-43A6-B848-1943C82AA51A}" Visualized="false" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="Status" GUID="{BCEBFDDD-48AC-43AD-99EE-DDEFE12E9880}" Visualized="false" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Client Name="CommandServer" Required="true" Internal="false"/>
		<Client Name="lmcX" Required="true" Internal="false"/>
		<Client Name="lmcY" Required="true" Internal="false"/>
	</Channels>
</Class>
*)
MoveController : CLASS
	TYPE
#pragma pack(push, 1)
	  _Move : STRUCT
	    Start : DINT;
	    X : DINT;
	    Z : DINT;
	    Y : DINT;
	    Speed : DINT;
	    Acc : DINT;
	  END_STRUCT;
#pragma pack(pop)
	  _State :  //! <Type Public="true" Name="_State"/>
	  (
	    _Safe,
	    _Homing,
	    _Idle,
	    _MovingAbsolute,
	    _moveready,
	    _MovingRelative,
	    _Pick,
	    _Place,
	    _Error
	  )$UDINT;
	  _Status :  //! <Type Public="true" Name="_Status"/>
	  (
	    _Idle,
	    _PowerOn,
	    _PowerIsOn,
	    _refRun,
	    _RefrunOk,
	    _MoveAbosolute,
	    _InPosition
	  )$UDINT;
	END_TYPE
  //Servers:
	Status 	: SvrChCmd__Status_PTofCls_MoveController;
	sPower 	: SvrCh_DINT;
	State 	: SvrCh__State_PTofCls_MoveController;
  //Clients:
	lmcX 	: CltChCmd__LMCAxis;
	lmcY 	: CltChCmd__LMCAxis;
	CommandServer 	: CltChCmd_CommandServer;
  //Variables:
		NewMove 	: _Move;
		IsMoving 	: BOOL;
  //Functions:
	
	FUNCTION VIRTUAL GLOBAL Init;
	
	FUNCTION VIRTUAL GLOBAL RtWork
		VAR_INPUT
			EAX 	: UDINT;
		END_VAR
		VAR_OUTPUT
			state (EAX) 	: UDINT;
		END_VAR;
	
	FUNCTION GLOBAL MoveAxis
		VAR_INPUT
			XPos 	: DINT;
			YPos 	: DINT;
			Speed 	: DINT;
			Accel 	: DINT;
		END_VAR;
	
	FUNCTION GLOBAL TogglePower
		VAR_INPUT
			Power 	: BOOL;
		END_VAR;
	
	FUNCTION StateMachine;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

#pragma usingLtd _LMCAxis
#pragma usingLtd CommandServer


//}}LSL_DECLARATION


FUNCTION GLOBAL TAB MoveController::@CT_
0$UINT,
2#0100000000000010$UINT, //TY_MOVECONTROLLER
0$UINT, 0$UINT, (SIZEOF(::MoveController))$UINT, 
3$UINT, 3$UINT, 0$UINT, 
TO_UDINT(1841029985), "MoveController", //Class
TO_UDINT(0), 0, 0$UINT, 0$UINT, //Baseclass
//Servers:
(::MoveController.Status.pMeth)$UINT, _CH_CMD$UINT, 2#0000000000000000$UINT, TO_UDINT(2348327578), "Status", 
(::MoveController.sPower.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2703552503), "sPower", 
(::MoveController.State.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1422331979), "State", 
//Clients:
(::MoveController.lmcX.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(908124938), "lmcX", TO_UDINT(1422175863), "_LMCAxis", 1$UINT, 85$UINT, 
(::MoveController.lmcY.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(1093129116), "lmcY", TO_UDINT(1422175863), "_LMCAxis", 1$UINT, 85$UINT, 
(::MoveController.CommandServer.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(1706127036), "CommandServer", TO_UDINT(1706127036), "CommandServer", 0$UINT, 0$UINT, 
END_FUNCTION


#define USER_CNT_MoveController 0

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_MoveController] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION MoveController::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
	END_VAR

	//Command Methods
	InitCmdTable (nCmd := nSTDCMD + USER_CNT_MoveController, pCmd := #vmt.CmdTable);
	vmt.CmdTable.Write		:= #M_WR_DIRECT();
	vmt.CmdTable.Init		:= #Init();
	vmt.CmdTable.RtWork		:= #RtWork();
	Status.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF Status.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	sPower.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF sPower.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	State.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF State.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;

END_FUNCTION

//{{LSL_IMPLEMENTATION

FUNCTION VIRTUAL GLOBAL MoveController::Init
  IsMoving := FALSE;
END_FUNCTION


FUNCTION VIRTUAL GLOBAL MoveController::RtWork
	VAR_INPUT
		EAX 	: UDINT;
	END_VAR
	VAR_OUTPUT
		state (EAX) 	: UDINT;
	END_VAR
  
  StateMachine();
	state := READY;
END_FUNCTION


FUNCTION MoveController::StateMachine

case State of

_State::_Safe:
  IF sPower THEN
    IF lmcX.AxisStatus.ReadyToPowerOn & lmcY.AxisStatus.ReadyToPowerOn THEN
      lmcX.PowerOn(Mode:=::_LMCAXIS_MOVEDIRECTION::LMCAXIS_MOVE_ANY_WAY);
      lmcY.PowerOn(Mode:=::_LMCAXIS_MOVEDIRECTION::LMCAXIS_MOVE_ANY_WAY);
      State := _State::_Homing;
    END_IF;
  END_IF;
  
_State::_Homing:
  IF lmcX.AxisStatus.PowerOn THEN
    lmcX.MoveReference(Mode:=_LMCAXIS_REFMODE.NoZImpulse , Position:=0, VRef1:=200000, VRef2:=50000, Accel:=5000000, PositionWindow:=50000, RefJerk:=0);
    lmcY.MoveReference(Mode:=_LMCAXIS_REFMODE.NoZImpulse | _LMCAXIS_REFMODE.RefDirection, Position:=0, VRef1:=2000000, VRef2:=500000, Accel:=20000000, PositionWindow:=50000, RefJerk:=0);
    //lmcY.MoveReference(Mode:=_LMCAXIS_REFMODE.NoZImpulse |_LMCAXIS_REFMODE.RefDirection , Position:=, VRef1:=, VRef2:=, Accel:=, PositionWindow:=, RefJerk:=);
  ELSIF lmcX.AxisStatus.IsReferenced & lmcY.AxisStatus.IsReferenced THEN
    State:=_State::_Idle;
  END_IF;
  
_State::_Idle:
  IF lmcX.AxisStatus.PowerOn THEN
    IF NewMove.Start THEN
      State:=_State::_MovingAbsolute;
    END_IF;
  END_IF;
  IF sPower = FALSE THEN
    lmcX.PowerOff(Mode:=::_LMCAXIS_POWER_OFF_MODE::LMCAXIS_SMOOTH_STOPP);
    lmcY.PowerOff(Mode:=::_LMCAXIS_POWER_OFF_MODE::LMCAXIS_SMOOTH_STOPP);
    State:=_State::_Safe;
  END_IF;
  
_State::_MovingAbsolute:
    lmcx.MoveAbsolute(Position:=NewMove.X, Speed:=NewMove.Speed, Accel:=NewMove.Acc, Decel:=NewMove.Acc, Jerk:=0);
    lmcY.MoveAbsolute(Position:=NewMove.Y, Speed:=NewMove.Speed, Accel:=NewMove.Acc, Decel:=NewMove.Acc, Jerk:=0);
    State:=_State::_moveready;

_State::_moveready:
    IF lmcX.InPosition(Mode:=::_LMCAXIS_QUERY_POSITION_MODE::LMCAXIS_ACTPOS_IN_WINDOW_APP_UNITS, PositionWindow:=1000) &
     lmcY.InPosition(Mode:=::_LMCAXIS_QUERY_POSITION_MODE::LMCAXIS_ACTPOS_IN_WINDOW_APP_UNITS, PositionWindow:=1000) THEN
      NewMove.Start := FALSE;
      CommandServer.SendStatus(Status:=1);
      State:=_State::_Idle;
    END_IF;

END_CASE;


END_FUNCTION
FUNCTION GLOBAL MoveController::MoveAxis
	VAR_INPUT
		XPos 	: DINT;
		YPos 	: DINT;
		Speed 	: DINT;
		Accel 	: DINT;
	END_VAR
  
  NewMove.X := XPos;
  NewMove.Y := YPos;
  NewMove.Speed := Speed;
  NewMove.Acc := Accel;
  
  NewMove.Start:=TRUE;
  
END_FUNCTION


FUNCTION GLOBAL MoveController::TogglePower
	VAR_INPUT
		Power 	: BOOL;
	END_VAR
  sPower:=Power;

END_FUNCTION
