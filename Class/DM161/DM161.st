//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)

//{{LSL_DEFINES
#define DEVICE_ID_DM161 1029

//}}LSL_DEFINES

//{{LSL_DECLARATION

(*!
<Class
	Name               = "DM161"
	Revision           = "1.12"
	GUID               = "{32158574-3D84-4244-ABAE-F62BF4B89E96}"
	RealtimeTask       = "false"
	CyclicTask         = "false"
	BackgroundTask     = "false"
	Sigmatek           = "true"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	IconPath           = ".\Class\s-dias.ico"
	SharedCommandTable = "true"
	Objectsize         = "(494,120)"
	Comment            = "This hardware class is used to control the DM161 hardware module with 8 digital inputs and 8 digital outputs.">
	<Channels>
		<Server Name="Input1" GUID="{2D974C62-80E3-4625-828C-140BD0016A2D}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Input 1 value"/>
		<Server Name="Input2" GUID="{38869745-7485-4568-812C-843F8B105A11}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Input 2 value"/>
		<Server Name="Input3" GUID="{D70208B8-C9DE-4DE0-8909-3ADADBF462CE}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Input 3 value"/>
		<Server Name="Input4" GUID="{8B1558AC-FBE6-4997-8C8E-003BF3E07D4F}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Input 4 value"/>
		<Server Name="Input5" GUID="{FA430548-0138-41BD-B527-374169014476}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Input 5 value"/>
		<Server Name="Input6" GUID="{188D3054-6589-446F-A074-BA8D79AE341F}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Input 6 value"/>
		<Server Name="Input7" GUID="{F80FDD57-918F-45EE-8CEE-6F6CBBAE22CF}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Input 7 value"/>
		<Server Name="Input8" GUID="{30E9C9BB-DFBB-4C24-936D-3B2CB8EFA649}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Input 8 value"/>
		<Server Name="InputByte" GUID="{8E5F05B8-8D1B-4170-94CA-86E586096B3C}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Bit 0 to 7 ... Input 1 to 8"/>
		<Server Name="Output1" GUID="{6D9719FB-779C-4EAF-A41A-8726515E46F2}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false" Comment="Digital Output 1"/>
		<Server Name="Output2" GUID="{04641EAB-5DB5-4164-8EBA-13EB02625D5A}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false" Comment="Digital Output 2"/>
		<Server Name="Output3" GUID="{03C4CDF3-4B3F-4F73-A39E-0E8132C6A6E4}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false" Comment="Digital Output 3"/>
		<Server Name="Output4" GUID="{C6CE0931-58EE-4E11-9D18-8C70B0390864}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false" Comment="Digital Output 4"/>
		<Server Name="Output5" GUID="{D0C365FB-0386-4EF8-AFD5-BA86E56A7AA0}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false" Comment="Digital Output 5"/>
		<Server Name="Output6" GUID="{C97A79B3-1A91-4A3E-AC64-F24DABC9A698}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false" Comment="Digital Output 6"/>
		<Server Name="Output7" GUID="{807DE5FE-061C-45CA-BD0C-97155D91357D}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false" Comment="Digital Output 7"/>
		<Server Name="Output8" GUID="{F72C0E69-3486-4186-A693-31D01551FE3D}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false" Comment="Digital Output 8"/>
		<Server Name="OutputByte" GUID="{82951DB6-2149-49F8-9C40-64D33C503818}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false" Comment="The digital outputs are displayed in this server in a 8-bit field"/>
		<Server Name="VoltageOk" GUID="{544B8C98-4878-4C59-BF98-FC0E29F32E2B}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Supply voltage ok&#13;&#10;+24V2 (Digital Out 1-8)"/>
	</Channels>
	<RevDoku>
		<Owner Company="Sigmatek" Author="BeiWol"/>
		<Dokumentation Revision="1.12" Date="08.06.2018" Author="RamAnd" Company="Sigmatek" Description="LASAL Hardware Description (.lhd) file has been updated."/>
		<Dokumentation Revision="1.11" Date="16.05.2017" Author="RamAnd" Company="Sigmatek" Description="When adding an SDO (i.e. via ReadSPIData) from background priority it was possible that the adding process got interrupted by receiving the answer to this SDO which is handled in cyclic priority. In the error case the answer was unexpected and therefore ignored. Then the class signals a timeout while waiting for the answer, which already arrived before waiting for it. Added mutex and changed instruction order to prevent this error."/>
		<Dokumentation Revision="1.10" Date="27.03.2017" Author="EisMic" Company="Sigmatek" Description="Corrected comment of server VoltageOk."/>
		<Dokumentation Revision="1.9" Date="12.07.2016" Author="SeiChr" Company="Sigmatek" Description="Added Values for the total Current calculation. SA 31571"/>
		<Dokumentation Revision="1.8" Date="01.03.2016" Author="EisMic" Company="Sigmatek" Description="Corrected BoundExceed Error in base class at Write method of LEDControl Server when Place = LSL_DEACTIVATED."/>
		<Dokumentation Revision="1.7" Date="22.06.2015" Author="EisMic" Company="Sigmatek" Description="The servers FPGAVersion, SerialNo, Device ID and status and input servers are now not reset anymore when the module is disconnected.&#13;&#10;Outputs are now written to the hardware in any case after a reconnect."/>
		<Dokumentation Revision="1.6" Date="27.05.2015" Author="EisMic" Company="Sigmatek" Description="Corrected ConnectEvent Method that outputs are set after reconnect."/>
		<Dokumentation Revision="1.5" Date="16.04.2015" Author="EisMic&#13;&#10;LanSte" Company="Sigmatek" Description="Added support for visualisation in graphical hardware editor.&#13;&#10;Added support for calculating resources for graphical hardware editor."/>
		<Dokumentation Revision="1.4" Date="17.03.2015" Author="RamAnd" Company="Sigmatek" Description="Added HW Version for sdias clients."/>
		<Dokumentation Revision="1.3" Date="11.02.2015" Author="PieSte" Company="Sigmatek" Description="Corrected read spi data for hardwaretree in methode GetSPIDataFromID from baseclass."/>
		<Dokumentation Revision="1.2" Date="18.11.2014" Author="PieSte" Company="Sigmatek" Description="Added possibility  to read more data from spi flash then one sdo access.&#13;&#10;Set methode GetDeviceID to global.&#13;&#10;Add methode to calculate checksum of spi flash."/>
		<Dokumentation Revision="1.1" Date="09.07.2014" Author="EisMic" Company="Sigmatek" Description="Added support for reading hardware diagnosis and hardwaretree entry."/>
		<Dokumentation Revision="1.0" Date="27.01.2014" Author="PieSte" Company="Sigmatek" Description="First library version"/>
	</RevDoku>
	<Network Name="DM161">
		<!-- List of Components in this network -->
		<Components>
			<Object
				Name       = "_base"
				GUID       = "{61060596-9132-45AF-B1E9-E38F56488C38}"
				Class      = "SdiasBase"
				Position   = "(218,120)"
				Visualized = "true">
				<Channels>
					<Server Name="ClassState"/>
					<Server Name="DeviceID"/>
					<Server Name="FPGAVersion"/>
					<Server Name="HwVersion"/>
					<Server Name="LEDControl" Value="0"/>
					<Server Name="RetryCounter"/>
					<Server Name="SDOState"/>
					<Server Name="SerialNo"/>
					<Client Name="Place" Value="0"/>
					<Client Name="Required" Value="1"/>
					<Client Name="SdiasIn"/>
					<Client Name="ToStdLib"/>
				</Channels>
			</Object>
		</Components>
		<Comments>
		</Comments>
		<!-- List of Connections in this network -->
		<Connections>
			<Connection Source="this.ClassState" Destination="_base.ClassState" Vertices="(804,210),(632,210),"/>
			<Connection Source="this.DeviceID" Destination="_base.DeviceID" Vertices="(804,270),(632,270),"/>
			<Connection Source="this.SerialNo" Destination="_base.SerialNo" Vertices="(804,450),(632,450),"/>
			<Connection Source="this.RetryCounter" Destination="_base.RetryCounter" Vertices="(804,510),(632,510),"/>
			<Connection Source="_base.SdiasIn" Destination="this.SdiasIn" Vertices="(218,210),(38,210),"/>
			<Connection Source="_base.Place" Destination="this.Place" Vertices="(218,270),(38,270),"/>
			<Connection Source="_base.Required" Destination="this.Required" Vertices="(218,330),(38,330),"/>
			<Connection Source="this.LEDControl" Destination="_base.LEDControl" Vertices="(804,570),(632,570),"/>
			<Connection Source="this.FPGAVersion" Destination="_base.FPGAVersion" Vertices="(804,330),(632,330),"/>
			<Connection Source="this.HwVersion" Destination="_base.HwVersion" Vertices="(804,390),(632,390),"/>
		</Connections>
		<!-- Headerfiles -->
		<Options>
		</Options>
	</Network>
</Class>
*)
#pragma using SdiasBase

DM161 : CLASS
: SdiasBase
	TYPE
	  t_DigitalInputs : BSINT
	  [
	  ];
	  t_VoltageOk : BSINT
	  [
	    1 Ok24V1,
	    2 Ok24V2,
	  ];
#pragma pack(push, 1)
	  t_DigitalRead : STRUCT
	    Inputs : t_DigitalInputs;
	    Voltage : t_VoltageOk;
	  END_STRUCT;
#pragma pack(pop)
	END_TYPE
  //Servers:
	Input1 	: SvrCh_DINT;
	Input2 	: SvrCh_DINT;
	Input3 	: SvrCh_DINT;
	Input4 	: SvrCh_DINT;
	Input5 	: SvrCh_DINT;
	Input6 	: SvrCh_DINT;
	Input7 	: SvrCh_DINT;
	Input8 	: SvrCh_DINT;
	Output1 	: SvrCh_DINT;
	Output2 	: SvrCh_DINT;
	Output3 	: SvrCh_DINT;
	Output4 	: SvrCh_DINT;
	Output5 	: SvrCh_DINT;
	Output6 	: SvrCh_DINT;
	Output7 	: SvrCh_DINT;
	Output8 	: SvrCh_DINT;
	InputByte 	: SvrCh_BDINT;
	OutputByte 	: SvrCh_BDINT;
	VoltageOk 	: SvrCh_DINT;
  //Clients:
  //Variables:
		bdOutputBitsOld : BSINT
		[
		];
			//! <Variable Comment="Merker for old OutputStatus." Name="bdOutputBitsOld"/>
		pReadData 	: ^UINT;			//! <Variable Comment="Read-Data from the Module." Name="pReadData"/>
		pWriteData 	: ^USINT;			//! <Variable Comment="WriteData of the Module." Name="pWriteData"/>
  //Functions:
				//! <Function Comment="Realtime Update Methode which runs in PreScan." Name="UpdateRt"/>
	FUNCTION VIRTUAL GLOBAL UpdateRt;
				//! <Function Comment="Realtime Update Methode which runs in PostScan." Name="UpdateRtPostScan"/>
	FUNCTION VIRTUAL GLOBAL UpdateRtPostScan;
				//! <Function Comment="Methode is called if this Module gets connected." Name="ConnectEvent"/>
	FUNCTION VIRTUAL GLOBAL ConnectEvent;
				//! <Function Comment="Methode is called if this Module gets disconnected." Name="DisconnectEvent"/>
	FUNCTION VIRTUAL GLOBAL DisconnectEvent;
				//! <Function Comment="This Methode should is used, to check the DeviceID of the Module." Name="CheckDeviceID"/>
	FUNCTION VIRTUAL GLOBAL CheckDeviceID
		VAR_INPUT
			udID2Check 	: UDINT;			//! <Variable Comment="Device ID of connected Module." Name="CheckDeviceID.udID2Check"/>
		END_VAR
		VAR_OUTPUT
			bIsOK 	: BOOL;			//! <Variable Comment="FALSE = Wrong DeviceID for Module&#13;&#10;TRUE  = DeviceID of Module is correct" Name="CheckDeviceID.bIsOK"/>
		END_VAR;
	
	FUNCTION VIRTUAL GetTaskCfg
		VAR_OUTPUT
			TaskCfg 	: BDINT;			//! <Variable Comment="Select which tasks will be available for this module:&#13;&#10;Bit0..Realtime PreScan&#13;&#10;Bit1..Realtime PostScan&#13;&#10;Bit2..Cyclic&#13;&#10;&#13;&#10;e.g. if only realtime postscan is needed:&#13;&#10;2#010" Name="GetTaskCfg.TaskCfg"/>
		END_VAR;
	
	FUNCTION VIRTUAL GetDeviceID
		VAR_OUTPUT
			output 	: UDINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL Output1::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL Output2::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL Output3::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL Output4::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL Output5::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL Output6::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL Output7::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL Output8::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL OutputByte::Write
		VAR_INPUT
			input (EAX) 	: BDINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: BDINT;
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

//}}LSL_DECLARATION


FUNCTION GLOBAL TAB DM161::@CT_
0$UINT,
2#0100000000000000$UINT, //TY_DM161
1$UINT, 12$UINT, (SIZEOF(::DM161))$UINT, 
19$UINT, 0$UINT, 0$UINT, 
TO_UDINT(4282685340), "DM161", //Class
TO_UDINT(3175101883), "SdiasBase", 1$UINT, 58$UINT, //Baseclass
//Servers:
(::DM161.Input1.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1344628668), "Input1", 
(::DM161.Input2.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3375117830), "Input2", 
(::DM161.Input3.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3190490768), "Input3", 
(::DM161.Input4.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(542085939), "Input4", 
(::DM161.Input5.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1464378277), "Input5", 
(::DM161.Input6.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3460428319), "Input6", 
(::DM161.Input7.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3108422281), "Input7", 
(::DM161.Input8.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(704241432), "Input8", 
(::DM161.Output1.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2425114930), "Output1", 
(::DM161.Output2.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(159711368), "Output2", 
(::DM161.Output3.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2122461214), "Output3", 
(::DM161.Output4.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3773212093), "Output4", 
(::DM161.Output5.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2548143403), "Output5", 
(::DM161.Output6.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(250135697), "Output6", 
(::DM161.Output7.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2045768711), "Output7", 
(::DM161.Output8.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3914394006), "Output8", 
(::DM161.InputByte.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2419834899), "InputByte", 
(::DM161.OutputByte.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1569094752), "OutputByte", 
(::DM161.VoltageOk.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2158378107), "VoltageOk", 
//Clients:
END_FUNCTION


#define USER_CNT_DM161 20

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_DM161] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION DM161::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
		nCmdSize	: UINT;
	END_VAR

	ret_code	:= SdiasBase::@STD();
	IF ret_code <> C_OK THEN
		RETURN;
	END_IF;
	nCmdSize		:= SdiasBase::ClassState.pMeth^.nCmds$UINT*SIZEOF(pVoid) + CMDMETH.Init;

	_memcpy((#vmt.CmdTable)$^USINT, SdiasBase::ClassState.pMeth, nCmdSize);
	vmt.CmdTable.nCmds		:= nSTDCMD + USER_CNT_DM161;
#pragma warning (disable : 74)
	vmt.UserFcts[0]		:= #UpdateRt();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[1]		:= #UpdateRtPostScan();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[5]		:= #ConnectEvent();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[6]		:= #DisconnectEvent();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[8]		:= #CheckDeviceID();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[13]		:= #GetTaskCfg();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[14]		:= #GetDeviceID();

#pragma warning (default : 74)
	SdiasBase::ClassState.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF SdiasBase::ClassState.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	Output1.pMeth			:= StoreMethod( #M_RD_DIRECT(), #Output1::Write() );
	IF Output1.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	Output2.pMeth			:= StoreMethod( #M_RD_DIRECT(), #Output2::Write() );
	IF Output2.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	Output3.pMeth			:= StoreMethod( #M_RD_DIRECT(), #Output3::Write() );
	IF Output3.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	Output4.pMeth			:= StoreMethod( #M_RD_DIRECT(), #Output4::Write() );
	IF Output4.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	Output5.pMeth			:= StoreMethod( #M_RD_DIRECT(), #Output5::Write() );
	IF Output5.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	Output6.pMeth			:= StoreMethod( #M_RD_DIRECT(), #Output6::Write() );
	IF Output6.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	Output7.pMeth			:= StoreMethod( #M_RD_DIRECT(), #Output7::Write() );
	IF Output7.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	Output8.pMeth			:= StoreMethod( #M_RD_DIRECT(), #Output8::Write() );
	IF Output8.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	OutputByte.pMeth			:= StoreMethod( #M_RD_DIRECT(), #OutputByte::Write() );
	IF OutputByte.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;

END_FUNCTION

//{{LSL_IMPLEMENTATION

FUNCTION VIRTUAL GLOBAL DM161::UpdateRt
  VAR
    diInputsTmp  : t_DigitalRead;
    inputMask    : USINT;
    newInputs    : USINT;
    pInputSrv    : ^DINT;
  END_VAR

  diInputsTmp := (pReadData^)$t_DigitalRead;
  
  newInputs   := (diInputsTmp.Inputs)$USINT;
  InputMask   := InputByte$USINT xor newInputs; //old Input xor new Input (to see changes)
  
  if InputMask <> 0 then
    
    InputByte$DINT  := newInputs;
    pInputSrv       :=#Input1.Ddata;

    repeat
      if InputMask and 1 then
        pInputSrv^ := newInputs and 1;
      end_if;
      inputMask := inputMask shr 1;
      newInputs := newInputs shr 1;
      pInputSrv += sizeof(SvrCh);
    until inputMask = 0 end_repeat;
  end_if;
    
  VoltageOk := diInputsTmp.Voltage.Ok24V1;  

END_FUNCTION


FUNCTION VIRTUAL GLOBAL DM161::UpdateRtPostScan

  if OutputByte <> bdOutputBitsOld then
    pWriteData^     := OutputByte$USINT;  
    bdOutputBitsOld := OutputByte$USINT;
  end_if;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL DM161::CheckDeviceID
	VAR_INPUT
		udID2Check 	: UDINT;
	END_VAR
	VAR_OUTPUT
		bIsOK 	: BOOL;
	END_VAR
  
  //look if it is right hardware
	if ( udID2Check <> DEVICE_ID_DM161 ) then
		bIsOK := FALSE;
	else
    bIsOK := TRUE;
	end_if;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL DM161::ConnectEvent

  // start the accesses on the SDIAS (initialize the control byte in the DPRAM)
  if DefaultAccesses.ReadAccess.pControlByte then
    pReadData := DefaultAccesses.ReadAccess.pData$^UINT;

    DefaultAccesses.ReadAccess.pControlByte^.EnableDO := TRUE;
  else
    eInitState := _DOHandleInvalid;
    return;
  end_if;

  if DefaultAccesses.WriteAccess.pControlByte then
    pWriteData := DefaultAccesses.WriteAccess.pData$^USINT;

    DefaultAccesses.WriteAccess.pControlByte^.EnableDO := TRUE;
  else
    eInitState := _DOHandleInvalid;
    return;
  end_if;
  
  //Set to write outputs at first access and after reconnect
  bdOutputBitsOld := NOT OutputByte$BSINT;
  
  // module is ok
  eInitState := _ClassOk;
 
END_FUNCTION


FUNCTION VIRTUAL GLOBAL DM161::DisconnectEvent

  // reset general module information shown on servers
  SdiasBase::DisconnectEvent();

END_FUNCTION


FUNCTION VIRTUAL GLOBAL DM161::Output1::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR
  
  if input then  
    result  := 1;  
    Output1 := 1;  
    OutputByte.1  := 1;
  else  
    result  := 0;  
    Output1 := 0;  
    OutputByte.1  := 0;
  end_if;
	
END_FUNCTION


FUNCTION VIRTUAL GLOBAL DM161::Output2::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

  if input then  
    result  := 1;  
    Output2 := 1;  
    OutputByte.2  := 1;
  else  
    result  := 0;  
    Output2 := 0;  
    OutputByte.2  := 0;
  end_if;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL DM161::Output3::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

  if input then  
    result  := 1;  
    Output3 := 1;  
    OutputByte.3  := 1;
  else  
    result  := 0;  
    Output3 := 0;  
    OutputByte.3  := 0;
  end_if;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL DM161::Output4::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

  if input then  
    result  := 1;  
    Output4 := 1;  
    OutputByte.4  := 1;
  else  
    result  := 0;  
    Output4 := 0;  
    OutputByte.4  := 0;
  end_if;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL DM161::Output5::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

  if input then  
    result  := 1;  
    Output5 := 1;  
    OutputByte.5  := 1;
  else  
    result  := 0;  
    Output5 := 0;  
    OutputByte.5  := 0;
  end_if;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL DM161::Output6::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

  if input then  
    result  := 1;  
    Output6 := 1;  
    OutputByte.6  := 1;
  else  
    result  := 0;  
    Output6 := 0;  
    OutputByte.6  := 0;
  end_if;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL DM161::Output7::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

  if input then  
    result  := 1;  
    Output7 := 1;  
    OutputByte.7  := 1;
  else  
    result  := 0;  
    Output7 := 0;  
    OutputByte.7  := 0;
  end_if;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL DM161::Output8::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

  if input then  
    result  := 1;  
    Output8 := 1;  
    OutputByte.8  := 1;
  else  
    result  := 0;  
    Output8 := 0;  
    OutputByte.8  := 0;
  end_if;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL DM161::OutputByte::Write
	VAR_INPUT
		input (EAX) 	: BDINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: BDINT;
	END_VAR

  input := input AND 16#ff;
  
  if( input$hint <> OutputByte$hint)then
    Output1 :=  (input and 2#1)$DINT;
    Output2 :=  (input and 2#10)$DINT shr 1;
    Output3 :=  (input and 2#100)$DINT shr 2;
    Output4 :=  (input and 2#1000)$DINT shr 3;
    Output5 :=  (input and 2#10000)$DINT shr 4;
    Output6 :=  (input and 2#100000)$DINT shr 5;
    Output7 :=  (input and 2#1000000)$DINT shr 6;
    Output8 :=  (input and 2#10000000)$DINT shr 7;  
  end_if;
 	OutputByte := result := input;

END_FUNCTION


FUNCTION VIRTUAL DM161::GetTaskCfg
	VAR_OUTPUT
		TaskCfg 	: BDINT;
	END_VAR

  TaskCfg := SDIAS_TASK_MASK_RT_PRE OR SDIAS_TASK_MASK_RT_POST;
  
END_FUNCTION


FUNCTION VIRTUAL DM161::GetDeviceID
	VAR_OUTPUT
		output 	: UDINT;
	END_VAR
  
  output := DEVICE_ID_DM161;

END_FUNCTION
