//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)
//{{LSL_DECLARATION

(*!
<Class
	Name               = "VirtualBaseInit"
	Revision           = "1.3"
	GUID               = "{9FBB5A34-CCCF-441F-A614-0CCECBD76648}"
	RealtimeTask       = "false"
	CyclicTask         = "false"
	BackgroundTask     = "false"
	Sigmatek           = "true"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	IconPath           = ".\Class\VirtualBaseInit\tool.ICO"
	SharedCommandTable = "true"
	Objectsize         = "(284,120)"
	Comment            = "base class for storage with variable length and display on LSE or OPC">
	<Channels>
		<Server
			Name           = "Data"
			GUID           = "{81990015-D505-4977-9326-733789F9FEAA}"
			Visualized     = "false"
			Initialize     = "false"
			WriteProtected = "false"
			Retentive      = "false">
			<NewInst>
				<Function Name="GET_ADD_INFO">
				</Function>
				<Function Name="READ_DATA">
				</Function>
				<Function Name="WRITE_DATA">
				</Function>
				<Function Name="READ_DATA_OFF">
				</Function>
				<Function Name="WRITE_DATA_OFF">
				</Function>
			</NewInst>
		</Server>
	</Channels>
	<Dependencies>
		<Files>
			<File Path=".\Class\StringInternal\StringDefs.h" Include="false"/>
		</Files>
	</Dependencies>
	<RevDoku>
		<Owner/>
		<Dokumentation Revision="1.3" Date="2013-04-23" Author="kolott" Company="sigmatek" Description="arm-ready"/>
	</RevDoku>
</Class>
*)
VirtualBaseInit : CLASS
	TYPE
	  CmdData :  //! <Type Public="true" Name="CmdData"/>
	  (
	    GET_ADD_INFO,
	    READ_DATA,
	    WRITE_DATA,
	    READ_DATA_OFF,
	    WRITE_DATA_OFF
	  )$UINT;
	END_TYPE
  //Servers:
	Data 	: SvrChCmd_UDINT;
  //Clients:
  //Variables:
  //Functions:
				//! <Function Comment=" This constructor is called for all derived objects&#13;&#10; automatically. It marks the object as a data buffer,&#13;&#10; which enables the ComLink-class to transmit more than&#13;&#10; only the 4 bytes of the dData element.&#13;&#10; Dieser Konstruktor wird für alle abgeleiteten Klassen automatisch&#13;&#10; aufgerufen. Er markiert das Objekt als Datenpuffer. Dadurch kann&#13;&#10; die ComLink-Klasse speziell für solche Objekte mehr als nur die&#13;&#10; 4 Byte des dData-Elements übertragen.&#13;&#10;" Name="VirtualBaseInit"/>
	FUNCTION VirtualBaseInit
		VAR_OUTPUT
			ret_code 	: ConfStates;			//! <Variable Comment=" C_OK:object could be constructed, else error" Name="VirtualBaseInit.ret_code"/>
		END_VAR;
				//! <Function Comment=" Overwrite this function for derived classes. It should return&#13;&#10; the length of the internal data buffer. If it&apos;s not possible&#13;&#10; to return the length, then overwrite the NewInst method, too,&#13;&#10; and use a different way to return the data.&#13;&#10; Diese Funktion gehört für abgeleitete Klassen überschrieben. Sie soll&#13;&#10; die Länge des internen Datenpuffers zurückliefern. Falls das nicht&#13;&#10; möglich ist, muß auch die NewInst-Methode überschrieben werden (READ_DATA).&#13;&#10;" Name="GetLength"/>
	FUNCTION VIRTUAL GLOBAL GetLength
		VAR_OUTPUT
			udLen 	: UDINT;			//! <Variable Comment=" length of internal data buffer" Name="GetLength.udLen"/>
		END_VAR;
				//! <Function Comment=" Diese Funktion muß für abgeleitete Klassen überschrieben werden. Sie soll die&#13;&#10; Daten vom angegebenen Offset im Datenpuffer auf den übergebenen Pointer kopieren.&#13;&#10; Maximal dürfen udLen-Bytes kopiert werden.&#13;&#10; Die Funktion wird durch das READ_DATA-Kommando der NewInst-Methode aufgerufen.&#13;&#10; Overwrite this function for derived classes, copy the data from offset udOff&#13;&#10; to the pointer pData. Copy at maximum udLen - bytes of data.&#13;&#10; The function is called on the READ_DATA-command in the NewInst-&#13;&#10; method.&#13;&#10;[&gt;udSize] data length to be copied&#13;&#10;[&gt;udAt] offset where data should be copied from&#13;&#10;" Name="GetDataAt"/>
	FUNCTION VIRTUAL GLOBAL GetDataAt
		VAR_INPUT
			pData 	: ^USINT;			//! <Variable Comment=" Zeiger auf die Daten" Name="GetDataAt.pData"/>
			udSize 	: UDINT;			//! <Variable Comment=" Länge der Daten die kopiert werden sollen" Name="GetDataAt.udSize"/>
			udAt 	: UDINT;			//! <Variable Comment=" Offset innerhalb des internen Datenpuffers, von dem die Daten kopiert werden sollen" Name="GetDataAt.udAt"/>
		END_VAR;
				//! <Function Comment=" Die Funktion soll ein Objekt mit Daten aus dem Konfigurationsfile&#13;&#10; intialisieren. Überschreiben Sie die Funktion für abgeleitete&#13;&#10; Klassen.&#13;&#10; The function should initialize an object with a data buffer&#13;&#10; from the configuration files.&#13;&#10; Overwrite the function for derived classes.&#13;&#10;" Name="InitFromTable"/>
	FUNCTION VIRTUAL GLOBAL InitFromTable
		VAR_INPUT
			udLen 	: UDINT;			//! <Variable Comment=" Länge des Datenblocks mit dem das Objekt initialisiert werden soll" Name="InitFromTable.udLen"/>
			pData 	: ^USINT;			//! <Variable Comment=" pointer to data block" Name="InitFromTable.pData"/>
		END_VAR;
				//! <Function Comment=" The function doesn&apos;t provide default functionality&#13;&#10; Please overwrite it for derived classes.&#13;&#10; Die Funktion stellt keine Standard-Implementierung dar. Sie muß für abgeleitete&#13;&#10; Klassen überschrieben werden.&#13;&#10;" Name="WriteDataOff"/>
	FUNCTION VIRTUAL GLOBAL WriteDataOff
		VAR_INPUT
			udLen 	: UDINT;			//! <Variable Comment=" Length of initialization data block" Name="WriteDataOff.udLen"/>
			udOff 	: UDINT;			//! <Variable Comment=" form this offset the data is read" Name="WriteDataOff.udOff"/>
			pData 	: ^USINT;
		END_VAR;
				//! <Function Comment=" The function should return a value that can be used&#13;&#10; to check if the contents of the data buffer changed.&#13;&#10; Diese Funktion soll eine Prüfsumme über die gehaltenen Daten liefern,&#13;&#10; anhand derer eine Änderung der Daten festgestellt werden kann.&#13;&#10;[&lt;udCRC] Prüfsumme&#13;&#10;" Name="GetCRC"/>
	FUNCTION VIRTUAL GLOBAL GetCRC
		VAR_OUTPUT
			udCRC 	: UDINT;			//! <Variable Comment=" check sum" Name="GetCRC.udCRC"/>
		END_VAR;
				//! <Function Comment="This function servers as a default implementation for data access.&#13;&#10;It copies the maximum amount of bytes into the provided result buffer.&#13;&#10;Die Funktion stellt eine Standardimplementierung für die Datenabholung dar.&#13;&#10;Sie kopiert vom angegebenen Offset die maximale Anzahl an Bytes in den&#13;&#10;bereitgestellten Ergebnispuffer.&#13;&#10;[&gt;udMax] maximale Anzahl an Bytes die kopiert werden&#13;&#10;" Name="ReadDataOff"/>
	FUNCTION VIRTUAL GLOBAL ReadDataOff
		VAR_INPUT
			udOff 	: UDINT;			//! <Variable Comment=" Offset von dem aus dem internen Datenpuffer Daten gelesen werden" Name="ReadDataOff.udOff"/>
			pData 	: ^USINT;
			udMax 	: UDINT;			//! <Variable Comment=" maximum number of bytes to copy" Name="ReadDataOff.udMax"/>
		END_VAR
		VAR_OUTPUT
			udLen 	: UDINT;			//! <Variable Comment=" Länge des internen Datenpuffers" Name="ReadDataOff.udLen"/>
		END_VAR;
				//! <Function Comment=" The following commands can be used as a default implementation&#13;&#10; by all derived classes.&#13;&#10;[!GET_ADD_INFO]&#13;&#10; no default implementation available&#13;&#10; overwrite NewInst and provide class dependant&#13;&#10; information.&#13;&#10;[!READ_DATA]&#13;&#10;  copies the data buffer of the object to the&#13;&#10; result data buffer (not including the 0-termination&#13;&#10; of a string object)&#13;&#10;[!WRITE_DATA]&#13;&#10; copies the data from the command buffer to&#13;&#10; the data buffer of the object, the 1st 4 byte&#13;&#10; must contain the length of the data (not including&#13;&#10; the 0-termination of a string)&#13;&#10;[!READ_DATA_OFF]&#13;&#10;  reads data from the specified offset, returns the&#13;&#10; the maximum length (either limited by the data length&#13;&#10; or by the send buffer size&#13;&#10;[!WRITE_DATA_OFF]&#13;&#10; writes data to the specified offset, the length&#13;&#10; is contained in the 1st 4 bytes&#13;&#10; Die folgenden Kommandos können als Standard-Implementierung von&#13;&#10; allen abgeleiteten Klassen verwendet werden.&#13;&#10;[!READ_DATA]&#13;&#10; kopiert den Dateninhalt des Objekts in den Resultat-&#13;&#10; Puffer (ohne Abschlußnull eines Strings)&#13;&#10;[!WRITE_DATA]&#13;&#10; kopiert den Inhalt des Kommandopuffers in den Datenpuffer&#13;&#10; des Objekts. Die ersten 4 Byte müssen die Länge des&#13;&#10; Datenblocks angeben (bei Strings ohne Abschlußnull)&#13;&#10;[!READ_DATA_OFF]&#13;&#10; liest Daten vom angegebenen Offset, gibt die maximale&#13;&#10; Länge zurück (entweder die reservierte Länge oder die&#13;&#10; Länge des Resultatpuffers).&#13;&#10;[!WRITE_DATA_OFF]&#13;&#10; schreibt Daten auf den angegebenen Offset im Datenpuffer.&#13;&#10; Die Länge ist in den ersten 4 Byte enthalten.&#13;&#10;[!GET_ADD_INFO]&#13;&#10; keine Standard-Implementierung verfügbar, NewInst&#13;&#10; muß überschrieben werden, klassenabhängige Information&#13;&#10; soll geliefert werden.&#13;&#10;" Name="Data.NewInst"/>
	FUNCTION VIRTUAL GLOBAL Data::NewInst
		VAR_INPUT
			pPara 	: ^CmdStruct;
			pResult 	: ^results;
		END_VAR
		VAR_OUTPUT
			ret_code 	: iprStates;
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

//}}LSL_DECLARATION


FUNCTION GLOBAL TAB VirtualBaseInit::@CT_
0$UINT,
2#0100000000000000$UINT, //TY_VIRTUALBASEINIT
1$UINT, 3$UINT, (SIZEOF(::VirtualBaseInit))$UINT, 
1$UINT, 0$UINT, 0$UINT, 
TO_UDINT(3232495061), "VirtualBaseInit", //Class
TO_UDINT(0), 0, 0$UINT, 0$UINT, //Baseclass
//Servers:
(::VirtualBaseInit.Data.pMeth)$UINT, _CH_CMD$UINT, 2#0000000000000000$UINT, TO_UDINT(2607161047), "Data", 
//Clients:
END_FUNCTION


#define USER_CNT_VirtualBaseInit 6

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_VirtualBaseInit] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION VirtualBaseInit::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
	END_VAR

	//Command Methods
	InitCmdTable (nCmd := nSTDCMD + USER_CNT_VirtualBaseInit, pCmd := #vmt.CmdTable);
	vmt.CmdTable.NewInstr		:= #NewInst();
	vmt.CmdTable.Write		:= #M_WR_DIRECT();
#pragma warning (disable : 74)
	vmt.UserFcts[0]		:= #GetLength();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[1]		:= #GetDataAt();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[2]		:= #InitFromTable();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[3]		:= #WriteDataOff();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[4]		:= #GetCRC();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[5]		:= #ReadDataOff();

#pragma warning (default : 74)
	Data.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF Data.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	ret_code	:= VirtualBaseInit();

END_FUNCTION

//{{LSL_IMPLEMENTATION


//*********************Inserted from .\code\VirtualBase.st*********************



 



//[#ENGLISH]
// This constructor is called for all derived objects
// automatically. It marks the object as a data buffer,
// which enables the ComLink-class to transmit more than
// only the 4 bytes of the dData element.
//[<ret_code] C_OK:object could be constructed, else error
//[#DEUTSCH]
// Dieser Konstruktor wird für alle abgeleiteten Klassen automatisch
// aufgerufen. Er markiert das Objekt als Datenpuffer. Dadurch kann
// die ComLink-Klasse speziell für solche Objekte mehr als nur die
// 4 Byte des dData-Elements übertragen.
//[<ret_code] C_OK wenn das Objekt angelegt werden konnte, sonst Fehler
//
FUNCTION  VirtualBaseInit::VirtualBaseInit
VAR_OUTPUT
	ret_code		: CONFSTATES;
END_VAR

	SetDataBufferFlag( this );
	ret_code	:= C_OK;

END_FUNCTION // VirtualBaseInit::VirtualBaseInit
//[#ENGLISH]
// The following commands can be used as a default implementation
// by all derived classes.
//[!GET_ADD_INFO]
//	no default implementation available
//	overwrite NewInst and provide class dependant
//	information.
//[!READ_DATA]
// 	copies the data buffer of the object to the
//	result data buffer (not including the 0-termination
//	of a string object)
//[!WRITE_DATA]
//	copies the data from the command buffer to
//	the data buffer of the object, the 1st 4 byte
//	must contain the length of the data (not including
//	the 0-termination of a string)
//[!READ_DATA_OFF]
// 	reads data from the specified offset, returns the
//	the maximum length (either limited by the data length
//	or by the send buffer size
//[!WRITE_DATA_OFF]
//	writes data to the specified offset, the length
//	is contained in the 1st 4 bytes
//[#DEUTSCH]
// Die folgenden Kommandos können als Standard-Implementierung von
// allen abgeleiteten Klassen verwendet werden.
//[!READ_DATA]
//	kopiert den Dateninhalt des Objekts in den Resultat-
//	Puffer (ohne Abschlußnull eines Strings)
//[!WRITE_DATA]
//	kopiert den Inhalt des Kommandopuffers in den Datenpuffer
//	des Objekts. Die ersten 4 Byte müssen die Länge des
//	Datenblocks angeben (bei Strings ohne Abschlußnull)
//[!READ_DATA_OFF]
//	liest Daten vom angegebenen Offset, gibt die maximale
//	Länge zurück (entweder die reservierte Länge oder die
//	Länge des Resultatpuffers).
//[!WRITE_DATA_OFF]
//	schreibt Daten auf den angegebenen Offset im Datenpuffer.
//	Die Länge ist in den ersten 4 Byte enthalten.
//[!GET_ADD_INFO]
//	keine Standard-Implementierung verfügbar, NewInst
//	muß überschrieben werden, klassenabhängige Information
//	soll geliefert werden.
FUNCTION VIRTUAL GLOBAL VirtualBaseInit::Data::NewInst
VAR_INPUT
	pPara		: ^CmdStruct;
	pResult		: ^results;
END_VAR
VAR_OUTPUT
	ret_code		: iprStates;
END_VAR
VAR
	udLen			: UDINT;
END_VAR

	CASE pPara^.uiCmd$CmdData OF
	GET_ADD_INFO:
		pResult^.uiLng	:= 0;

	READ_DATA:
		udLen := GetLength();
		pResult^.aData[0]$UDINT := udLen;	// real length

		IF udLen > sizeof(results.aData)-sizeof(UDINT) THEN
			udLen	:= sizeof(results.aData)-sizeof(UDINT);
		END_IF;

		// transmitted length
		pResult^.uiLng	:= TO_UINT(udLen)+sizeof(UDINT)+sizeof(results.uiLng);
		GetDataAt(#pResult^.aData[sizeof(UDINT)], udLen, 0);

	WRITE_DATA:
		//InitFromTable(pPara^.aPara[0]$UDINT, #pPara^.aPara[1]$USINT);	.. scheitert bei StringRAM, wenn die RAMEx Zelle schon existiert
		WriteDataOff(pPara^.aPara[0]$UDINT, 0, #pPara^.aPara[1]$USINT);

	READ_DATA_OFF:
		pResult^.uiLng	:= TO_UINT(ReadDataOff(pPara^.aPara[0]$UDINT, #pResult^.aData[0], sizeof(results.aData)))
							+ sizeof(results.uiLng);
		
	WRITE_DATA_OFF:
		WriteDataOff(pPara^.aPara[0]$UDINT, pPara^.aPara[1]$UDINT, #pPara^.aPara[2]$USINT);

	END_CASE;

	ret_code := READY;

END_FUNCTION //VIRTUAL GLOBAL String::NewInst
//[#DEUTSCH]
// Diese Funktion muß für abgeleitete Klassen überschrieben werden. Sie soll die
// Daten vom angegebenen Offset im Datenpuffer auf den übergebenen Pointer kopieren.
// Maximal dürfen udLen-Bytes kopiert werden.
// Die Funktion wird durch das READ_DATA-Kommando der NewInst-Methode aufgerufen.
//[>pData] Zeiger auf den Datenblock der die Daten aufnehmen soll
//[>udSize] Länge der Daten die kopiert werden sollen
//[>udAt] Offset innerhalb des internen Datenpuffers, von dem die Daten kopiert werden sollen
//[#ENGLISH]
// Overwrite this function for derived classes, copy the data from offset udOff
// to the pointer pData. Copy at maximum udLen - bytes of data.
// The function is called on the READ_DATA-command in the NewInst-
// method.
//[>pData] pointer to data buffer which receives data
//[>udSize] data length to be copied
//[>udAt] offset where data should be copied from
FUNCTION VIRTUAL GLOBAL VirtualBaseInit::GetDataAt
VAR_INPUT
#pragma warning (disable : 73)
	pData		: ^USINT;
	udSize		: UDINT;
	udAt		: UDINT;
#pragma warning (default : 73)
END_VAR


END_FUNCTION //VIRTUAL GLOBAL VirtualBaseInit::GetDataAt
//[#ENGLISH]
// The function doesn't provide default functionality
// Please overwrite it for derived classes.
//[>udLen]	data length to be copied
//[>udOff]	offset where data should be copied to
//[>pData]	pointer to new data
//[#DEUTSCH]
// Die Funktion stellt keine Standard-Implementierung dar. Sie muß für abgeleitete
// Klassen überschrieben werden.
//[>udLen] Länge des übergebenen Datenpuffers
//[>udOff] Offset innerhalb des internen Datenpuffers, auf den die Daten kopiert werden sollen
//[>pData] Zeiger auf den neuen Datenblock
FUNCTION VIRTUAL GLOBAL VirtualBaseInit::WriteDataOff
VAR_INPUT
#pragma warning (disable : 73)
	udLen		: UDINT;
	udOff		: UDINT;
	pData		: ^USINT;
#pragma warning (default : 73)
END_VAR


END_FUNCTION //VIRTUAL GLOBAL VirtualBaseInit::WriteDataOff
//[#ENGLISH]
//This function servers as a default implementation for data access.
//It copies the maximum amount of bytes into the provided result buffer.
//[>udOff]	form this offset the data is read
//[>pData]	pointer to result buffer
//[>udMax]	maximum number of bytes to copy
//[<udLen]	number of bytes actually copied
//[#DEUTSCH]
//Die Funktion stellt eine Standardimplementierung für die Datenabholung dar.
//Sie kopiert vom angegebenen Offset die maximale Anzahl an Bytes in den
//bereitgestellten Ergebnispuffer.
//[>udOff]	Offset von dem aus dem internen Datenpuffer Daten gelesen werden
//[>pData]	Zeiger auf den Ergebnispuffer
//[>udMax]	maximale Anzahl an Bytes die kopiert werden
//[<udLen]	Anzahl der kopierten Bytes
FUNCTION VirtualBaseInit::ReadDataOff
VAR_INPUT
	udOff		: UDINT;
	pData		: ^USINT;
	udMax		: UDINT;
END_VAR
VAR_OUTPUT
	udLen		: UDINT;
END_VAR

	udLen := GetLength();
	IF udLen > udOff THEN
		udLen -= udOff;
	ELSE
		udLen := 0;
	END_IF;

	IF udLen > udMax THEN
		udLen	:= udMax;
	END_IF;

	GetDataAt(pData, udLen, udOff);

END_FUNCTION
//[#DEUTSCH]
// Die Funktion soll ein Objekt mit Daten aus dem Konfigurationsfile
// intialisieren. Überschreiben Sie die Funktion für abgeleitete
// Klassen.
//[>udLen] Länge des Datenblocks mit dem das Objekt initialisiert werden soll
//[>pData] Zeiger auf die Daten
//[#ENGLISH]
// The function should initialize an object with a data buffer
// from the configuration files.
// Overwrite the function for derived classes.
//[>udLen] Length of initialization data block
//[>pData] pointer to data block
FUNCTION VIRTUAL GLOBAL VirtualBaseInit::InitFromTable
VAR_INPUT
#pragma warning (disable : 73)
	udLen		: UDINT;
	pData		: ^USINT;
#pragma warning (default : 73)
END_VAR


END_FUNCTION //VIRTUAL GLOBAL VirtualBaseInit::InitFromTable
//[#ENGLISH]
// Overwrite this function for derived classes. It should return
// the length of the internal data buffer. If it's not possible
// to return the length, then overwrite the NewInst method, too,
// and use a different way to return the data.
//[<udLen] length of internal data buffer
//[#DEUTSCH]
// Diese Funktion gehört für abgeleitete Klassen überschrieben. Sie soll
// die Länge des internen Datenpuffers zurückliefern. Falls das nicht
// möglich ist, muß auch die NewInst-Methode überschrieben werden (READ_DATA).
//[<udLen] Länge des internen Datenpuffers
FUNCTION VIRTUAL GLOBAL VirtualBaseInit::GetLength
VAR_OUTPUT
	udLen		: UDINT;
END_VAR

	udLen := 0;

END_FUNCTION //VIRTUAL GLOBAL VirtualBaseInit::GetLength
//[#ENGLISH]
// The function should return a value that can be used
// to check if the contents of the data buffer changed.
//[<udCRC] check sum
//[#DEUTSCH]
// Diese Funktion soll eine Prüfsumme über die gehaltenen Daten liefern,
// anhand derer eine Änderung der Daten festgestellt werden kann.
//[<udCRC] Prüfsumme
FUNCTION VIRTUAL GLOBAL VirtualBaseInit::GetCRC
VAR_OUTPUT
	udCRC		: UDINT;
END_VAR

	udCRC	:= 0;	// never changing

END_FUNCTION //VIRTUAL GLOBAL VirtualBaseInit::GetCRC
