//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)

//{{LSL_DEFINES
  #ifndef OS_VERSION_MIN_SALAMANDER
    #define OS_VERSION_MIN_SALAMANDER          0x9000
  #endif
  #define TCP_SVR_NO_ERROR                          0

  #define TCP_SVR_ERR_INVALID_SOCKET            -1


  #define TCP_SVR_ERR_SET_PARA_INVALID_CMD     -10
  #define TCP_SVR_ERR_SET_PARA_INVALID_SUB_CMD -11

  #define TCP_SVR_ERR_TASK_ALREADY_EXIST       -12


  // - RETURN VALUES PRIVATE METHOD Read_AP_TaskPeriod
  #define TCP_SVR_ERR_TASK_TIME_NO_APP            -31
  #define TCP_SVR_ERR_TASK_TIME_WRONG_TASK_TYPE   -33
  #define TCP_SVR_ERR_TASK_TIME_OBJ_NOT_FOUND     -35

  // - RETURN VALUES PRIVATE METHOD Read_LSLOBJ_CRC32
  #define TCP_SVR_ERR_GET_LSLOBJ_NAME             -20
  #define TCP_SVR_ERR_INVALID_POINTER             -21

  // - RETURN VALUES PRIVATE METHOD AP_TaskCreate
  #define TCP_SVR_ERR_TASK_CREATE                 -40

  // - RETURN VALUES PRIVATE METHOD AP_SemaCreate
  #define TCP_SVR_ERR_SEMA_CREATE                 -50
  #define TCP_SVR_ERR_SEMA_INVALID_IDX            -51
  #define TCP_SVR_ERR_SEMA_INVALID_NAME           -52

  #define TCP_SVR_SEND_BUFFER_EMPTY               -6
  #define TCP_SVR_ERR_SEND_BUFFER_FATAL_ERROR     -7

  #define TCP_SVR_SEND_BUFFER_FULL      -4

  #define TCP_SVR_SOCK_INFO_CONNECT                 1
  #define TCP_SVR_SOCK_INFO_DISCONNECT              0

  #define TCP_SVR_ERR_GROUP_OS                      0
  #define TCP_SVR_ERR_GROUP_AP                      1

  #define TCP_SVR_ERR_CODE_AP_TIMEOUT              -1

  #ifndef INIT_FIRSTSCAN
    #define INIT_FIRSTSCAN                         12
  #endif

  #ifndef AP_TASK_PRIORITY_DEFAULT
    #define AP_TASK_PRIORITY_DEFAULT               14
  #endif

  #define TCP_SVR_ERR_MAIN_INIT                   -90

  #define TCP_SVR_ERR_MAX_CONN                    -80

  #ifndef KEEPALIVE_INTERVAL_DEFAULT
    #define KEEPALIVE_INTERVAL_DEFAULT           7200
  #endif

  #ifndef KEEPALIVE_RETRYTIME_DEFAULT
    #define KEEPALIVE_RETRYTIME_DEFAULT            75
  #endif

  #ifndef KEEPALIVE_RETRYCNT_DEFUALT
    #define KEEPALIVE_RETRYCNT_DEFUALT             10
  #endif

  #ifndef CLOSE_SOCKET_TYPE_DEFAULT
    #define CLOSE_SOCKET_TYPE_DEFAULT               0
  #endif
//}}LSL_DEFINES

//{{LSL_DECLARATION
#include "..\..\Class\_TCPIP_SERVER\SalamanderDelay.h"

(*!
<Class
	Name               = "_TCPIP_SERVER"
	Revision           = "1.36"
	GUID               = "{E84BD10E-292D-4E0D-BB1B-39D896115F6E}"
	RealtimeTask       = "false"
	CyclicTask         = "true"
	DefCyclictime      = "10 ms"
	BackgroundTask     = "false"
	DefBackground      = "always"
	Sigmatek           = "true"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	SharedCommandTable = "true"
	Objectsize         = "(590,120)"
	Comment            = "TCP/IP Server for TCP/IP Communication">
	<Channels>
		<Server Name="sControl" GUID="{66AFA47E-2161-45EA-A723-9FFE3FE2BCB4}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false" Comment="shows the actual TCP/IP state"/>
		<Server Name="SemaName01" GUID="{B775AD7C-58EB-4B8E-8F93-6A68FE5D4FCA}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="name of mutex to save the internal connection buffer&#13;&#10;&#13;&#10;This name is also listed in PLCTraceView"/>
		<Server Name="SemaName02" GUID="{5179BD8F-F0F7-4ECA-9FC4-5EF66AA5AF90}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="name of mutex to save the internal connection settings (socket options)&#13;&#10;&#13;&#10;This name is also listed in PLCTraceView"/>
		<Server Name="sError" GUID="{B963685F-CCC8-43B3-8AF0-1B57CA1FB364}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false" Comment="Shows error codes&#13;&#10; 0 ... no error&#13;&#10;-1 ... general error&#13;&#10;-2 ... timeout error&#13;&#10;-3 ... connection closed by client&#13;&#10;-4 ... File open failed&#13;&#10;-5 ... Copy Data from File failed&#13;&#10;-6 ... Sending Data failed&#13;&#10;-7 ... read SendBuffer failed&#13;&#10;-8 ... BackUp- or Restore-Object failed&#13;&#10;-9 ... Pointer to SendBuffer = NIL&#13;&#10;-10... Pointer to Receive Buffer = NIL&#13;&#10;-11... Write into SendBuffer failed&#13;&#10;-12... Set Socket Option failed&#13;&#10;-13... Data is to big to send&#13;&#10;-14... Received Data is too short&#13;&#10;-15... Received Datasize not equal with specified Datasize&#13;&#10;-16... Received Datasize not equal with specified Datasize (too long)&#13;&#10;-99... Allocate Memory failed&#13;&#10;-100 . Search for Semikolon or Carriage Return failed"/>
		<Server Name="TaskName" GUID="{505801B5-33F8-44EC-BA56-99EAC85FE0FB}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="shows task information&#13;&#10;-) use object in cyclic task&#13;&#10;-) use object in async task&#13;&#10;-) task deactivated&#13;&#10;-) async task error status (error creating async task)&#13;&#10;&#13;&#10;In case of using the object in async task, this name is also listed in PLCTraceView"/>
		<Client Name="cConfig" Required="false" Internal="false" Comment="object configuration&#13;&#10;bit0 ... task configuration&#13;&#10;0 = use object in cyclic task&#13;&#10;1 = use object in async task"/>
		<Client Name="CheckSum" Required="true" Internal="true"/>
		<Client Name="cMaxConnections" Required="true" Internal="false" DefValue="0" Comment="Maximal number of connections. Maximal possible connections are 16.&#13;&#10;&#13;&#10;0 = 16 connections, because of compatibility to older versions."/>
		<Client Name="co_MultiTask" Required="false" Internal="false" Comment="object channel to OS interface class _MultiTask"/>
		<Client Name="co_SigCLib" Required="false" Internal="false" Comment="object channel to OS interface class SigCLib"/>
		<Client Name="co_StdLib" Required="false" Internal="false" Comment="object channel to OS interface class _StdLib"/>
		<Client Name="co_Task" Required="false" Internal="false" Comment="object channel to OS interface class _TaskObjectControl"/>
		<Client Name="cPort" Required="true" Internal="false" Comment="port number&#13;&#10;"/>
		<Client Name="cSizeOfTXBuffer" Required="false" Internal="false" Comment="size of TX buffer [byte]&#13;&#10;if 0 there will be 1024 Byte allocated"/>
		<Client Name="cTimeout" Required="false" Internal="false" Comment="TCP timeout [ms]&#13;&#10;if 0 then Timeout is deactivated"/>
		<Client Name="StrSemaName01" Required="true" Internal="true"/>
		<Client Name="StrSemaName02" Required="true" Internal="true"/>
		<Client Name="StrTaskName" Required="true" Internal="true"/>
	</Channels>
	<Dependencies>
		<Files>
			<File Path=".\lsl_st_tcp_user.h" Include="false"/>
			<File Path=".\Class\_TCPIP_SERVER\_TCPIP_SERVER.h" Include="true"/>
			<File Path=".\Class\_TCPIP_SERVER\SalamanderDelay.h" Include="true"/>
		</Files>
	</Dependencies>
	<RevDoku>
		<Owner Company="SIGMATEK" Author="KELSTE"/>
		<Dokumentation Revision="1.36" Date="2018-02-22" Author="SchMat" Company="SIGMATEK" Description="- bugfix: send more than 5840 byte"/>
		<Dokumentation Revision="1.35" Date="2018-02-05" Author="SchMat" Company="SIGMATEK" Description="-corrected defines because of identical redefinition warning by using _TCPIP_CLIENT and _TCPIP_SERVER in same network"/>
		<Dokumentation Revision="1.34" Date="2017-10-27" Author="SchMat" Company="SIGMATEK" Description="- bugfix using async task at multi core CPUs&#13;&#10;- run cyclic task also in case of using async communication to do the CyWork of derived classes"/>
		<Dokumentation Revision="1.33" Date="2017-08-16" Author="HubChr, SchMat" Company="SIGMATEK" Description="Type of connection closing can now also be set (graceful close / hard close)"/>
		<Dokumentation Revision="1.32" Date="2017-06-22" Author="SchMat" Company="SIGMATEK" Description="bug fix: semaphore handling&#13;&#10;improvement: possible use of async task for cyclic connection updates&#13;&#10;improved error interfaces"/>
		<Dokumentation Revision="1.31" Date="2016-11-21" Author="HubChr" Company="SIGMATEK" Description="-) Fixed error that occurred when an Objectname longer than 32 signs was used&#13;&#10;-) CIL-Pointer is now declared as Member-Variable (was private)"/>
		<Dokumentation Revision="1.30" Date="2015-07-07" Author="hoechr1" Company="SIGMATEK" Description="Added support for sending more than 1452 Bytes.&#13;&#10;Added client cMaxConnections for set the number of connections that should be initialized.&#13;&#10;Added client co_MultiTask for threadsave working."/>
		<Dokumentation Revision="1.20" Date="2014-01-29" Author="spimar" Company="SIGMATEK" Description="Using defines for socketoptions for better source code readability"/>
		<Dokumentation Revision="1.10" Date="2013-09-24" Author="spimar" Company="SIGMATEK" Description="Added check of the array bound;"/>
		<Dokumentation Revision="1.3" Date="2012-03-20" Author="spimar" Company="SIGMATEK" Description="Added performance improvements;"/>
		<Dokumentation Revision="1.2" Date="2011-11-14" Author="FesGue" Company="SIGMATEK" Description="Memory Problem when received data is bigger than the receive Buffer"/>
		<Dokumentation Revision="1.1" Date="2011-08-30" Author="spimar" Company="SIGMATEK" Description="Added a step to check if interface is present;"/>
		<Dokumentation Revision="1.0" Date="8.10.2010" Author="KELSTE" Company="SIGMATEK" Description="TCP/IP Server for TCP/IP Communication"/>
	</RevDoku>
	<Network Name="_TCPIP_SERVER">
		<!-- List of Components in this network -->
		<Components>
			<Object
				Name       = "CheckSum"
				GUID       = "{924983ED-FE4B-4B5A-BC71-6E6963A07A78}"
				Class      = "_CheckSum"
				Position   = "(240,180)"
				Visualized = "false">
				<Channels>
					<Server Name="ClassSvr"/>
				</Channels>
			</Object>
			<Object
				Name       = "StrSemaName01"
				GUID       = "{299AFE23-53C0-4268-B520-661EA498CF23}"
				Class      = "String"
				Position   = "(240,510)"
				Visualized = "true"
				Remotely   = "true">
				<Channels>
					<Server Name="Data"/>
					<Client Name="SingleRealloc" Value="1"/>
				</Channels>
			</Object>
			<Object
				Name       = "StrSemaName02"
				GUID       = "{75EFD2B9-8A72-4ADD-B553-20298AB8A232}"
				Class      = "String"
				Position   = "(240,660)"
				Visualized = "true"
				Remotely   = "true">
				<Channels>
					<Server Name="Data"/>
					<Client Name="SingleRealloc" Value="1"/>
				</Channels>
			</Object>
			<Object
				Name       = "StrTaskName"
				GUID       = "{510AA27F-2062-4B46-A6C5-CE04D658B1CE}"
				Class      = "String"
				Position   = "(240,360)"
				Visualized = "true"
				Remotely   = "true">
				<Channels>
					<Server Name="Data"/>
					<Client Name="SingleRealloc" Value="1"/>
				</Channels>
			</Object>
		</Components>
		<Comments>
		</Comments>
		<!-- List of Connections in this network -->
		<Connections>
			<Connection Source="this.CheckSum" Destination="CheckSum.ClassSvr"/>
			<Connection Source="this.StrTaskName" Destination="StrTaskName.Data"/>
			<Connection Source="this.StrSemaName01" Destination="StrSemaName01.Data"/>
			<Connection Source="this.StrSemaName02" Destination="StrSemaName02.Data"/>
			<Connection Source="this.TaskName" Destination="StrTaskName.Data" Vertices="(818,330),(556,450),"/>
			<Connection Source="this.SemaName01" Destination="StrSemaName01.Data" Vertices="(818,390),(556,600),"/>
			<Connection Source="this.SemaName02" Destination="StrSemaName02.Data" Vertices="(818,450),(556,750),"/>
		</Connections>
		<!-- Headerfiles -->
		<Options>
		</Options>
	</Network>
</Class>
*)
_TCPIP_SERVER : CLASS
	TYPE
#pragma pack(push, 1)
	  _BUFFER : STRUCT  //! <Type Comment="Struct for Receive- and Send-Buffer" Name="_BUFFER"/>
	    udSize : UDINT;  //! <Type Comment="Size of Data" Name="_BUFFER.udSize"/>
	    pData : ^void;  //! <Type Comment="Pointer to Data" Name="_BUFFER.pData"/>
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  _BUFFER_HEADER : STRUCT
	    DataSize : UDINT;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  _TX_RINGBUFFER : STRUCT  //! <Type Comment="struct to handle a ringbuffer" Name="_TX_RINGBUFFER"/>
	    udSize : UDINT;
	    udUsed : UDINT;
	    pMem : ^void;
	    pRead : ^CHAR;
	    pWrite : ^CHAR;
	  END_STRUCT;
#pragma pack(pop)
	  _SocketOptions : BDINT
	  [
	    1 Nagle,
	    2 KeepAlive,
	    3 DelayedAck,
	    4 ReuseAddr,
	    5 Bit5,
	    6 Bit6,
	    7 Bit7,
	    8 Bit8,
	    9 Bit9,
	    10 Bit10,
	    11 Bit11,
	    12 Bit12,
	    13 Bit13,
	    14 Bit14,
	    15 Bit15,
	    16 Bit16,
	    17 Bit17,
	    18 Bit18,
	    19 Bit19,
	    20 Bit20,
	    21 Bit21,
	    22 Bit22,
	    23 Bit23,
	    24 Bit24,
	    25 Bit25,
	    26 Bit26,
	    27 Bit27,
	    28 Bit28,
	    29 Bit29,
	    30 Bit30,
	    31 Bit31,
	    32 Bit32,
	  ];
#pragma pack(push, 1)
	  _KeepAlivePara : STRUCT
	    keepIDLE : DINT;
	    keepINTVL : DINT;
	    keepCNT : DINT;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  _CONNECTION : STRUCT
	    dSocket : DINT;
	    FSM_TCP : _FSM_TCP_USER;
	    udTimeStamp : UDINT;
	    SendBuffer : _TX_RINGBUFFER;
	    pBufferWaitForSendig : ^CHAR;
	    pBufferWaitForSendingHelp : ^CHAR;
	    BufferHeader : _BUFFER_HEADER;
	    ConnSockOpt : _SocketOptions;
	    pNextConn : ^_CONNECTION;
	    bdSettings : BDINT
	    [
	      1 SockOptChanged,
	      2 Bit2,
	      3 Bit3,
	      4 Bit4,
	      5 Bit5,
	      6 Bit6,
	      7 Bit7,
	      8 Bit8,
	      9 Bit9,
	      10 Bit10,
	      11 Bit11,
	      12 Bit12,
	      13 Bit13,
	      14 Bit14,
	      15 Bit15,
	      16 Bit16,
	      17 Bit17,
	      18 Bit18,
	      19 Bit19,
	      20 Bit20,
	      21 Bit21,
	      22 Bit22,
	      23 Bit23,
	      24 Bit24,
	      25 Bit25,
	      26 Bit26,
	      27 Bit27,
	      28 Bit28,
	      29 Bit29,
	      30 Bit30,
	      31 Bit31,
	      32 Bit32,
	    ];
	    KeepAlivePara : _KeepAlivePara;
	    CloseSocketType : UDINT;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  _KeepAliveParaLasalOS : STRUCT
	    interval : UINT;
	    retry : UINT;
	    timeout : UINT;
	  END_STRUCT;
#pragma pack(pop)
	  _LONGSTRING : ARRAY [0..255] OF USINT;  //! <Type Comment="data buffer [256 byte]" Name="_LONGSTRING"/>
	END_TYPE
  //Servers:
	sControl 	: SvrChCmd__FSM_TCP_USER;
	sError 	: SvrCh_DINT;
	TaskName 	: SvrCh_UDINT;
	SemaName01 	: SvrCh_UDINT;
	SemaName02 	: SvrCh_UDINT;
  //Clients:
	cPort 	: CltCh_DINT;
	cTimeout 	: CltCh_DINT;
	cSizeOfTXBuffer 	: CltCh_UDINT;
	cMaxConnections 	: CltCh_DINT;
	cConfig 	: CltCh_DINT;
	co_StdLib 	: CltChCmd__StdLib;
	co_MultiTask 	: CltChCmd__MultiTask;
	co_SigCLib 	: CltChCmd_SigCLib;
	CheckSum 	: CltChCmd__CheckSum;
	StrTaskName 	: CltChCmd_String;
	StrSemaName01 	: CltChCmd_String;
	StrSemaName02 	: CltChCmd_String;
	co_Task 	: CltChCmd__TaskObjectControl;
  //Variables:
		dMainSock 	: DINT;			//! <Variable Comment="main socket for TCP/IP connection" Name="dMainSock"/>
		FSM_TCP 	: _FSM_TCP_USER;			//! <Variable Comment="finite state machine for TCP/IP connection" Name="FSM_TCP"/>
		SocketArray : ARRAY [0..15] OF _CONNECTION;
			//! <Variable Comment="Saves the Informations for each Connection" Name="SocketArray"/>
		RECVCounter 	: DINT;			//! <Variable Comment="when the _STATE_RECV is called 5 Times (for every Connection) the _STATE_ACCEPT is called again " Name="RECVCounter"/>
		RECVbuffer 	: _BUFFER;			//! <Variable Comment="struct of Receive buffer" Name="RECVbuffer"/>
		lsl_tcp_user 	: ^LSL_TCP_USER;
		usInit 	: USINT;
		bdStatus : BDINT
		[
		  1 SalamanderOS,
		  5 CIL_tcp_user,
		  6 CIL_ssl_user,
		  7 CIL_debug,
		  9 InhibNextConn,
		  13 LSLOBJ_CRC32,
		  14 AP_TaskPeriod,
		  15 CyclicTask,
		  16 AsyncTask,
		  17 Sema01,
		  18 Sema02,
		  25 ErrAsyncTask,
		  26 ErrSema01,
		  27 ErrSema02,
		  28 ErrMem,
		];

		MaxConn 	: DINT;
		lsl_ssl_user 	: ^LSL_SSL_USER;
		pCIL_DEBUG 	: ^OS_SALAMANDERDEBUG;
		MainSockOpt 	: _SocketOptions;
		AP_TaskTime 	: UDINT;
		AP_TaskHandle 	: MT_TASKHANDLE;
		AP_SemaHandle1 	: MT_SEMAHANDLE;
		AP_SemaSockOpt 	: MT_SEMAHANDLE;
		ActConn 	: DINT;
		pActConn 	: ^_CONNECTION;
		udTimeStamp 	: UDINT;
		udTimeAccept 	: UDINT;
		AP_TaskPriority 	: UDINT;
		KeepAlivePara 	: _KeepAlivePara;
		CloseSocketType 	: UDINT;
		dNewSock 	: DINT;
  //Functions:
				//! <Function Comment="-) initialize TCP USER pointer to use OS TCP FUNCTIONS&#13;&#10;-) read port number&#13;&#10;-) Allocate Memory for Buffers" Name="Init"/>
	FUNCTION VIRTUAL GLOBAL Init;
	
	FUNCTION VIRTUAL GLOBAL CyWork
		VAR_INPUT
			EAX 	: UDINT;
		END_VAR
		VAR_OUTPUT
			state (EAX) 	: UDINT;
		END_VAR;
				//! <Function Comment="this function reads data from the TX buffer" Name="RECVbuffer_Read"/>
	FUNCTION RECVbuffer_Read
		VAR_INPUT
			pData 	: ^void;
		END_VAR
		VAR_OUTPUT
			udSize 	: UDINT;
		END_VAR;
				//! <Function Comment="this function writes data into the TX buffer&#13;&#10;" Name="SENDbuffer_Write"/>
	FUNCTION SENDbuffer_Write
		VAR_INPUT
			pData 	: ^void;
			udSize 	: UDINT;
			pBuffer 	: ^_TX_RINGBUFFER;
		END_VAR
		VAR_OUTPUT
			dRetcode 	: DINT;
		END_VAR;
				//! <Function Comment="Function to send data over TCP/IP&#13;&#10;&#13;&#10;--------------------------------------&#13;&#10;Input variables&#13;&#10;--------------------------------------&#13;&#10;-) pData ... pointer to data to send&#13;&#10;-) udSize ... size of data to send [byte]&#13;&#10;-) dSock ... Receiver-Socket&#13;&#10;&#13;&#10;--------------------------------------&#13;&#10;Output variables&#13;&#10;--------------------------------------&#13;&#10;-) dRetcode&#13;&#10;   &lt; 0:&#13;&#10;      -1 ... TCP Client not ready&#13;&#10;      else ... OS TCP error code&#13;&#10;&#13;&#10;   &gt;=0:&#13;&#10;      dRetcode = udSize ... Sending data over TCP/IP successful" Name="SendTCP"/>
	FUNCTION SendTCP
		VAR_INPUT
			pData 	: ^void;
			udSize 	: UDINT;
			dSock 	: DINT;
			bDirect 	: DINT;
		END_VAR
		VAR_OUTPUT
			dRetcode 	: DINT;
		END_VAR;
				//! <Function Comment="Handles the Connection and Data receiving and sending" Name="CyclicCall"/>
	FUNCTION VIRTUAL GLOBAL CyclicCall;
				//! <Function Comment="This Method is called if Data is received (Overwrite it, to create a Request)" Name="Response"/>
	FUNCTION VIRTUAL GLOBAL Response
		VAR_INPUT
			pData 	: ^void;			//! <Variable Comment="Pointer to Data" Name="Response.pData"/>
			udSize 	: UDINT;			//! <Variable Comment="Size of Data" Name="Response.udSize"/>
			dSock 	: DINT;			//! <Variable Comment="Socketnumber" Name="Response.dSock"/>
		END_VAR;
				//! <Function Comment="Clear Send Buffer" Name="SENDbuffer_Clear"/>
	FUNCTION SENDbuffer_Clear
		VAR_INPUT
			pBuffer 	: ^_TX_RINGBUFFER;
		END_VAR;
				//! <Function Comment="Read Send Buffer" Name="SENDbuffer_Read"/>
	FUNCTION SENDbuffer_Read
		VAR_INPUT
			pBuffer 	: ^_TX_RINGBUFFER;
			pData 	: ^void;
			udSize 	: UDINT;
		END_VAR
		VAR_OUTPUT
			Retcode 	: DINT;
		END_VAR;
				//! <Function Comment="Send Data over TCP/IP" Name="SendData"/>
	FUNCTION VIRTUAL GLOBAL SendData
		VAR_INPUT
			pData 	: ^void;			//! <Variable Comment="Pointer to Data" Name="SendData.pData"/>
			udSize 	: UDINT;			//! <Variable Comment="Size of Data" Name="SendData.udSize"/>
			dSock 	: DINT;			//! <Variable Comment="Socket to which it should be send" Name="SendData.dSock"/>
			bDirect 	: BOOL;			//! <Variable Comment="0 ... Write it to Send Buffer and send it in next Cyclus&#13;&#10;1 ... Send it imidiatly" Name="SendData.bDirect"/>
		END_VAR
		VAR_OUTPUT
			dRetcode 	: DINT;			//! <Variable Comment="if bDirect is&#13;&#10;0: Size of Sended Data&#13;&#10;1: 0: Write to SendBuffer succesful&#13;&#10;   &lt;0: Write to SendBuffer faileed (see sError)" Name="SendData.dRetcode"/>
		END_VAR;
	
	FUNCTION Read_LSLOBJ_CRC32
		VAR_INPUT
			pCRC32 	: ^CHAR;
		END_VAR
		VAR_OUTPUT
			Retcode 	: DINT;
		END_VAR;
	
	FUNCTION Read_AP_TaskPeriod
		VAR_OUTPUT
			Retcode 	: DINT;
		END_VAR;
	
	FUNCTION AP_TaskCreate
		VAR_INPUT
			pTaskName 	: ^CHAR;
			pCallback 	: ^void;
		END_VAR
		VAR_OUTPUT
			Retcode 	: DINT;
		END_VAR;
	
	FUNCTION AP_TaskCallback
		VAR_INPUT
			Param0 	: ^void;
		END_VAR;
	
	FUNCTION GetMultiTaskErrorCode
		VAR_INPUT
			pErrTxt 	: ^CHAR;
		END_VAR;
	
	FUNCTION AP_SemaCreate
		VAR_INPUT
			pSemaName 	: ^CHAR;
			Index 	: DINT;
		END_VAR
		VAR_OUTPUT
			Retcode 	: DINT;
		END_VAR;
	
	FUNCTION AP_TaskDelay
		VAR_INPUT
			udTaskDelay 	: UDINT;
		END_VAR;
	
	FUNCTION SetMainSocketOptions
		VAR_OUTPUT
			Retcode 	: DINT;
		END_VAR;
	
	FUNCTION RingbufferReadEntry
		VAR_INPUT
			pBuffer 	: ^_TX_RINGBUFFER;
			pData 	: ^void;
			pSize 	: ^UDINT;
		END_VAR
		VAR_OUTPUT
			Retcode 	: DINT;
		END_VAR;
	
	FUNCTION RingbufferWriteEntry
		VAR_INPUT
			pBuffer 	: ^_TX_RINGBUFFER;
			pData 	: ^void;
			udSize 	: UDINT;
		END_VAR
		VAR_OUTPUT
			Retcode 	: DINT;
		END_VAR;
	
	FUNCTION AP_SemaWait
		VAR_INPUT
			SemaHandle 	: MT_SEMAHANDLE;
		END_VAR;
	
	FUNCTION AP_SemaSignal
		VAR_INPUT
			SemaHandle 	: MT_SEMAHANDLE;
		END_VAR;
	
	FUNCTION SetSocketOptions
		VAR_INPUT
			pConn 	: ^_CONNECTION;
		END_VAR
		VAR_OUTPUT
			Retcode 	: DINT;
		END_VAR;
	
	FUNCTION AddConnIntern
		VAR_INPUT
			dSocket 	: DINT;
			ppConn 	: ^pVoid;
		END_VAR
		VAR_OUTPUT
			Retcode 	: DINT;
		END_VAR;
	
	FUNCTION DelConnIntern
		VAR_INPUT
			dSocket 	: DINT;
		END_VAR
		VAR_OUTPUT
			Retcode 	: DINT;
		END_VAR;
				//! <Function Comment="method is called with socket informations of the connection sockets" Name="ConnSocketInfo"/>
	FUNCTION VIRTUAL GLOBAL ConnSocketInfo
		VAR_INPUT
			dSock 	: DINT;			//! <Variable Comment="socket number" Name="ConnSocketInfo.dSock"/>
			InfoPara1 	: DINT;			//! <Variable Comment="0 ... socket disconnected&#13;&#10;1 ... socket connected" Name="ConnSocketInfo.InfoPara1"/>
			InfoPara2 	: DINT;			//! <Variable Comment="InfoPara2 = 0" Name="ConnSocketInfo.InfoPara2"/>
		END_VAR;
				//! <Function Comment="method is called with socket error status of the connection sockets&#13;&#10;&#13;&#10;-) TCP error (callback: ErrorGroup = 0, ErrorCode = TCP error status)&#13;&#10;-) error code definition in lsl_st_tcp_user.h&#13;&#10;&#13;&#10;-)  internal error (callback: ErrorGroup = 1, ErrorCode = internal error status)&#13;&#10;-) -1: receive timeout (in case of timeout is set)" Name="ConnSocketError"/>
	FUNCTION VIRTUAL GLOBAL ConnSocketError
		VAR_INPUT
			dSock 	: DINT;			//! <Variable Comment="socket number" Name="ConnSocketError.dSock"/>
			FSM_TCP 	: _FSM_TCP_USER;			//! <Variable Comment="status of the state machine of the connection socket" Name="ConnSocketError.FSM_TCP"/>
			ErrGroup 	: DINT;			//! <Variable Comment="0 ... OS error (OS_TCP_USER)&#13;&#10;1 ... AP error (connection timeout)" Name="ConnSocketError.ErrGroup"/>
			ErrCode 	: DINT;			//! <Variable Comment="ErrGroup = 0 (OS error)&#13;&#10;ErrCode definition in lsl_st_tcp_user.h&#13;&#10;&#13;&#10;ErrGroup = 1 (AP error)&#13;&#10;ErrCode = -1 ... connection timeout&#13;&#10;" Name="ConnSocketError.ErrCode"/>
		END_VAR;
				//! <Function Comment="method is called with socket informations of the main socket" Name="MainSocketError"/>
	FUNCTION VIRTUAL GLOBAL MainSocketError
		VAR_INPUT
			FSM_TCP 	: _FSM_TCP_USER;			//! <Variable Comment="status of the state machine of the main socket" Name="MainSocketError.FSM_TCP"/>
			ErrGroup 	: DINT;			//! <Variable Comment="0 ... OS error (OS_TCP_USER)" Name="MainSocketError.ErrGroup"/>
			ErrorCode 	: DINT;			//! <Variable Comment="ErrGroup = 0 (OS error)&#13;&#10;ErrCode definition in lsl_st_tcp_user.h&#13;&#10;" Name="MainSocketError.ErrorCode"/>
		END_VAR;
				//! <Function Comment="Method to set main parameters. Main parameters will be used for every new connection." Name="SetMainParameter"/>
	FUNCTION VIRTUAL GLOBAL SetMainParameter
		VAR_INPUT
			Cmd 	: DINT;			//! <Variable Comment="0 ... (TCPSVR_CMD_SETSOCKOPT) socket option&#13;&#10;1 ... (TCPSVR_CMD_TASKPRIO) task priority of async task (in case of using object in async task)&#13;&#10;2 ... (TCPSVR_CMD_KEEPALIVEPARA) keep alive parameter&#13;&#10;3 ... (TCPSVR_CMD_CLOSE_SOCKET_TYPE) close socket type" Name="SetMainParameter.Cmd"/>
			SubCmd 	: DINT;			//! <Variable Comment="Cmd = 0 (socket option)&#13;&#10;-) SubCmd = 0: TCPSVR_SOCKOPT_NAGLE ... activate/deactivate nagle algorithm&#13;&#10;-) SubCmd = 1: TCPSVR_SOCKOPT_KEEPALIVE ... activate/deactivate keepalive message&#13;&#10;-) SubCmd = 2: TCPSVR_SOCKOPT_DELAYEDACK ... activate/deactivate delayed acknowledge packet&#13;&#10;-) SubCmd = 3: TCPSVR_SOCKOPT_REUSEADDR ... activate/deactivate option reuse address&#13;&#10;&#13;&#10;Cmd = 1 (task priority of async task)&#13;&#10;-) SubCmd = 0: task priority of async task&#13;&#10;&#13;&#10;Cmd = 2 (keep alive parameter)&#13;&#10;-) SubCmd = 0: TCPSVR_KEEPALIVE_KEEPIDLE&#13;&#10;-) SubCmd = 1: TCPSVR_KEEPALIVE_KEEPINTVL&#13;&#10;-) SubCmd = 2: TCPSVR_KEEPALIVE_KEEPCNT&#13;&#10;&#13;&#10;Cmd = 3 (close soccket type)&#13;&#10;-) SubCmd = 0: TCPSVR_CLOSE_SOCKET_TYPE" Name="SetMainParameter.SubCmd"/>
			ParaValue 	: DINT;			//! <Variable Comment="Cmd = 0 (socket option)&#13;&#10;-) 1 ... Activate option&#13;&#10;-) 2 ... Deactivate option&#13;&#10;&#13;&#10;Cmd = 1 (task priority of async task)&#13;&#10;-) task priority 1-14" Name="SetMainParameter.ParaValue"/>
		END_VAR
		VAR_OUTPUT
			Retcode 	: DINT;			//! <Variable Comment="0 ... success&#13;&#10;-10 ... invalid CMD&#13;&#10;-11 ... invalid SubCMD&#13;&#10;-12 ... error set task priority - task already created&#13;&#10;-90 ... object not initialized (initialization in first Init() call)" Name="SetMainParameter.Retcode"/>
		END_VAR;
				//! <Function Comment="method to set connection socket parameters" Name="SetSocketParameter"/>
	FUNCTION VIRTUAL GLOBAL SetSocketParameter
		VAR_INPUT
			dSock 	: DINT;			//! <Variable Comment="socket number" Name="SetSocketParameter.dSock"/>
			Cmd 	: DINT;			//! <Variable Comment="0 ... socket option" Name="SetSocketParameter.Cmd"/>
			SubCmd 	: DINT;			//! <Variable Comment="Cmd = 0 (socket option)&#13;&#10;-) SubCmd = 0: TCPCLT_SOCKOPT_NAGLE... activate/deactivate nagle algorithm&#13;&#10;-) SubCmd = 1: TCPCLT_SOCKOPT_KEEPALIVE... activate/deactivate keepalive message&#13;&#10;-) SubCmd = 2: TCPCLT_SOCKOPT_DELAYEDACK... activate/deactivate delayed acknowledge packet&#13;&#10;-) SubCmd = 3: TCP_SVR_SUB_CMD_SOCK_OPT_REUSE_ADDR activate/deactivate option reuse address" Name="SetSocketParameter.SubCmd"/>
			ParaValue 	: DINT;			//! <Variable Comment="Cmd = 0 (socket option)&#13;&#10;-) 1 ... Activate option&#13;&#10;-) 2 ... Deactivate option" Name="SetSocketParameter.ParaValue"/>
		END_VAR
		VAR_OUTPUT
			Retcode 	: DINT;			//! <Variable Comment="0 ... success&#13;&#10;-1 ... invalid socket number&#13;&#10;-10 ... invalid CMD&#13;&#10;-11 ... invalid SubCMD" Name="SetSocketParameter.Retcode"/>
		END_VAR;
				//! <Function Comment="method to read main parameters" Name="ReadMainParameter"/>
	FUNCTION VIRTUAL GLOBAL ReadMainParameter
		VAR_INPUT
			Cmd 	: DINT;			//! <Variable Comment="0 ... socket option&#13;&#10;1 ... task priority of async task (in case of using object in async task)" Name="ReadMainParameter.Cmd"/>
			SubCmd 	: DINT;			//! <Variable Comment="Cmd = 0 (socket option)&#13;&#10;-) SubCmd = 0: TCPCLT_SOCKOPT_NAGLE... status option nagle algorithm&#13;&#10;-) SubCmd = 1: TCPCLT_SOCKOPT_KEEPALIVE... status option keepalive message&#13;&#10;-) SubCmd = 2: TCPCLT_SOCKOPT_DELAYEDACK... status option delayed acknowledge packet&#13;&#10;-) SubCmd = 3: TCP_SVR_SUB_CMD_SOCK_OPT_REUSE_ADDR status option option reuse address&#13;&#10;&#13;&#10;Cmd = 1 (task priority of async task)&#13;&#10;-) SubCmd = 0: task priority of async task" Name="ReadMainParameter.SubCmd"/>
			pParaValue 	: ^DINT;			//! <Variable Comment="pointer to target parameter value" Name="ReadMainParameter.pParaValue"/>
		END_VAR
		VAR_OUTPUT
			Retcode 	: DINT;			//! <Variable Comment="0 ... success&#13;&#10;-10 ... invalid CMD&#13;&#10;-11 ... invalid SubCMD&#13;&#10;-90 ... object not initialized (initialization in first Init() call)" Name="ReadMainParameter.Retcode"/>
		END_VAR;
				//! <Function Comment="method to read connection socket parameters" Name="ReadSocketParameter"/>
	FUNCTION VIRTUAL GLOBAL ReadSocketParameter
		VAR_INPUT
			dSock 	: DINT;			//! <Variable Comment="socket number" Name="ReadSocketParameter.dSock"/>
			Cmd 	: DINT;			//! <Variable Comment="0 ... socket option" Name="ReadSocketParameter.Cmd"/>
			SubCmd 	: DINT;			//! <Variable Comment="Cmd = 0 (socket option)&#13;&#10;-) SubCmd = 0: TCPCLT_SOCKOPT_NAGLE... status option nagle algorithm&#13;&#10;-) SubCmd = 1: TCPCLT_SOCKOPT_KEEPALIVE... status option keepalive message&#13;&#10;-) SubCmd = 2: TCPCLT_SOCKOPT_DELAYEDACK... status option delayed acknowledge packet&#13;&#10;-) SubCmd = 3: TCP_SVR_SUB_CMD_SOCK_OPT_REUSE_ADDR status option option reuse address" Name="ReadSocketParameter.SubCmd"/>
			pParaValue 	: ^DINT;			//! <Variable Comment="pointer to target parameter value" Name="ReadSocketParameter.pParaValue"/>
		END_VAR
		VAR_OUTPUT
			Retcode 	: DINT;			//! <Variable Comment="0 ... success&#13;&#10;-1 ... invalid socket number&#13;&#10;-10 ... invalid CMD&#13;&#10;-11 ... invalid SubCMD" Name="ReadSocketParameter.Retcode"/>
		END_VAR;
	
	FUNCTION CheckSocketValid
		VAR_INPUT
			dSock 	: DINT;
			ppConn 	: ^pVoid;
		END_VAR
		VAR_OUTPUT
			Retcode 	: BOOL;
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

#pragma using _CheckSum
#pragma using String
#pragma usingLtd _MultiTask
#pragma usingLtd _StdLib
#pragma usingLtd _TaskObjectControl
#pragma usingLtd SigCLib


//}}LSL_DECLARATION


FUNCTION GLOBAL TAB _TCPIP_SERVER::@CT_
0$UINT,
2#0100000000000000$UINT, //TY__TCPIP_SERVER
1$UINT, 36$UINT, (SIZEOF(::_TCPIP_SERVER))$UINT, 
5$UINT, 13$UINT, 0$UINT, 
TO_UDINT(26234884), "_TCPIP_SERVER", //Class
TO_UDINT(0), 0, 0$UINT, 0$UINT, //Baseclass
//Servers:
(::_TCPIP_SERVER.sControl.pMeth)$UINT, _CH_CMD$UINT, 2#0000000000000000$UINT, TO_UDINT(4051248739), "sControl", 
(::_TCPIP_SERVER.sError.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1467175462), "sError", 
(::_TCPIP_SERVER.TaskName.pMeth)$UINT, _CH_SVR$UINT, 2#0000000001000000$UINT, TO_UDINT(3136881463), "TaskName", 
(::_TCPIP_SERVER.SemaName01.pMeth)$UINT, _CH_SVR$UINT, 2#0000000001000000$UINT, TO_UDINT(3023984995), "SemaName01", 
(::_TCPIP_SERVER.SemaName02.pMeth)$UINT, _CH_SVR$UINT, 2#0000000001000000$UINT, TO_UDINT(758581465), "SemaName02", 
//Clients:
(::_TCPIP_SERVER.cPort.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(2368846560), "cPort", 
(::_TCPIP_SERVER.cTimeout.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(3780660881), "cTimeout", 
(::_TCPIP_SERVER.cSizeOfTXBuffer.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(1870367421), "cSizeOfTXBuffer", 
(::_TCPIP_SERVER.cMaxConnections.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(4178062980), "cMaxConnections", 
(::_TCPIP_SERVER.cConfig.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(2101344707), "cConfig", 
(::_TCPIP_SERVER.co_StdLib.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(3072335391), "co_StdLib", TO_UDINT(3689364044), "_StdLib", 0$UINT, 0$UINT, 
(::_TCPIP_SERVER.co_MultiTask.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(123997224), "co_MultiTask", TO_UDINT(2641766936), "_MultiTask", 1$UINT, 1$UINT, 
(::_TCPIP_SERVER.co_SigCLib.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(2195423801), "co_SigCLib", TO_UDINT(77440046), "SigCLib", 0$UINT, 24$UINT, 
(::_TCPIP_SERVER.CheckSum.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(408699862), "CheckSum", TO_UDINT(916194998), "_CheckSum", 1$UINT, 0$UINT, 
(::_TCPIP_SERVER.StrTaskName.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(3109787989), "StrTaskName", TO_UDINT(1850111279), "String", 1$UINT, 10$UINT, 
(::_TCPIP_SERVER.StrSemaName01.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(4079954366), "StrSemaName01", TO_UDINT(1850111279), "String", 1$UINT, 10$UINT, 
(::_TCPIP_SERVER.StrSemaName02.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(1780905988), "StrSemaName02", TO_UDINT(1850111279), "String", 1$UINT, 10$UINT, 
(::_TCPIP_SERVER.co_Task.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(3916282292), "co_Task", TO_UDINT(1584830088), "_TaskObjectControl", 1$UINT, 1$UINT, 
END_FUNCTION


#define USER_CNT__TCPIP_SERVER 10

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT__TCPIP_SERVER] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION _TCPIP_SERVER::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
	END_VAR

	//Command Methods
	InitCmdTable (nCmd := nSTDCMD + USER_CNT__TCPIP_SERVER, pCmd := #vmt.CmdTable);
	vmt.CmdTable.Init		:= #Init();
	vmt.CmdTable.CyWork		:= #CyWork();
#pragma warning (disable : 74)
	vmt.UserFcts[0]		:= #CyclicCall();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[1]		:= #Response();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[2]		:= #SendData();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[3]		:= #ConnSocketInfo();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[4]		:= #ConnSocketError();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[5]		:= #MainSocketError();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[6]		:= #SetMainParameter();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[7]		:= #SetSocketParameter();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[8]		:= #ReadMainParameter();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[9]		:= #ReadSocketParameter();

#pragma warning (default : 74)
	sControl.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF sControl.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;

END_FUNCTION

//{{LSL_IMPLEMENTATION

FUNCTION VIRTUAL GLOBAL _TCPIP_SERVER::Init
VAR
	i                     : USINT;
  udStrLen              : UDINT;
  dRet                  : DINT;
  szCRC32               : ARRAY [0..15] OF CHAR;
  szTaskName            : ARRAY [0..63] OF CHAR;
  szErrCode             : ARRAY [0..31] OF CHAR;
  szSemaName            : ARRAY [0..63] OF CHAR;
END_VAR

  // -------------------------------------------------------------------------------------------------------
  // -------------------------------------------------------------------------------------------------------
  // - F I R S T   I N I T   R U N   ( M A I N   I N I T )
  // -------------------------------------------------------------------------------------------------------
  // -------------------------------------------------------------------------------------------------------
  if (usInit = 0) then

    // -------------------------------------------------------------------------------------
    // -------------------------------------------------------------------------------------
    // - SET DEFAULT SETTINGS
    // -------------------------------------------------------------------------------------
    // -------------------------------------------------------------------------------------
    MainSockOpt.Nagle      := true;
    MainSockOpt.KeepAlive  := false;
    MainSockOpt.DelayedAck := true;
    MainSockOpt.ReuseAddr  := true;

    AP_TaskPriority         := AP_TASK_PRIORITY_DEFAULT;

    KeepAlivePara.keepIDLE  := KEEPALIVE_INTERVAL_DEFAULT;
    KeepAlivePara.keepINTVL := KEEPALIVE_RETRYTIME_DEFAULT;
    KeepAlivePara.keepCNT   := KEEPALIVE_RETRYCNT_DEFUALT;

    CloseSocketType         := CLOSE_SOCKET_TYPE_DEFAULT;

    // -------------------------------------------------------------------------------------
    // -------------------------------------------------------------------------------------
    // - READ CONFIGURATION PARAMETER
    // -------------------------------------------------------------------------------------
    // -------------------------------------------------------------------------------------
    cPort           := cPort.Read();
    cConfig         := cConfig.Read();
    cTimeout        := cTimeout.Read();
    cMaxConnections := cMaxConnections.Read();
    cSizeOfTXBuffer := cSizeOfTXBuffer.Read();


    // -------------------------------------------------------------------------------------
    // -------------------------------------------------------------------------------------
    // - CHECK GENERAL PARAMETER CONFIGURATION
    // -------------------------------------------------------------------------------------
    // -------------------------------------------------------------------------------------
    if cMaxConnections <= 0 then
      cMaxConnections := 16;
    elsif cMaxConnections > 16 then
      cMaxConnections := 16;
    end_if;
    MaxConn := cMaxConnections;

    if (cSizeOfTXBuffer = 0) then
      cSizeOfTXBuffer := 1024;
    end_if;


    // -------------------------------------------------------------------------------------
    // -------------------------------------------------------------------------------------
    // - READ OS INFORMATION
    // -------------------------------------------------------------------------------------
    // -------------------------------------------------------------------------------------
    if (_RtOSVersion >= OS_VERSION_MIN_SALAMANDER) then
      bdStatus.SalamanderOS := true;
    end_if;


    // -------------------------------------------------------------------------------------
    // -------------------------------------------------------------------------------------
    // - READ OS CIL INTERFACE INFORMATION
    // -------------------------------------------------------------------------------------
    // -------------------------------------------------------------------------------------
    if OS_CILGET("TCP_USER", #lsl_tcp_user) then 
      lsl_tcp_user := NIL;
    else
      bdStatus.CIL_tcp_user := true;
    end_if;

    if OS_CILGET("SSL_USER", #lsl_ssl_user) then 
      lsl_ssl_user := NIL;
    else
      bdStatus.CIL_ssl_user := true;
    end_if;

    if OS_CILGET("SALAMANDERDEBUG", #pCIL_DEBUG) then
      pCIL_DEBUG := NIL;
    else
      bdStatus.CIL_debug := true;
    end_if;


    // -------------------------------------------------------------------------------------
    // -------------------------------------------------------------------------------------
    // - ALLOCATE MEMORY FOR RECEIVE BUFFER
    // -------------------------------------------------------------------------------------
    // -------------------------------------------------------------------------------------
    RECVbuffer.pData := co_StdLib.Malloc(size := to_UDINT(cSizeOfTXBuffer));
    if (RECVbuffer.pData = NIL) then
      bdStatus.ErrMem := true;
      sError := -99;
    end_if;


    // -------------------------------------------------------------------------------------
    // -------------------------------------------------------------------------------------
    // - ALLOCATE MEMORY FOR SEND BUFFER
    // -------------------------------------------------------------------------------------
    // -------------------------------------------------------------------------------------
    for i := 0 to ((MaxConn-1)$USINT) do

      SocketArray[i].dSocket     := 0;    
      SocketArray[i].udTimeStamp := 0;
      SocketArray[i].FSM_TCP     := _STATE_IDLE;
      SocketArray[i].pNextConn   := NIL;
      SocketArray[i].SendBuffer.pMem := co_StdLib.Malloc(size:=(cSizeOfTXBuffer + (10 *sizeof(_BUFFER_HEADER)))); // allocate memory for Ringbuffer (+ 10 * size of Buffer-Header to have enogh Memory)

      if SocketArray[i].SendBuffer.pMem = NIL then
        bdStatus.ErrMem := true;
        sError := -99;
      else
        SocketArray[i].SendBuffer.pRead  := SocketArray[i].SendBuffer.pMem$^USINT;
        SocketArray[i].SendBuffer.pWrite := SocketArray[i].SendBuffer.pMem$^USINT;
        SocketArray[i].SendBuffer.udSize := cSizeOfTXBuffer;
        SocketArray[i].SendBuffer.udUsed := 0;
      end_if;

      SocketArray[i].pBufferWaitForSendig$^void := co_StdLib.Malloc(size:=cSizeOfTXBuffer); //allocate memory for Sendbuffer

      if SocketArray[i].pBufferWaitForSendig = NIL then
        bdStatus.ErrMem := true;
        sError := -99;
      end_if;

    end_for;

  end_if;

  usInit += 1;


  // -------------------------------------------------------------------------------------------------------
  // -------------------------------------------------------------------------------------------------------
  // - F I R S T S C A N
  // -------------------------------------------------------------------------------------------------------
  // -------------------------------------------------------------------------------------------------------
  if (_firstscan) then 

    // -------------------------------------------------------------------------------------
    // -------------------------------------------------------------------------------------
    // - READ THE LASAL OBJECT CRC32
    // -------------------------------------------------------------------------------------
    // -------------------------------------------------------------------------------------
    dRet := Read_LSLOBJ_CRC32(#szCRC32[0]);
    case dRet of
      (*==================================================================*)
      TCP_SVR_NO_ERROR: // - NO ERROR
      (*==================================================================*)
        bdStatus.LSLOBJ_CRC32 := true;
      (*==================================================================*)
      else // - ERROR WHILE READING THE LASAL OBJECT CRC32 (USE THIS PTR)
      (*==================================================================*)
        co_SigCLib.IToA(this$DINT, #szCRC32[0], 0x10);
    end_case;


    // -------------------------------------------------------------------------------------
    // -------------------------------------------------------------------------------------
    // - MUTEX CONNECTION INIT
    // -------------------------------------------------------------------------------------
    // -------------------------------------------------------------------------------------
    co_SigCLib.StrCpy(#szSemaName[0], "USR_SEMA_");
    co_SigCLib.StrCat(#szSemaName[0], #szCRC32[0]);
    co_SigCLib.StrCat(#szSemaName[0], "_01");
    dRet := AP_SemaCreate(#szSemaName[4], 0);
    if (dRet = TCP_SVR_NO_ERROR) then
      bdStatus.Sema01 := true;
    else
      bdStatus.ErrSema01 := true;
      GetMultiTaskErrorCode(#szErrCode[0]);
      co_SigCLib.StrCpy(#szTaskName[0], "SEMA ERR: CREATE SEMA (");
      co_SigCLib.StrCat(#szTaskName[0], #szErrCode[0]);
      co_SigCLib.StrCat(#szTaskName[0], ")");
    end_if;

    udStrLen := co_SigCLib.StrLen(#szSemaName[0]);
    StrSemaName01.WriteDataOff(udStrLen, 0, #szSemaName[0]);


    // -------------------------------------------------------------------------------------
    // -------------------------------------------------------------------------------------
    // - MUTEX SOCKET OPTION INIT
    // -------------------------------------------------------------------------------------
    // -------------------------------------------------------------------------------------
    co_SigCLib.StrCpy(#szSemaName[0], "USR_SEMA_");
    co_SigCLib.StrCat(#szSemaName[0], #szCRC32[0]);
    co_SigCLib.StrCat(#szSemaName[0], "_02");
    dRet := AP_SemaCreate(#szSemaName[4], 1);
    if (dRet = TCP_SVR_NO_ERROR) then
      bdStatus.Sema01 := true;
    else
      bdStatus.ErrSema01 := true;
      GetMultiTaskErrorCode(#szErrCode[0]);
      co_SigCLib.StrCpy(#szTaskName[0], "SEMA ERR: CREATE SEMA (");
      co_SigCLib.StrCat(#szTaskName[0], #szErrCode[0]);
      co_SigCLib.StrCat(#szTaskName[0], ")");
    end_if;

    udStrLen := co_SigCLib.StrLen(#szSemaName[0]);
    StrSemaName02.WriteDataOff(udStrLen, 0, #szSemaName[0]);


    // -------------------------------------------------------------------------------------
    // -------------------------------------------------------------------------------------
    // - TASK INIT
    // -------------------------------------------------------------------------------------
    // -------------------------------------------------------------------------------------
    udTimeAccept := 500;
    
    dRet := Read_AP_TaskPeriod();
    if (dRet = TCP_SVR_NO_ERROR) then
      bdStatus.AP_TaskPeriod := true;
      if (cConfig AND 0x1) then
        // - CYCLIC CALL IN PARALLEL TASK
        co_SigCLib.StrCpy(#szTaskName[0], "USR_TASK_");
        co_SigCLib.StrCat(#szTaskName[0], #szCRC32[0]);
        dRet := AP_TaskCreate(#szTaskName[4], #AP_TaskCallback());
        if (dRet = TCP_SVR_NO_ERROR) then
          bdStatus.AsyncTask := true;
        else
          bdStatus.ErrAsyncTask := true;
          GetMultiTaskErrorCode(#szErrCode[0]);
          co_SigCLib.StrCpy(#szTaskName[0], "TASK ERR: CREATE TASK (");
          co_SigCLib.StrCat(#szTaskName[0], #szErrCode[0]);
          co_SigCLib.StrCat(#szTaskName[0], ")");
        end_if;
      else
        // - CYCLIC CALL IN CYCLIC TASK
        bdStatus.CyclicTask := true;
        co_SigCLib.StrCpy(#szTaskName[0], "CyclicTask");
      end_if;

      // ---------------------------------------------------------------------
      // - ADJUST TIME BETWEEN ACCEPT STEPS FOR COMPATIBILITY
      // ---------------------------------------------------------------------
      if (bdStatus.SalamanderOS = true) then
        udTimeAccept := AP_TaskTime / 1000;
        if (udTimeAccept = 0) then
          udTimeAccept := 1;
        end_if;
      else
        udTimeAccept := AP_TaskTime;
      end_if;
      udTimeAccept := udTimeAccept * 4;

    else

      case dRet of
        (*==================================================================*)
        TCP_SVR_ERR_TASK_TIME_NO_APP:
        (*==================================================================*)
          co_SigCLib.StrCpy(#szTaskName[0], "TASK ERR: LSLOBJ (NO APPLICATION)");
        (*==================================================================*)
        TCP_SVR_ERR_TASK_TIME_WRONG_TASK_TYPE:
        (*==================================================================*)
          co_SigCLib.StrCpy(#szTaskName[0], "TASK ERR: LSLOBJ (WRONG TASK TYPE)");
        (*==================================================================*)
        TCP_SVR_ERR_TASK_TIME_OBJ_NOT_FOUND:
        (*==================================================================*)
          co_SigCLib.StrCpy(#szTaskName[0], "task deactivated");
        (*==================================================================*)
        else
        (*==================================================================*)
          co_SigCLib.StrCpy(#szTaskName[0], "TASK ERR: LSLOBJ (UNKNOWN ERROR)");
      end_case;

    end_if;

    udStrLen := co_SigCLib.StrLen(#szTaskName[0]);
    StrTaskName.WriteDataOff(udStrLen, 0, #szTaskName[0]);

  end_if;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL _TCPIP_SERVER::CyWork
VAR_INPUT
  EAX 	: UDINT;
END_VAR
VAR_OUTPUT
  state (EAX) 	: UDINT;
END_VAR

  if (bdStatus.CyclicTask = true) then
    CyclicCall();
  end_if;

	state := READY;

END_FUNCTION

FUNCTION VIRTUAL GLOBAL _TCPIP_SERVER::CyclicCall
VAR
  dBytes        : DINT;
  i             : DINT;
  dRet          : DINT;
  dAccSock      : DINT;
  pConn         : ^_CONNECTION;
END_VAR

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//++                                                                                        ++
//++    this finite state machine is used for the main TCP/IP connection:                   ++
//++                                                                                        ++
//++    -> allocate sockets                                                                 ++
//++    -> build a connection to a specified socket                                         ++
//++    -> receive data from Client                                                         ++
//++    -> disable receives and sends on socket                                             ++
//++    -> close socket                                                                     ++
//++                                                                                        ++
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  case FSM_TCP of

    //**********************************************************************************
    _STATE_INIT_SERVER: // init state ... check if interface is present
    //**********************************************************************************
      if (bdStatus.ErrAsyncTask = true) then
        sControl := _STATE_ERROR_CREATING_TASK;
      elsif (bdStatus.ErrSema01 = true) | (bdStatus.ErrSema02 = true) then
        sControl := _STATE_ERROR_CREATING_MUTEX;
      elsif (bdStatus.ErrMem = true) then
        sControl := _STATE_ERROR_ALLOCATING_MEMORY;
      else
        if lsl_tcp_user <> NIL then
          FSM_TCP := _STATE_IDLE;
        else
          sError := -1;
        end_if;
      end_if;

    //**********************************************************************************
    _STATE_IDLE: // idle state ... wait for start server
    //**********************************************************************************
      FSM_TCP := _STATE_MAIN_SOCK;
      ActConn := 0;

    //**********************************************************************************
    _STATE_MAIN_SOCK: // allocate main socket
    //**********************************************************************************
      dMainSock := OS_TCP_USER_SOCKET();
      if (dMainSock < 0) then
        MainSocketError(FSM_TCP, TCP_SVR_ERR_GROUP_OS, dMainSock);
        FSM_TCP := _STATE_ERROR;
      else
        dRet := SetMainSocketOptions();
        if (dRet = TCP_SVR_NO_ERROR) then
          FSM_TCP := _STATE_LISTEN;
        else
          MainSocketError(FSM_TCP, TCP_SVR_ERR_GROUP_OS, dRet);
          sError := -12;
          FSM_TCP := _STATE_CLOSE_MAIN_SOCK;
        end_if;
      end_if;

    //**********************************************************************************
    _STATE_LISTEN: // listen for an incoming connection
    //**********************************************************************************
      dRet := OS_TCP_USER_LISTEN(dMainSock, to_UDINT(cPort), to_udint(cMaxConnections));
      if (dRet < 0) then
        if ((dRet = TCP_INVALID_SOCKET) | (dRet = TCP_INVALID_SOCKNUM)) then
          MainSocketError(FSM_TCP, TCP_SVR_ERR_GROUP_OS, dRet);
          FSM_TCP := _STATE_CLOSE_MAIN_SOCK;
        end_if;
      else
        FSM_TCP := _STATE_ACCEPT;
      end_if;

    //**********************************************************************************
    _STATE_ACCEPT: // accept a connection from any remote host
    //**********************************************************************************
      if (ActConn < MaxConn) then
        dNewSock := dAccSock := OS_TCP_USER_ACCEPT(dMainSock, 0);
        if (dAccSock < 0) & (dAccSock <> TCP_NOT_READY) then
          MainSocketError(FSM_TCP, TCP_SVR_ERR_GROUP_OS, dAccSock);
          FSM_TCP := _STATE_CLOSE_SOCK;
        elsif (dAccSock >= 0) then
          dRet := AddConnIntern(dAccSock, (#pConn)$^pVoid);
          if (dRet = TCP_SVR_NO_ERROR) & (pConn <> NIL) then
            dRet := SetSocketOptions(pConn);
            if (dRet = TCP_SVR_NO_ERROR) then
              FSM_TCP := _STATE_RECV;
              sError  := 0;
            else
              pConn^.FSM_TCP := _STATE_SHUTDOWN;
              sError := -12;
              FSM_TCP := _STATE_RECV;
            end_if;
          else
            FSM_TCP := _STATE_RECV;
          end_if;
        elsif (ActConn > 0) then
          FSM_TCP     := _STATE_RECV;
          sError      := 0;
          RECVCounter := 0;
        end_if;
      else
        FSM_TCP := _STATE_RECV;
        RECVCounter := 0;
      end_if;

    //**********************************************************************************
    _STATE_RECV: // general send and receive state
    //**********************************************************************************
      case pActConn^.FSM_TCP of

        (*===================================================================*)
        _STATE_RECV: // - RECEIVE DATA
        (*===================================================================*)
          dNewSock := pActConn^.dSocket;
          if (pActConn^.bdSettings.SockOptChanged = true) then
            pActConn^.FSM_TCP := _STATE_CONN_SOCK_OPT;
          else
            dBytes := OS_TCP_USER_NREAD_AVAILABLE(pActConn^.dSocket);
            if (dBytes < 0) then
              if (dBytes <> TCP_NOT_READY) then
                ConnSocketError(pActConn^.dSocket, pActConn^.FSM_TCP, TCP_SVR_ERR_GROUP_OS, dBytes);
                pActConn^.FSM_TCP := _STATE_SHUTDOWN;
                sError := -1;
              else
                if (cTimeOut > 0) then
                  if ((ops.tAbsolute - pActConn^.udTimeStamp) > to_UDINT(cTimeOut)) then
                    ConnSocketError(pActConn^.dSocket, pActConn^.FSM_TCP, TCP_SVR_ERR_GROUP_AP, TCP_SVR_ERR_CODE_AP_TIMEOUT);
                    pActConn^.FSM_TCP := _STATE_SHUTDOWN; 
                    sError := -2;
                  end_if;
                end_if;
              end_if;
            else
              if (dBytes > cSizeOfTXBuffer$DINT) then
                dBytes := cSizeOfTXBuffer$DINT;
              end_if;
              RECVbuffer.udSize := dBytes$UDINT;

              dRet := OS_TCP_USER_RECV(pActConn^.dSocket, RECVbuffer.pData$^CHAR, dBytes$UDINT, 0, 0);
              if (dRet = TCP_SOCK_NOT_CONNECTED) then
                ConnSocketError(pActConn^.dSocket, pActConn^.FSM_TCP, TCP_SVR_ERR_GROUP_OS, dRet);
                pActConn^.FSM_TCP := _STATE_SHUTDOWN;
                sError := -3;
              elsif (dRet <= 0) & (dRet <> TCP_NOT_READY) then
                ConnSocketError(pActConn^.dSocket, pActConn^.FSM_TCP, TCP_SVR_ERR_GROUP_OS, dRet);
                pActConn^.FSM_TCP := _STATE_SHUTDOWN;
                sError := -1;
              else
                Response(RECVbuffer.pData, RECVbuffer.udSize, pActConn^.dSocket);
                if (cTimeOut > 0) then
                  pActConn^.udTimeStamp := ops.tAbsolute;
                end_if;        
              end_if;
            end_if;

            if (pActConn^.FSM_TCP = _STATE_RECV) then
              if pActConn^.BufferHeader.DataSize > 0 then
                pActConn^.FSM_TCP := _STATE_SEND;
              elsif pActConn^.SendBuffer.udUsed > sizeof(_BUFFER_HEADER) then
                pActConn^.pBufferWaitForSendingHelp := pActConn^.pBufferWaitForSendig;
                //pActConn^.FSM_TCP := _STATE_READ_RINGBUFFER;
                pActConn^.FSM_TCP := _STATE_SEND;
              end_if;
            end_if;
          end_if;

        (*===================================================================*)
        _STATE_CONN_SOCK_OPT: // set socket options
        (*===================================================================*)
          dRet := SetSocketOptions(pActConn);
          if (dRet = TCP_SVR_NO_ERROR) then
            pActConn^.FSM_TCP := _STATE_RECV;
          else
            pActConn^.FSM_TCP := _STATE_SHUTDOWN;
          end_if;

        (*===================================================================*)
        _STATE_READ_RINGBUFFER:
        (*===================================================================*)
          if (sError <> -11) then
            dRet := RingbufferReadEntry(#pActConn^.SendBuffer, pActConn^.pBufferWaitForSendig, #pActConn^.BufferHeader.DataSize);
            if (pActConn^.BufferHeader.DataSize > 0) then
              pActConn^.pBufferWaitForSendingHelp := pActConn^.pBufferWaitForSendig;
              pActConn^.FSM_TCP := _STATE_SEND;
            else
              pActConn^.FSM_TCP := _STATE_RECV;
            end_if;
          else
            pActConn^.FSM_TCP := _STATE_RECV;
          end_if;

        (*===================================================================*)
        _STATE_SEND:
        (*===================================================================*)
          if (sError <> -11) then
            if (pActConn^.BufferHeader.DataSize = 0) then
              dRet := RingbufferReadEntry(#pActConn^.SendBuffer, pActConn^.pBufferWaitForSendig, #pActConn^.BufferHeader.DataSize);
              pActConn^.pBufferWaitForSendingHelp := pActConn^.pBufferWaitForSendig;
            end_if;
            if (pActConn^.BufferHeader.DataSize > 0) then
              dRet := SendTCP(pActConn^.pBufferWaitForSendingHelp, pActConn^.BufferHeader.DataSize, pActConn^.dSocket, false);
              if (dRet >= 0) then
                pActConn^.BufferHeader.DataSize -= dRet$UDINT;
                pActConn^.pBufferWaitForSendingHelp += dRet;
                if (pActConn^.BufferHeader.DataSize <= 0) then
                  pActConn^.FSM_TCP := _STATE_RECV;
                  pActConn^.pBufferWaitForSendingHelp := pActConn^.pBufferWaitForSendig;
                else
                  bdStatus.InhibNextConn := true;
                end_if;
              else
                ConnSocketError(pActConn^.dSocket, pActConn^.FSM_TCP, TCP_SVR_ERR_GROUP_OS, dRet);
                pActConn^.FSM_TCP := _STATE_RECV;
                sError := -6;
              end_if;
            else
              pActConn^.FSM_TCP := _STATE_RECV;
            end_if;
          else
            pActConn^.FSM_TCP := _STATE_RECV;
          end_if;

        (*===================================================================*)
        _STATE_SHUTDOWN:
        (*===================================================================*)
          OS_TCP_USER_CLOSESOCKET(pActConn^.dSocket, pActConn^.CloseSocketType);
          pActConn^.FSM_TCP := _STATE_DEL_CONNECTION;

        (*===================================================================*)
        _STATE_DEL_CONNECTION:
        (*===================================================================*)          
          DelConnIntern(pActConn^.dSocket);
          dNewSock := 0;

        (*===================================================================*)
        else // INAVLID CONNECTION STATE
        (*===================================================================*)          
          pActConn^.FSM_TCP := _STATE_RECV;

      end_case;

      if (ActConn = 0) then
        FSM_TCP := _STATE_ACCEPT;
      else
        if (bdStatus.InhibNextConn = false) then
          pActConn := pActConn^.pNextConn;
          if ((ops.tAbsolute - udTimeStamp) >= udTimeAccept) then
            FSM_TCP := _STATE_ACCEPT;
            udTimeStamp := ops.tAbsolute;
          end_if;
        end_if;
        bdStatus.InhibNextConn := false;
      end_if;

    //**********************************************************************************
    _STATE_CLOSE_SOCK: // close all sockets
    //**********************************************************************************
      for i := 0 to (MaxConn-1) do
        if (SocketArray[i].dSocket <> 0) then
          OS_TCP_USER_CLOSESOCKET(SocketArray[i].dSocket, SocketArray[i].CloseSocketType);
          SocketArray[i].dSocket   := 0;
          SocketArray[i].FSM_TCP   := _STATE_IDLE;
          SocketArray[i].pNextConn := NIL;
        end_if;
      end_for;
      dNewSock := 0;
      ActConn := 0;
      FSM_TCP := _STATE_CLOSE_MAIN_SOCK; 

    //**********************************************************************************
    _STATE_CLOSE_MAIN_SOCK: // close main socket
    //**********************************************************************************
        OS_TCP_USER_CLOSESOCKET(dMainSock, 0);
        dMainSock := 0;

        FSM_TCP := _STATE_IDLE;

    //**********************************************************************************
    _STATE_ERROR,
    _STATE_ERROR_ALLOCATING_MEMORY,
    _STATE_ERROR_CREATING_MUTEX,
    _STATE_ERROR_CREATING_TASK: 
    //**********************************************************************************

  end_case;

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//++                                       E N D                                           ++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  sControl := FSM_TCP;

END_FUNCTION

FUNCTION _TCPIP_SERVER::SendTCP
VAR_INPUT
  pData 	  : ^void;
  udSize 	  : UDINT;
  dSock 	  : DINT;
  bDirect 	: DINT;
END_VAR
VAR_OUTPUT
  dRetcode 	: DINT;
END_VAR

  if ((FSM_TCP <> _STATE_RECV) & (bDirect = false)) then
    dRetcode := -1;
    return;
  end_if;

  dRetcode := OS_TCP_USER_SEND(dSock, pData$^CHAR, udSize, 0, 0);

END_FUNCTION

FUNCTION _TCPIP_SERVER::RECVbuffer_Read
VAR_INPUT
  pData 	: ^void;
END_VAR
VAR_OUTPUT
  udSize 	: UDINT;
END_VAR

  if (RECVbuffer.pData = NIL) then
    sError := -10;
    return;
  end_if;

  udSize := RECVbuffer.udSize;
  _memcpy(pData, RECVbuffer.pData, RECVbuffer.udSize);
  
END_FUNCTION

FUNCTION VIRTUAL GLOBAL _TCPIP_SERVER::Response
VAR_INPUT
#pragma warning(disable: 0073);
  pData 	: ^void;
  udSize 	: UDINT;
  dSock 	: DINT;
#pragma warning(default: 0073);
END_VAR

END_FUNCTION

FUNCTION _TCPIP_SERVER::SENDbuffer_Read
VAR_INPUT
  pBuffer 	    : ^_TX_RINGBUFFER;
  pData 	      : ^void;
  udSize 	      : UDINT;
END_VAR
VAR_OUTPUT
  Retcode 	    : DINT;
END_VAR
VAR
	udBytes2End   : UDINT;
  udBytesTmp    : UDINT;
END_VAR

  Retcode := 0;

  if (pBuffer = NIL) | (pData = NIL) | (pBuffer^.pMem = NIL) then
    return; //### invalid pointer
  end_if;

  udBytes2End := (pBuffer^.pMem$UDINT + pBuffer^.udSize) - pBuffer^.pRead$UDINT;

  if (udSize > udBytes2End) then 

    //##########################################################################################
    //### we must read the data in 2 blocks (|second|...........other data...........|first|)
    //##########################################################################################
    _memcpy(ptr1 := pData, ptr2 := pBuffer^.pRead, cntr := udBytes2End); //### copy the first block
    pData += udBytes2End;
    pBuffer^.pRead := pBuffer^.pMem$^USINT;
    udBytesTmp := udSize - udBytes2End;
    _memcpy(ptr1 := pData, ptr2 := pBuffer^.pRead, cntr := udBytesTmp); //### copy the second block
    pBuffer^.pRead += udBytesTmp;

  else

    //##########################################################################################
    //### read data in one block
    //##########################################################################################
    _memcpy(ptr1 := pData, ptr2 := pBuffer^.pRead, cntr := udSize);
    pBuffer^.pRead += udSize;
  end_if;

  pBuffer^.udUsed -= udSize; // decrease the number of bytes in ringbuffer
  Retcode := udSize$DINT;

END_FUNCTION

FUNCTION _TCPIP_SERVER::SENDbuffer_Write
VAR_INPUT
  pData 	      : ^void;
  udSize 	      : UDINT;
  pBuffer 	    : ^_TX_RINGBUFFER;
END_VAR
VAR_OUTPUT
  dRetcode 	    : DINT;
END_VAR
VAR
	udBytes2End   : UDINT;
  udBytesTmp    : UDINT;
END_VAR

  if (pBuffer^.pMem = NIL) | (pData = NIL) | (pBuffer = NIL) then         // Check if Pointer is NIL
    dRetcode := -9;                       // Pointer to SendBuffer is NIL
    return;
  end_if;

  dRetcode := 0;
  
  if ((udSize) > (pBuffer^.udSize - pBuffer^.udUsed)) then
    return; //### buffer full
  end_if;

  udBytes2End := (pBuffer^.pMem$UDINT + pBuffer^.udSize) - pBuffer^.pWrite$UDINT; // calculate number of bytes till the end of SENDbuffer

  if (udSize > udBytes2End) then
    
    //##########################################################################################
    //### we must write the data in 2 blocks  (|second|...........other data...........|first|)
    //##########################################################################################
    _memcpy(ptr1 := pBuffer^.pWrite, ptr2 := pData, cntr := udBytes2End); // copy the first block
    pData += udBytes2End;
    pBuffer^.pWrite := pBuffer^.pMem$^USINT;
    udBytesTmp := udSize - udBytes2End;
    _memcpy(ptr1 := pBuffer^.pWrite, ptr2 := pData, cntr := udBytesTmp); // copy the second block
    pBuffer^.pWrite += udBytesTmp;
    dRetcode := udSize$DINT;
  else
    
    //##########################################################################################
    //### store data in one block
    //##########################################################################################
    _memcpy(ptr1 := pBuffer^.pWrite, ptr2 := pData, cntr := udSize);
    pBuffer^.pWrite += udSize;
    dRetcode := udSize$DINT;
  end_if;
  
  pBuffer^.udUsed += udSize; // increase the number of bytes in ringbuffer

END_FUNCTION

FUNCTION _TCPIP_SERVER::SENDbuffer_Clear
VAR_INPUT
  pBuffer 	: ^_TX_RINGBUFFER;
END_VAR

  if pBuffer = NIL then
    return;
  end_if;

  pBuffer^.pRead := pBuffer^.pMem$^USINT;
  pBuffer^.pWrite := pBuffer^.pMem$^USINT;
  pBuffer^.udUsed := 0;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL _TCPIP_SERVER::SendData
VAR_INPUT
  pData 	    : ^void;
  udSize 	    : UDINT;
  dSock 	    : DINT;
  bDirect 	  : BOOL;
END_VAR
VAR_OUTPUT
  dRetcode 	  : DINT;
END_VAR
VAR
  dRet        : DINT;
  i           : USINT;  
  bFound      : BOOL;
END_VAR  

  if (bDirect = true) then
    if (udSize <= 1452) then
      dRet := SendTCP(pData, udSize, dSock, true);
      if (dRet <> udSize$DINT) then
        dRetcode := -6;
      else
        dRetcode := dRet;
      end_if;
    else
      dRetcode := -13;
      sError   := -13;
    end_if;
  else

    bFound := false;
    for i := 0 to (MaxConn-1)$USINT do
      if (SocketArray[i].dSocket = dSock) then
        bFound := true;
        exit;
      end_if;
    end_for;

    if (bFound = true) then
      dRet := RingbufferWriteEntry(#SocketArray[i].SendBuffer, pData, udSize);
      if (dRet = TCP_SVR_NO_ERROR) then
        dRetcode := to_DINT(udSize);
      else
        dRetcode := -11;
        sError   := -11;
      end_if;
    else
      dRetcode := -11;
      sError   := -11;
    end_if;

  end_if;
      
END_FUNCTION

FUNCTION _TCPIP_SERVER::Read_LSLOBJ_CRC32
VAR_INPUT
  pCRC32 	    : ^CHAR;
END_VAR
VAR_OUTPUT
  Retcode 	  : DINT;
END_VAR
VAR
	udStrLen    : UDINT;
  udCRC32     : UDINT;
  szObjName   : ARRAY [0..255] OF CHAR;
END_VAR

  Retcode := TCP_SVR_NO_ERROR;

  if (pCRC32 <> NIL) then
    pCRC32^ := 0x00;
    udStrLen := _GetObjName(this, #szObjName[0]);
    if (udStrLen > 0) then
      udCRC32 := CheckSum.CRC32(#szObjName[0], udStrLen, 0);
      co_SigCLib.IToA(udCRC32$DINT, pCRC32, 0x10);
    else
      Retcode := TCP_SVR_ERR_GET_LSLOBJ_NAME;
    end_if;
  else
    Retcode := TCP_SVR_ERR_INVALID_POINTER;
  end_if;

END_FUNCTION

FUNCTION _TCPIP_SERVER::Read_AP_TaskPeriod
VAR_OUTPUT
  Retcode 	    : DINT;
END_VAR
VAR
	dRet          : DINT;
  LSLOBJ_INFO   : LSLOBJ_INFO;
END_VAR

  Retcode := TCP_SVR_NO_ERROR;

  dRet := co_Task.GetObjectInfo(this, OBJ_CT, #LSLOBJ_INFO);
  case dRet of
    (*=============================================================================*)
    0: // - GET OBJECT INFO OK
    (*=============================================================================*)
      if (bdStatus.SalamanderOS = true) then
        // --------------------------------------------------------
        // - SALAMANDER OS
        // --------------------------------------------------------
        if (LSLOBJ_INFO.orgperiod AND 0x80000000) then
          // -------------------------------------------------------
          // - TASK PERIOD IN [s]
          // -------------------------------------------------------
          AP_TaskTime  := LSLOBJ_INFO.orgperiod XOR 0x80000000;
        else
          // -------------------------------------------------------
          // - TASK PERIOD IN [ms]
          // -------------------------------------------------------
          AP_TaskTime  := LSLOBJ_INFO.orgperiod * 1000;
        end_if;
      else
        // --------------------------------------------------------
        // - LASAL OS
        // --------------------------------------------------------
        if (LSLOBJ_INFO.orgperiod AND 0x80000000) then
          // -------------------------------------------------------
          // - TASK PERIOD IN [s]
          // -------------------------------------------------------
          AP_TaskTime := (LSLOBJ_INFO.orgperiod XOR 0x80000000) / 1000;
          if (AP_TaskTime = 0) then
            AP_TaskTime := 1;
          end_if;
        else
          // -------------------------------------------------------
          // - TASK PERIOD IN [ms]
          // -------------------------------------------------------
          AP_TaskTime  := LSLOBJ_INFO.orgperiod;
        end_if;
      end_if;

    (*=============================================================================*)
    -1: // - ERROR READ OBJECT INFO (NO APPLICATION)
    (*=============================================================================*)
      Retcode     := TCP_SVR_ERR_TASK_TIME_NO_APP;
      AP_TaskTime := 0xFFFFFFFF;

    (*=============================================================================*)
    -3: // - ERROR READ OBJECT INFO (NO APPLICATION)
    (*=============================================================================*)
      Retcode     := TCP_SVR_ERR_TASK_TIME_WRONG_TASK_TYPE;
      AP_TaskTime := 0xFFFFFFFF;

    (*=============================================================================*)
    -5: // - OBJECT NOT FOUND (TASK DEACTIVATED)
    (*=============================================================================*)
      Retcode     := TCP_SVR_ERR_TASK_TIME_OBJ_NOT_FOUND;
      AP_TaskTime := 0xFFFFFFFF;

  end_case;

END_FUNCTION

FUNCTION _TCPIP_SERVER::AP_TaskCreate
VAR_INPUT
  pTaskName 	: ^CHAR;
  pCallback 	: ^void;
END_VAR
VAR_OUTPUT
  Retcode 	  : DINT;
END_VAR

  Retcode := TCP_SVR_NO_ERROR;

  AP_TaskHandle := co_MultiTask.CREATETHREAD(pCallback, AP_TaskPriority, 0x4000, MT_TASK_SAVETHIS, this, pTaskName);
  if (AP_TaskHandle = NIL) then
    Retcode := TCP_SVR_ERR_TASK_CREATE;
  end_if;

END_FUNCTION

FUNCTION _TCPIP_SERVER::AP_TaskCallback
VAR_INPUT
#pragma warning (disable: 0073)
  Param0 	: ^void;
#pragma warning (default: 0073)
END_VAR

  while 1 do
    CyclicCall();
    AP_TaskDelay(AP_TaskTime);
  end_while;

END_FUNCTION

FUNCTION _TCPIP_SERVER::GetMultiTaskErrorCode
VAR_INPUT
  pErrTxt 	: ^CHAR;
END_VAR
VAR
	ErrMT     : DINT;
END_VAR

  ErrMT := co_MultiTask.GETLASTERROR();
  case ErrMT of

    (*===============================================================================================*)
    MTERROR_NONE: // - NO ERROR
    (*===============================================================================================*)
      co_SigCLib.StrCpy(pErrTxt, "MTERROR_NONE");

    (*===============================================================================================*)
    MTERROR_NOMEM: // - NO MORE MEMORY TO RUN THIS FUNCTION, E.G. INTERNAL ALLOC FAILED
    (*===============================================================================================*)
      co_SigCLib.StrCpy(pErrTxt, "MTERROR_NOMEM");

    (*===============================================================================================*)
    MTERROR_NOFCT: // - CREATE TASK NEEDS A VALID TASK FUNCTION
    (*===============================================================================================*)
      co_SigCLib.StrCpy(pErrTxt, "MTERROR_NOFCT");

    (*===============================================================================================*)
    MTERROR_FCTNOTINMEM: // - CREATE TASK NEEDS A TASK FUNCTION PLACED IN LASAL CODE MEMORY
    (*===============================================================================================*)
      co_SigCLib.StrCpy(pErrTxt, "MTERROR_FCTNOTINMEM");

    (*===============================================================================================*)
    MTERROR_WRONGPRIOR: // - CREATE TASK ONLY SUPPORTS PRIORS FROM 1 .. 14
    (*===============================================================================================*)
      co_SigCLib.StrCpy(pErrTxt, "MTERROR_WRONGPRIOR");

    (*===============================================================================================*)
    MTERROR_STACK: // - CREATE TASK ONLY SUPPORT SATCK SIZE LOWER THAN 0x4000
    (*===============================================================================================*)
      co_SigCLib.StrCpy(pErrTxt, "MTERROR_STACK");

    (*===============================================================================================*)
    MTERROR_NAME: // - CREATE TASK, MAILBOX OR SEMAPHORE NEEDS A VALID NAME
    (*===============================================================================================*)
      co_SigCLib.StrCpy(pErrTxt, "MTERROR_NAME");

    (*===============================================================================================*)
    MTERROR_NAMEUSED: // - CREATE TASK, MAILBOX OR SEMAPHORE NAME ALREADY IN USE
    (*===============================================================================================*)
      co_SigCLib.StrCpy(pErrTxt, "MTERROR_NAMEUSED");

    (*===============================================================================================*)
    MTERROR_HANDLE: // - HANDLE NOT FOUND IN OS-LIST => NOT VALID
    (*===============================================================================================*)
      co_SigCLib.StrCpy(pErrTxt, "MTERROR_HANDLE");

    (*===============================================================================================*)
    MTERROR_NOTALLOWED: // - MT-FUNCTION NOT ALLOWED IN THIS TASK CONTEXT
    (*===============================================================================================*)
      co_SigCLib.StrCpy(pErrTxt, "MTERROR_NOTALLOWED");

    (*===============================================================================================*)
    MTERROR_MESSAGESIZE: // - MAILBOX NEED A VALID MESSAGE SIZE
    (*===============================================================================================*)
      co_SigCLib.StrCpy(pErrTxt, "MTERROR_MESSAGESIZE");

    (*===============================================================================================*)
    MTERROR_DATA: // - POINTER TO DATA IS NOT VALID
    (*===============================================================================================*)
      co_SigCLib.StrCpy(pErrTxt, "MTERROR_DATA");

    (*===============================================================================================*)
    MTERROR_PTR: // - INVALID POINTER, PARAMETER OR INTERNAL
    (*===============================================================================================*)
      co_SigCLib.StrCpy(pErrTxt, "MTERROR_PTR");

    (*===============================================================================================*)
    MTERROR_TASKID: // - INVALID TASK ID, ID NOT FOUND
    (*===============================================================================================*)
      co_SigCLib.StrCpy(pErrTxt, "MTERROR_TASKID");

    (*===============================================================================================*)
    MTERROR_NOTASK: // - TASK DOES NOT EXIST
    (*===============================================================================================*)
      co_SigCLib.StrCpy(pErrTxt, "MTERROR_NOTASK");

    (*===============================================================================================*)
    MTERROR_NOIFFNC: // - INTERFACE FUNCTION IS NOT AVAILABLE
    (*===============================================================================================*)
      co_SigCLib.StrCpy(pErrTxt, "MTERROR_NOIFFNC");

    (*===============================================================================================*)
    else // - UNKNOWN ERROR CODE
    (*===============================================================================================*)
      co_SigCLib.StrCpy(pErrTxt, "MTERROR_UNKNOWN");

  end_case;

END_FUNCTION

FUNCTION _TCPIP_SERVER::AP_SemaCreate
VAR_INPUT
  pSemaName 	: ^CHAR;
  Index 	    : DINT;
END_VAR
VAR_OUTPUT
  Retcode 	: DINT;
END_VAR

  Retcode := TCP_SVR_NO_ERROR;

  if (pSemaName <> NIL) then
    case Index of
      (*=================================================================================*)
      0:
      (*=================================================================================*)
        AP_SemaHandle1 := co_MultiTask.CREATESEMAPHORE(MTSEMATYPE_MUTEX, 1, 0, pSemaName);
        if (AP_SemaHandle1 = NIL) then
          Retcode := TCP_SVR_ERR_SEMA_CREATE;
        end_if;

      (*=================================================================================*)
      1:
      (*=================================================================================*)
        AP_SemaSockOpt := co_MultiTask.CREATESEMAPHORE(MTSEMATYPE_MUTEX, 1, 0, pSemaName);
        if (AP_SemaSockOpt = NIL) then
          Retcode := TCP_SVR_ERR_SEMA_CREATE;
        end_if;

      (*=================================================================================*)
      else
      (*=================================================================================*)
        Retcode := TCP_SVR_ERR_SEMA_INVALID_IDX;

    end_case;
  else
    Retcode := TCP_SVR_ERR_SEMA_INVALID_NAME;
  end_if;

END_FUNCTION

FUNCTION _TCPIP_SERVER::AP_TaskDelay
VAR_INPUT
  udTaskDelay 	: UDINT;
END_VAR

  if (bdStatus.SalamanderOS = true) then
    OSSD_DELAY(pCIL_DEBUG, udTaskDelay);
  else
    co_MultiTask.TASKDELAY(udTaskDelay);
  end_if;

END_FUNCTION

FUNCTION _TCPIP_SERVER::SetMainSocketOptions
VAR_OUTPUT
  Retcode 	: DINT;
END_VAR
VAR
	dRet        : DINT;
  OptionValue : DINT;
END_VAR

  Retcode := TCP_SVR_NO_ERROR;

  OptionValue := 1;
  dRet := OS_TCP_USER_SETSOCKOPT(dMainSock, SOL_SOCKET, SO_REUSEADDR, #OptionValue$CHAR, sizeof(DINT));
  if (dRet <> 0) then
    Retcode := dRet;
  end_if;

  OptionValue := 0;
  dRet := OS_TCP_USER_SETSOCKOPT(dMainSock, SOL_SOCKET, SO_DELAYED_ACK, #OptionValue$CHAR, sizeof(DINT));
  if (dRet <> 0) then
    Retcode := dRet;
  end_if;

END_FUNCTION

FUNCTION _TCPIP_SERVER::RingbufferReadEntry
VAR_INPUT
  pBuffer 	: ^_TX_RINGBUFFER;
  pData 	: ^void;
  pSize 	: ^UDINT;
END_VAR
VAR_OUTPUT
  Retcode 	: DINT;
END_VAR
VAR
	BufferHeader    : _BUFFER_HEADER;
  dRet            : DINT;
END_VAR

  Retcode := TCP_SVR_NO_ERROR;
  pSize^  := 0;

  if (pBuffer = NIL) | (pData = NIL) | (pSize = NIL) then
    Retcode := TCP_SVR_ERR_INVALID_POINTER;
  else
    if (pBuffer^.udUsed = 0) then
      Retcode := TCP_SVR_SEND_BUFFER_EMPTY;
    else
      AP_SemaWait(AP_SemaHandle1);
      dRet := SENDBuffer_Read(pBuffer, #BufferHeader, sizeof(_BUFFER_HEADER));
      if (dRet = sizeof(_BUFFER_HEADER)) then
        dRet := SENDBuffer_Read(pBuffer, pData, BufferHeader.DataSize);
        if (dRet = BufferHeader.DataSize$DINT) then
          pSize^ := BufferHeader.DataSize;
        else
          Retcode := TCP_SVR_ERR_SEND_BUFFER_FATAL_ERROR;
        end_if;
      else
        Retcode := TCP_SVR_ERR_SEND_BUFFER_FATAL_ERROR;
      end_if;
      AP_SemaSignal(AP_SemaHandle1);
    end_if;
  end_if;

END_FUNCTION

FUNCTION _TCPIP_SERVER::RingbufferWriteEntry
VAR_INPUT
  pBuffer 	: ^_TX_RINGBUFFER;
  pData 	: ^void;
  udSize 	: UDINT;
END_VAR
VAR_OUTPUT
  Retcode 	: DINT;
END_VAR
VAR
	BufferHeader  : _BUFFER_HEADER;
END_VAR

  Retcode := TCP_SVR_NO_ERROR;

  if (pBuffer = NIL) | (pData = NIL) then
    Retcode := TCP_SVR_ERR_INVALID_POINTER;
  else
    AP_SemaWait(AP_SemaHandle1);
    if ((udSize + sizeof(_BUFFER_HEADER)) > (pBuffer^.udSize - pBuffer^.udUsed)) then
      Retcode := TCP_SVR_SEND_BUFFER_FULL;
    else
      BufferHeader.DataSize := udSize;
      SENDbuffer_Write(#BufferHeader, sizeof(_BUFFER_HEADER), pBuffer);
      SENDbuffer_Write(pData, udSize, pBuffer);
    end_if;
    AP_SemaSignal(AP_SemaHandle1);
  end_if;

END_FUNCTION

FUNCTION _TCPIP_SERVER::AP_SemaWait
VAR_INPUT
  SemaHandle 	: MT_SEMAHANDLE;
END_VAR

  if (SemaHandle <> NIL) then
    co_MultiTask.WAIT(SemaHandle);
  end_if;

END_FUNCTION

FUNCTION _TCPIP_SERVER::AP_SemaSignal
VAR_INPUT
  SemaHandle 	: MT_SEMAHANDLE;
END_VAR

  if (SemaHandle <> NIL) then
    co_MultiTask.SIGNAL(SemaHandle);
  end_if;

END_FUNCTION

FUNCTION _TCPIP_SERVER::SetSocketOptions
VAR_INPUT
  pConn 	          : ^_CONNECTION;
END_VAR
VAR_OUTPUT
  Retcode 	        : DINT;
END_VAR
VAR
	OptionValue       : DINT;
  dRet              : DINT;
  KeepAliveLasalOS  : _KeepAliveParaLasalOS;
END_VAR

  Retcode := TCP_SVR_NO_ERROR;

  AP_SemaWait(AP_SemaSockOpt);

  // -----------------------------------------------------------
  // - SOCKET OPTION NAGLE
  // -----------------------------------------------------------
  if (pConn^.ConnSockOpt.Nagle = true) then
    OptionValue := 1;
  else
    OptionValue := 0;
  end_if;
  dRet := OS_TCP_USER_SETSOCKOPT(pConn^.dSocket, SOL_SOCKET, SO_NAGLE, (#OptionValue)$^CHAR, sizeof(DINT));
  if (dRet < 0) then
    Retcode := dRet;
    ConnSocketError(pConn^.dSocket, pConn^.FSM_TCP, TCP_SVR_ERR_GROUP_OS, dRet);
  end_if;

  // -----------------------------------------------------------
  // - SOCKET OPTION KEEP ALIVE
  // -----------------------------------------------------------
  if (bdStatus.SalamanderOS = false) then
    // --------------------------------------------------------
    // - LASAL OS
    // --------------------------------------------------------
    if (pConn^.ConnSockOpt.KeepAlive = true) then
      KeepAliveLasalOS.interval := to_UINT(pConn^.KeepAlivePara.keepIDLE);
      KeepAliveLasalOS.retry    := to_UINT(pConn^.KeepAlivePara.keepINTVL);
      KeepAliveLasalOS.timeout  := to_UINT(pConn^.KeepAlivePara.keepCNT * pConn^.KeepAlivePara.keepINTVL);
    else
      KeepAliveLasalOS.interval := 0;
      KeepAliveLasalOS.retry    := 0;
      KeepAliveLasalOS.timeout  := 0;
    end_if;
    dRet := OS_TCP_USER_SETSOCKOPT(pConn^.dSocket, SOL_SOCKET, 8, (#KeepAliveLasalOS)$^CHAR, sizeof(_KeepAliveParaLasalOS));
    if (dRet < 0) then
      Retcode := dRet;
      ConnSocketError(pConn^.dSocket, pConn^.FSM_TCP, TCP_SVR_ERR_GROUP_OS, dRet);
    end_if;
  else
    // --------------------------------------------------------
    // - SALAMANDER OS
    // --------------------------------------------------------
    if (pConn^.ConnSockOpt.KeepAlive = true) then
      OptionValue := 1;
    else
      OptionValue := 0;
    end_if;
    dRet := OS_TCP_USER_SETSOCKOPT(pConn^.dSocket, SOL_SOCKET, 8, (#OptionValue)$^CHAR, sizeof(DINT));
    if (dRet < 0) then
      Retcode := dRet;
      ConnSocketError(pConn^.dSocket, pConn^.FSM_TCP, TCP_SVR_ERR_GROUP_OS, dRet);
    end_if;

//    if (pConn^.ConnSockOpt.KeepAlive = true) then
//      OptionValue := KeepAlivePara.keepCNT;
//      dRet := OS_TCP_USER_SETSOCKOPT(pConn^.dSocket, SOL_TCP, TCP_KEEPCNT, (#OptionValue)$^CHAR, sizeof(DINT));
//      if (dRet < 0) then
//        Retcode := dRet;
//        ConnSocketError(pConn^.dSocket, pConn^.FSM_TCP, TCP_SVR_ERR_GROUP_OS, dRet);
//      end_if;
//      OptionValue := KeepAlivePara.keepIDLE;
//      dRet := OS_TCP_USER_SETSOCKOPT(pConn^.dSocket, SOL_TCP, TCP_KEEPIDLE, (#OptionValue)$^CHAR, sizeof(DINT));
//      if (dRet < 0) then
//        Retcode := dRet;
//        ConnSocketError(pConn^.dSocket, pConn^.FSM_TCP, TCP_SVR_ERR_GROUP_OS, dRet);
//      end_if;
//      OptionValue := KeepAlivePara.keepINTVL;
//      dRet := OS_TCP_USER_SETSOCKOPT(pConn^.dSocket, SOL_TCP, TCP_KEEPINTVL, (#OptionValue)$^CHAR, sizeof(DINT));
//      if (dRet < 0) then
//        Retcode := dRet;
//        ConnSocketError(pConn^.dSocket, pConn^.FSM_TCP, TCP_SVR_ERR_GROUP_OS, dRet);
//      end_if;
//    end_if;
  end_if;

  // -----------------------------------------------------------
  // - SOCKET OPTION DELAYED ACK
  // -----------------------------------------------------------
  if (pConn^.ConnSockOpt.DelayedAck = true) then
    OptionValue := 1;
  else
    OptionValue := 0;
  end_if;
  OS_TCP_USER_SETSOCKOPT(pConn^.dSocket, SOL_SOCKET, SO_DELAYED_ACK, (#OptionValue)$^CHAR, sizeof(DINT));
  if (dRet < 0) then
    Retcode := dRet;
    ConnSocketError(pConn^.dSocket, pConn^.FSM_TCP, TCP_SVR_ERR_GROUP_OS, dRet);
  end_if;

  // -----------------------------------------------------------
  // - SOCKET OPTION REUSE ADDR
  // -----------------------------------------------------------
  if (pConn^.ConnSockOpt.ReuseAddr = true) then
    OptionValue := 1;
  else
    OptionValue := 0;
  end_if;
  OS_TCP_USER_SETSOCKOPT(pConn^.dSocket, SOL_SOCKET, SO_REUSEADDR, (#OptionValue)$^CHAR, sizeof(DINT));
  if (dRet < 0) then
    Retcode := dRet;
    ConnSocketError(pConn^.dSocket, pConn^.FSM_TCP, TCP_SVR_ERR_GROUP_OS, dRet);
  end_if;

  pConn^.bdSettings.SockOptChanged := false;

  AP_SemaSignal(AP_SemaSockOpt);

END_FUNCTION

FUNCTION _TCPIP_SERVER::AddConnIntern
VAR_INPUT
  dSocket 	: DINT;
  ppConn 	  : ^pVoid;
END_VAR
VAR_OUTPUT
  Retcode 	: DINT;
END_VAR
VAR
	i           : USINT;
  pFirstConn  : ^_CONNECTION;
  pNewConn    : ^_CONNECTION;
  pSearchConn : ^_CONNECTION;
END_VAR

  Retcode := TCP_SVR_NO_ERROR;
  if (ppConn <> NIL) then
    ppConn^ := NIL;
  end_if;

  if (ActConn < MaxConn) then

    for i := 0 to (MaxConn-1) do
      pFirstConn := #SocketArray[0] + (i * sizeof(_CONNECTION));
      if (pFirstConn^.dSocket <> 0) then
        exit;
      else
        pFirstConn := NIL;
      end_if;
    end_for;

    for i := 0 to (MaxConn-1) do
      pNewConn := #SocketArray[0] + (i * sizeof(_CONNECTION));
      if (pNewConn^.dSocket = 0) then
        pNewConn^.dSocket         := dSocket;
        pNewConn^.FSM_TCP         := _STATE_RECV;
        pNewConn^.ConnSockOpt     := MainSockOpt;
        pNewConn^.KeepAlivePara   := KeepAlivePara;
        pNewConn^.CloseSocketType := CloseSocketType;
        pNewConn^.bdSettings.SockOptChanged := true;
        ConnSocketInfo(dSocket, TCP_SVR_SOCK_INFO_CONNECT, 0);
        if (ppConn <> NIL) then
          ppConn^$^_CONNECTION := pNewConn;
        end_if;
        exit;
      end_if;
    end_for;

    if (pFirstConn = NIL) then
      pNewConn^.pNextConn := pNewConn;
    else
      pSearchConn := pFirstConn;
      while (pSearchConn^.pNextConn <> pFirstConn) do
        pSearchConn := pSearchConn^.pNextConn;
      end_while;
      pNewConn^.pNextConn    := pFirstConn;
      pSearchConn^.pNextConn := pNewConn;
    end_if;

    ActConn += 1;
    if (ActConn = 1) then
      pActConn := pNewConn;
    end_if;

    if (cTimeOut > 0) then
      pNewConn^.udTimeStamp := ops.tAbsolute;
    end_if;

  else
    Retcode := TCP_SVR_ERR_MAX_CONN;
  end_if;

END_FUNCTION

FUNCTION _TCPIP_SERVER::DelConnIntern
VAR_INPUT
  dSocket 	: DINT;
END_VAR
VAR_OUTPUT
  Retcode 	: DINT;
END_VAR
VAR
	pConn       : ^_CONNECTION;
  pSearchConn : ^_CONNECTION;
  i           : USINT;
END_VAR

  Retcode := TCP_SVR_NO_ERROR;

  if (ActConn > 0) then

    for i := 0 to (MaxConn-1) do
      pConn := #SocketArray[0] + (i * sizeof(_CONNECTION));
      if (pConn^.dSocket = dSocket) then
        exit;
      else
        pConn := NIL;
      end_if;
    end_for;

    if (pConn <> NIL) then
      if (pConn^.pNextConn = pConn) then
        // - ONE ACTIVE CONNECTION
      else
        pSearchConn := pConn;
        while (pSearchConn^.pNextConn <> pConn) do
          pSearchConn := pSearchConn^.pNextConn;
        end_while;
        pSearchConn^.pNextConn := pConn^.pNextConn;
        pActConn := pConn^.pNextConn;
        bdStatus.InhibNextConn := true;
      end_if;
      pConn^.dSocket   := 0;
      pConn^.FSM_TCP   := _STATE_IDLE;
      pConn^.pNextConn := NIL;
      ConnSocketInfo(dSocket, TCP_SVR_SOCK_INFO_DISCONNECT, 0);
      ActConn -= 1;
    end_if;

  else
    // - ERROR NO CONN
  end_if;

END_FUNCTION

FUNCTION VIRTUAL GLOBAL _TCPIP_SERVER::ConnSocketInfo
VAR_INPUT
#pragma warning (disable: 0073)
  dSock 	    : DINT;
  InfoPara1 	: DINT;
  InfoPara2 	: DINT;
#pragma warning (default: 0073)
END_VAR

END_FUNCTION

FUNCTION VIRTUAL GLOBAL _TCPIP_SERVER::ConnSocketError
VAR_INPUT
#pragma warning (disable: 0073)
  dSock 	: DINT;
  FSM_TCP 	: _FSM_TCP_USER;
  ErrGroup 	: DINT;
  ErrCode 	: DINT;
#pragma warning (default: 0073)
END_VAR

END_FUNCTION

FUNCTION VIRTUAL GLOBAL _TCPIP_SERVER::MainSocketError
VAR_INPUT
#pragma warning (disable: 0073)
  FSM_TCP 	  : _FSM_TCP_USER;
  ErrGroup 	  : DINT;
  ErrorCode 	: DINT;
#pragma warning (default: 0073)
END_VAR

END_FUNCTION

FUNCTION VIRTUAL GLOBAL _TCPIP_SERVER::SetMainParameter
VAR_INPUT
  Cmd 	      : DINT;
  SubCmd 	    : DINT;
  ParaValue 	: DINT;
END_VAR
VAR_OUTPUT
  Retcode 	  : DINT;
END_VAR

  Retcode := TCP_SVR_NO_ERROR;

  if (usInit > 0) then
    case Cmd of
      (*================================================================*)
      TCPSVR_CMD_SETSOCKOPT:
      (*================================================================*)
        case SubCmd of
          (*==================================================*)
          TCPSVR_SOCKOPT_NAGLE:
          (*==================================================*)
            if (ParaValue = 0) then
              MainSockOpt.Nagle := false;
            else
              MainSockOpt.Nagle := true;
            end_if;
          (*==================================================*)
          TCPSVR_SOCKOPT_KEEPALIVE:
          (*==================================================*)
            if (ParaValue = 0) then
              MainSockOpt.KeepAlive := false;
            else
              MainSockOpt.KeepAlive := true;
            end_if; 
          (*==================================================*)
          TCPSVR_SOCKOPT_DELAYEDACK:
          (*==================================================*)
            if (ParaValue = 0) then
              MainSockOpt.DelayedAck := false;
            else
              MainSockOpt.DelayedAck := true;
            end_if;
          (*==================================================*)
          TCPSVR_SOCKOPT_REUSEADDR:
          (*==================================================*)
            if (ParaValue = 0) then
              MainSockOpt.ReuseAddr := false;
            else
              MainSockOpt.ReuseAddr := true;
            end_if;
          (*==================================================*)
          else // - INVALID SUB COMMAND
          (*==================================================*)
            Retcode := TCP_SVR_ERR_SET_PARA_INVALID_SUB_CMD;
        end_case;

      (*================================================================*)
      TCPSVR_CMD_TASKPRIO: // - ASYNC TASK PRIORITY
      (*================================================================*)
        case SubCmd of
          (*==================================================*)
          TCPSVR_SUB_CMD_TASKPRIO:
          (*==================================================*)
            if (usInit < INIT_FIRSTSCAN) then
              AP_TaskPriority := ParaValue$UDINT;
            else
              Retcode := TCP_SVR_ERR_TASK_ALREADY_EXIST;
            end_if;
          (*==================================================*)
          else // - INVALID SUB COMMAND
          (*==================================================*)
            Retcode := TCP_SVR_ERR_SET_PARA_INVALID_SUB_CMD;
        end_case;

      (*================================================================*)
      TCPSVR_CMD_KEEPALIVEPARA: // - ASYNC TASK PRIORITY
      (*================================================================*)
        case SubCmd of
          (*==================================================*)
          TCPSVR_KEEPALIVE_KEEPIDLE:
          (*==================================================*)
            KeepAlivePara.keepIDLE := ParaValue;
          (*==================================================*)
          TCPSVR_KEEPALIVE_KEEPINTVL:
          (*==================================================*)
            KeepAlivePara.keepINTVL := ParaValue;
          (*==================================================*)
          TCPSVR_KEEPALIVE_KEEPCNT:
          (*==================================================*)
            KeepAlivePara.keepCNT := ParaValue;
          (*==================================================*)
          else // - INVALID SUB COMMAND
          (*==================================================*)
            Retcode := TCP_SVR_ERR_SET_PARA_INVALID_SUB_CMD;
        end_case;

      (*================================================================*)
      TCPSVR_CMD_CLOSESOCKETTYPE:
      (*================================================================*)
        case SubCmd of
          (*==================================================*)
          TCPSVR_CLOSESOCKETTYPE:
          (*==================================================*)
            CloseSocketType := ParaValue$UDINT;
          (*==================================================*)
          else // - INVALID SUB COMMAND
          (*==================================================*)
            Retcode := TCP_SVR_ERR_SET_PARA_INVALID_SUB_CMD;
        end_case;

      (*================================================================*)
      else // - INVALID COMMAND
      (*================================================================*)
        Retcode := TCP_SVR_ERR_SET_PARA_INVALID_CMD;

    end_case;
  else
    Retcode := TCP_SVR_ERR_MAIN_INIT;
  end_if;

END_FUNCTION

FUNCTION VIRTUAL GLOBAL _TCPIP_SERVER::SetSocketParameter
VAR_INPUT
  dSock 	    : DINT;
  Cmd 	      : DINT;
  SubCmd 	    : DINT;
  ParaValue 	: DINT;
END_VAR
VAR_OUTPUT
  Retcode 	  : DINT;
END_VAR
VAR
	pConn       : ^_CONNECTION;
END_VAR

  Retcode := TCP_SVR_NO_ERROR;

  if (CheckSocketValid(dSock, (#pConn)$^pVoid) = true) then
    if (pConn <> NIL) then
      case Cmd of
        (*================================================================*)
        TCPSVR_CMD_SETSOCKOPT:
        (*================================================================*)
          case SubCmd of
            (*==================================================*)
            TCPSVR_SOCKOPT_NAGLE:
            (*==================================================*)
              if (ParaValue = 0) then
                if (pConn^.ConnSockOpt.Nagle = true) then
                  AP_SemaWait(AP_SemaSockOpt);
                  pConn^.ConnSockOpt.Nagle := false;
                  pConn^.bdSettings.SockOptChanged := true;
                  AP_SemaSignal(AP_SemaSockOpt);
                end_if;
              else
                if (pConn^.ConnSockOpt.Nagle = false) then
                  AP_SemaWait(AP_SemaSockOpt);
                  pConn^.ConnSockOpt.Nagle := true;
                  pConn^.bdSettings.SockOptChanged := true;
                  AP_SemaSignal(AP_SemaSockOpt);
                end_if;
              end_if;
            (*==================================================*)
            TCPSVR_SOCKOPT_KEEPALIVE:
            (*==================================================*)
              if (ParaValue = 0) then
                if (pConn^.ConnSockOpt.KeepAlive = true) then
                  AP_SemaWait(AP_SemaSockOpt);
                  pConn^.ConnSockOpt.KeepAlive := false;
                  pConn^.bdSettings.SockOptChanged := true;
                  AP_SemaSignal(AP_SemaSockOpt);
                end_if;
              else
                if (pConn^.ConnSockOpt.KeepAlive = false) then
                  AP_SemaWait(AP_SemaSockOpt);
                  pConn^.ConnSockOpt.KeepAlive := true;
                  pConn^.bdSettings.SockOptChanged := true;
                  AP_SemaSignal(AP_SemaSockOpt);
                end_if;
              end_if;
            (*==================================================*)
            TCPSVR_SOCKOPT_DELAYEDACK:
            (*==================================================*)
              if (ParaValue = 0) then
                if (pConn^.ConnSockOpt.DelayedAck = true) then
                  AP_SemaWait(AP_SemaSockOpt);
                  pConn^.ConnSockOpt.DelayedAck := false;
                  pConn^.bdSettings.SockOptChanged := true;
                  AP_SemaSignal(AP_SemaSockOpt);
                end_if;
              else
                if (pConn^.ConnSockOpt.DelayedAck = false) then
                  AP_SemaWait(AP_SemaSockOpt);
                  pConn^.ConnSockOpt.DelayedAck := true;
                  pConn^.bdSettings.SockOptChanged := true;
                  AP_SemaSignal(AP_SemaSockOpt);
                end_if;
              end_if;
            (*==================================================*)
            TCPSVR_SOCKOPT_REUSEADDR:
            (*==================================================*)
              if (ParaValue = 0) then
                if (pConn^.ConnSockOpt.ReuseAddr = true) then
                  AP_SemaWait(AP_SemaSockOpt);
                  pConn^.ConnSockOpt.ReuseAddr := false;
                  pConn^.bdSettings.SockOptChanged := true;
                  AP_SemaSignal(AP_SemaSockOpt);
                end_if;
              else
                if (pConn^.ConnSockOpt.ReuseAddr = false) then
                  AP_SemaWait(AP_SemaSockOpt);
                  pConn^.ConnSockOpt.ReuseAddr := true;
                  pConn^.bdSettings.SockOptChanged := true;
                  AP_SemaSignal(AP_SemaSockOpt);
                end_if;
              end_if;
            (*==================================================*)
            else // - INVALID SUB COMMAND
            (*==================================================*)
              Retcode := TCP_SVR_ERR_SET_PARA_INVALID_SUB_CMD;
          end_case;

        (*================================================================*)
        TCPSVR_CMD_KEEPALIVEPARA: // - ASYNC TASK PRIORITY
        (*================================================================*)
          case SubCmd of
            (*==================================================*)
            TCPSVR_KEEPALIVE_KEEPIDLE:
            (*==================================================*)
              AP_SemaWait(AP_SemaSockOpt);
              pConn^.KeepAlivePara.keepIDLE    := ParaValue;
              pConn^.bdSettings.SockOptChanged := true;
              AP_SemaSignal(AP_SemaSockOpt);
            (*==================================================*)
            TCPSVR_KEEPALIVE_KEEPINTVL:
            (*==================================================*)
              AP_SemaWait(AP_SemaSockOpt);
              pConn^.KeepAlivePara.keepINTVL   := ParaValue;
              pConn^.bdSettings.SockOptChanged := true;
              AP_SemaSignal(AP_SemaSockOpt);
            (*==================================================*)
            TCPSVR_KEEPALIVE_KEEPCNT:
            (*==================================================*)
              AP_SemaWait(AP_SemaSockOpt);
              pConn^.KeepAlivePara.keepCNT     := ParaValue;
              pConn^.bdSettings.SockOptChanged := true;
              AP_SemaSignal(AP_SemaSockOpt);
            (*==================================================*)
            else // - INVALID SUB COMMAND
            (*==================================================*)
              Retcode := TCP_SVR_ERR_SET_PARA_INVALID_SUB_CMD;
          end_case;

        (*================================================================*)
        TCPSVR_CMD_CLOSESOCKETTYPE:
        (*================================================================*)
          case SubCmd of
            (*==================================================*)
            TCPSVR_CLOSESOCKETTYPE:
            (*==================================================*)
              pConn^.CloseSocketType := ParaValue$UDINT;
            (*==================================================*)
            else // - INVALID SUB COMMAND
            (*==================================================*)
              Retcode := TCP_SVR_ERR_SET_PARA_INVALID_SUB_CMD;
          end_case;

        (*================================================================*)
        else // - INVALID COMMAND
        (*================================================================*)
          Retcode := TCP_SVR_ERR_SET_PARA_INVALID_CMD;

      end_case;
    else
      Retcode := TCP_SVR_ERR_INVALID_SOCKET;
    end_if;
  else
    Retcode := TCP_SVR_ERR_INVALID_SOCKET;
  end_if;

END_FUNCTION

FUNCTION VIRTUAL GLOBAL _TCPIP_SERVER::ReadMainParameter
	VAR_INPUT
		Cmd 	: DINT;
		SubCmd 	: DINT;
		pParaValue 	: ^DINT;
	END_VAR
	VAR_OUTPUT
		Retcode 	: DINT;
	END_VAR

  Retcode := TCP_SVR_NO_ERROR;

  if (usInit > 0) then
    case Cmd of
      (*================================================================*)
      TCPSVR_CMD_SETSOCKOPT:
      (*================================================================*)
        case SubCmd of
          (*==================================================*)
          TCPSVR_SOCKOPT_NAGLE:
          (*==================================================*)
            if (MainSockOpt.Nagle = false) then
              pParaValue^ := 0;
            else
              pParaValue^ := 1;
            end_if;
          (*==================================================*)
          TCPSVR_SOCKOPT_KEEPALIVE:
          (*==================================================*)
            if (MainSockOpt.KeepAlive = false) then
              pParaValue^ := 0;
            else
              pParaValue^ := 1;
            end_if; 
          (*==================================================*)
          TCPSVR_SOCKOPT_DELAYEDACK:
          (*==================================================*)
            if (MainSockOpt.DelayedAck = false) then
              pParaValue^ := 0;
            else
              pParaValue^ := 1;
            end_if;
          (*==================================================*)
          TCPSVR_SOCKOPT_REUSEADDR:
          (*==================================================*)
            if (MainSockOpt.ReuseAddr = false) then
              pParaValue^ := 0;
            else
              pParaValue^ := 1;
            end_if;
          (*==================================================*)
          else // - INVALID SUB COMMAND
          (*==================================================*)
            Retcode := TCP_SVR_ERR_SET_PARA_INVALID_SUB_CMD;
        end_case;

      (*================================================================*)
      TCPSVR_CMD_TASKPRIO:
      (*================================================================*)
        case SubCmd of
          (*==================================================*)
          TCPSVR_SUB_CMD_TASKPRIO:
          (*==================================================*)
            pParaValue^ := AP_TaskPriority$DINT;
          (*==================================================*)
          else // - INVALID SUB COMMAND
          (*==================================================*)
            Retcode := TCP_SVR_ERR_SET_PARA_INVALID_SUB_CMD;
        end_case;

      (*================================================================*)
      TCPSVR_CMD_KEEPALIVEPARA: // - ASYNC TASK PRIORITY
      (*================================================================*)
        case SubCmd of
          (*==================================================*)
          TCPSVR_KEEPALIVE_KEEPIDLE:
          (*==================================================*)
            pParaValue^ := KeepAlivePara.keepIDLE;
          (*==================================================*)
          TCPSVR_KEEPALIVE_KEEPINTVL:
          (*==================================================*)
            pParaValue^ := KeepAlivePara.keepINTVL;
          (*==================================================*)
          TCPSVR_KEEPALIVE_KEEPCNT:
          (*==================================================*)
            pParaValue^ := KeepAlivePara.keepCNT;
          (*==================================================*)
          else // - INVALID SUB COMMAND
          (*==================================================*)
            Retcode := TCP_SVR_ERR_SET_PARA_INVALID_SUB_CMD;
        end_case;

      (*================================================================*)
      TCPSVR_CMD_CLOSESOCKETTYPE:
      (*================================================================*)
        case SubCmd of
          (*==================================================*)
          TCPSVR_CLOSESOCKETTYPE:
          (*==================================================*)
            pParaValue^$UDINT := CloseSocketType;
          (*==================================================*)
          else // - INVALID SUB COMMAND
          (*==================================================*)
            Retcode := TCP_SVR_ERR_SET_PARA_INVALID_SUB_CMD;
        end_case;

      (*================================================================*)
      else // - INVALID COMMAND
      (*================================================================*)
        Retcode := TCP_SVR_ERR_SET_PARA_INVALID_CMD;

    end_case;
  else
    Retcode := TCP_SVR_ERR_MAIN_INIT;
  end_if;

END_FUNCTION

FUNCTION VIRTUAL GLOBAL _TCPIP_SERVER::ReadSocketParameter
	VAR_INPUT
		dSock 	: DINT;
		Cmd 	: DINT;
		SubCmd 	: DINT;
		pParaValue 	: ^DINT;
	END_VAR
	VAR_OUTPUT
		Retcode 	: DINT;
	END_VAR
VAR
	pConn       : ^_CONNECTION;
END_VAR

  Retcode := TCP_SVR_NO_ERROR;

  if (CheckSocketValid(dSock, (#pConn)$^pVoid) = true) then
    if (pConn <> NIL) then
      case Cmd of
        (*================================================================*)
        TCPSVR_CMD_SETSOCKOPT:
        (*================================================================*)
          case SubCmd of
            (*==================================================*)
            TCPSVR_SOCKOPT_NAGLE:
            (*==================================================*)
              if (pConn^.ConnSockOpt.Nagle = false) then
                pParaValue^ := 0;
              else
                pParaValue^ := 1;
              end_if;
            (*==================================================*)
            TCPSVR_SOCKOPT_KEEPALIVE:
            (*==================================================*)
              if (pConn^.ConnSockOpt.KeepAlive = false) then
                pParaValue^ := 0;
              else
                pParaValue^ := 1;
              end_if;
            (*==================================================*)
            TCPSVR_SOCKOPT_DELAYEDACK:
            (*==================================================*)
              if (pConn^.ConnSockOpt.DelayedAck = false) then
                pParaValue^ := 0;
              else
                pParaValue^ := 1;
              end_if;
            (*==================================================*)
            TCPSVR_SOCKOPT_REUSEADDR:
            (*==================================================*)
              if (pConn^.ConnSockOpt.ReuseAddr = false) then
                pParaValue^ := 0;
              else
                pParaValue^ := 1;
              end_if;
            (*==================================================*)
            else // - INVALID SUB COMMAND
            (*==================================================*)
              Retcode := TCP_SVR_ERR_SET_PARA_INVALID_SUB_CMD;
          end_case;

        (*================================================================*)
        TCPSVR_CMD_KEEPALIVEPARA: // - ASYNC TASK PRIORITY
        (*================================================================*)
          case SubCmd of
            (*==================================================*)
            TCPSVR_KEEPALIVE_KEEPIDLE:
            (*==================================================*)
              pParaValue^ := pConn^.KeepAlivePara.keepIDLE;
            (*==================================================*)
            TCPSVR_KEEPALIVE_KEEPINTVL:
            (*==================================================*)
              pParaValue^ := pConn^.KeepAlivePara.keepINTVL;
            (*==================================================*)
            TCPSVR_KEEPALIVE_KEEPCNT:
            (*==================================================*)
              pParaValue^ := pConn^.KeepAlivePara.keepCNT;
            (*==================================================*)
            else // - INVALID SUB COMMAND
            (*==================================================*)
              Retcode := TCP_SVR_ERR_SET_PARA_INVALID_SUB_CMD;
          end_case;

        (*================================================================*)
        TCPSVR_CMD_CLOSESOCKETTYPE:
        (*================================================================*)
          case SubCmd of
            (*==================================================*)
            TCPSVR_CLOSESOCKETTYPE:
            (*==================================================*)
              pParaValue^$UDINT := pConn^.CloseSocketType;
            (*==================================================*)
            else // - INVALID SUB COMMAND
            (*==================================================*)
              Retcode := TCP_SVR_ERR_SET_PARA_INVALID_SUB_CMD;
          end_case;

        (*================================================================*)
        else // - INVALID COMMAND
        (*================================================================*)
          Retcode := TCP_SVR_ERR_SET_PARA_INVALID_CMD;

      end_case;
    else
      Retcode := TCP_SVR_ERR_INVALID_SOCKET;
    end_if;
  else
    Retcode := TCP_SVR_ERR_INVALID_SOCKET;
  end_if;

END_FUNCTION

FUNCTION _TCPIP_SERVER::CheckSocketValid
VAR_INPUT
  dSock 	  : DINT;
  ppConn    : ^pVoid;
END_VAR
VAR_OUTPUT
  Retcode 	: BOOL;
END_VAR
VAR
	i         : USINT;
END_VAR

  Retcode := false;
  if (ppConn <> NIL) then
    ppConn^ := NIL;
  end_if;

  for i := 0 to (MaxConn-1) do
    if (SocketArray[i].dSocket = dSock) then
      if (ppConn <> NIL) then
        ppConn^ := (#SocketArray[i])$^void;
      end_if;
      Retcode := true;
      exit; 
    end_if;
  end_for;

END_FUNCTION
