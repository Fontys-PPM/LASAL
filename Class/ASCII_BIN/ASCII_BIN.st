//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)
//{{LSL_DECLARATION

(*!
<Class
	Name               = "ASCII_BIN"
	Revision           = "1.20"
	GUID               = "{CBAEE384-C115-4DE8-8094-C7D4F0EF8746}"
	RealtimeTask       = "false"
	CyclicTask         = "false"
	BackgroundTask     = "false"
	Sigmatek           = "true"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	IconPath           = ".\Class\ASCII_BIN\convert.ICO"
	SharedCommandTable = "true"
	Objectsize         = "(378,120)"
	Comment            = "converts ASCII to BIN values&#13;&#10;">
	<Channels>
		<Server Name="Obj_channel" GUID="{AA790E5E-E4EC-4B0F-80BB-3FC837048BBA}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="you can call the method Ascii2Bin, Bin2Ascii, Ascii2udBin or udBin2Ascii"/>
	</Channels>
	<RevDoku>
		<Owner Company="Sigmatek"/>
		<Dokumentation Revision="1.20" Date="2013-07-12" Author="spimar" Company="Sigmatek" Description="- complemented method comments&#13;&#10;- ARM ready&#13;&#10;- Fixed a bug in Ascii2Bin() to be able to convert a full DINT value;&#13;&#10;- Now it is possible to convert a unrestricted number of characters (Ascii2Bin, Ascii2udBin). &#13;&#10;- If the number of characters doesn’t fit into the datatype(DINT, UDINT), an errorbit is set and the value is cut off at the last character which fits into the datatype;"/>
		<Dokumentation Revision="1.10" Date="2012-06-28" Author="spimar" Company="Sigmatek" Description="The global functions are now virtual;"/>
		<Dokumentation Revision="1.9" Date="2012-02-09" Author="spimar" Company="Sigmatek" Description="The functions Ascii2udBin and Ascii2Bin doesn&apos;t support a string which begins with a plus &apos;+&apos; sign."/>
		<Dokumentation Revision="1.8" Date="2011-11-22" Author="FesGue" Company="Sigmatek" Description="In the functions Ascii2udBin and Ascii2Bin was an error when the input string has wrong signs. (not 0-9 or &apos;.&apos;);"/>
		<Dokumentation Revision="1.7" Date="2011-08-08" Author="FesGue" Company="Sigmatek" Description="Function ASCII2BIN and ASCII2udBIN returns wrong number of digits"/>
		<Dokumentation Revision="1.6" Date="2011-05-17" Author="spimar" Company="Sigmatek" Description="Added methods to convert in or from a UDINT (udBIN2ASCII &amp; ASCII2udBIN&#13;&#10;Wrong format was given back in funktion ASCII2BIN! The number of &apos;0&apos; before the real number starts, was counted!"/>
		<Dokumentation Revision="1.5" Date="20.10.10" Author="WalRob" Company="Sigmatek" Description="Change:&#13;&#10;Wrong Dec. Point position by Translate negativ ASCII Values to Bin&#13;&#10;Wrong Dec. Point position by Translate Numbers with Comma befor or after the ASCII String"/>
		<Dokumentation Revision="1.4" Date="28.08.2010" Author="BleErn" Company="Sigmatek" Description="-2147483648 was not converted correct"/>
		<Dokumentation Revision="1.3" Date="30.04.09" Author="hötant" Company="Sigmatek" Description="Changed LSL_TARGETARCH_ARM to _LSL_TARGETARCH_ARM"/>
		<Dokumentation Revision="1.2" Date="09.02.09" Author="hötant" Company="Sigmatek" Description="AWL to ST (to guarantee compatibility for other processors)"/>
	</RevDoku>
</Class>
*)
ASCII_BIN : CLASS
  //Servers:
	Obj_channel 	: SvrChCmd_DINT;
  //Clients:
  //Variables:
  //Functions:
				//! <Function Comment=" *************************************************************************&#13;&#10;                BIN to ASCII converter&#13;&#10;  The input variables of this function have to be a&#13;&#10;  pointer  on a  Char-String, the value you want to convert(DINT)&#13;&#10;  and a scheme(BINT). In the scheme you must define the number&#13;&#10; of digits to convert, the position of the decimal point,&#13;&#10; hasty zeros or not and if the descendant zeros should be&#13;&#10; deleted or not.&#13;&#10; -------------scheme------------------------------&#13;&#10;       xxxx xx00 0000 0000&#13;&#10;       .... .... .... **** no. of digits&#13;&#10;       .... .... **** ....    pos. of decimal point (from lowest sign.)&#13;&#10;       .... ...* .... ....    reminding digits fill with hasty zeros&#13;&#10;   .... ..*. .... .... delete descendant zeros&#13;&#10;&#13;&#10;     16#0224$BINT&#13;&#10;       |||........   no. of digits&#13;&#10;       ||.........   pos. of decimal point&#13;&#10;        |..........   0 without hasty zeros&#13;&#10;                      1 with hasty zeros&#13;&#10;                     2 delete descendant zeros (the&#13;&#10;         digits have to be the real number&#13;&#10;         of digits, without the deleted&#13;&#10;         zeros! f.e.: &#13;&#10;         12.900 =&gt; 12.9 that means 3 digits!)&#13;&#10;&#13;&#10; If an error occures during the conversion, the first CHAR in&#13;&#10; your string will be set to &apos;?&apos; (this f.e. could be the result&#13;&#10;  of a wrong number of digits). The status of all other CHAR in&#13;&#10; the String is undefined!&#13;&#10; *************************************************************************&#13;&#10;    created   :   MS    :     KW 12/02&#13;&#10; *************************************************************************&#13;&#10;                    operation of BIN2ASCII function&#13;&#10; *************************************************************************&#13;&#10;&#13;&#10; *************************************************************************&#13;&#10;                BIN to ASCII Konverter&#13;&#10;  &#13;&#10;  Übergeben Sie der Funktion einen Pointer auf ein CHAR-Feld, die&#13;&#10; Zahl die in ASCII gewandelt werden soll (vom Typ DINT) und das&#13;&#10; Format nach welchem die Zahl gewandelt wird. Im Format muss&#13;&#10; folgendes angegeben werden: die Anzahl der Stellen, die &#13;&#10;  Position des Kommas, ob Vornullen verwendet werden und ob &#13;&#10; Nachnullen gelöscht werden sollen. &#13;&#10; -------------Format------------------------------&#13;&#10;       xxxx xx00 0000 0000&#13;&#10;       .... .... .... **** Anz. der Stellen&#13;&#10;       .... .... **** ....    pos. des Komma (von hinten)&#13;&#10;       .... ...* .... ....    restlichen Stellen mit Vornullen auffüllen&#13;&#10;   .... ..*. .... .... Nachnullen löschen&#13;&#10;&#13;&#10;     16#0224$BINT&#13;&#10;       |||........   Anz. der Stellen&#13;&#10;       ||.........   pos. des Komma (von hinten)&#13;&#10;        |..........   0 ohne Vornullen&#13;&#10;                      1 mit Vornullen auffüllen&#13;&#10;                     2 Nachnullen löschen (die Anz. der&#13;&#10;         Stellen muss genau der Anz. der&#13;&#10;         Gewandelten entsprechen, ohne &#13;&#10;         Nachnullen! z.B.:&#13;&#10;         12.900 =&gt; 12.9 d.h. 3 Stellen!)  &#13;&#10; Wenn bei der Wandlung ein Fehler aufgetreten ist, wir das &#13;&#10; erste Zeichen im CHAR-String auf &apos;?&apos; gesetzt (könnte z.B.&#13;&#10;  durch eine falsche Anzahl Stellen auftreten). Alle Anderen&#13;&#10; haben einen nicht definierten Zustand!&#13;&#10; *************************************************************************&#13;&#10;    erstellt   :   MS    :     KW 12/02&#13;&#10; *************************************************************************&#13;&#10;                    operation of BIN2ASCII function&#13;&#10; *************************************************************************&#13;&#10;[&gt;pt]Pointer auf CHAR-String&#13;&#10;[&gt;value]zu konvertierende Zahl&#13;&#10;[&gt;format]das Format&#13;&#10;" Name="Bin2Ascii"/>
	FUNCTION VIRTUAL GLOBAL Bin2Ascii
		VAR_INPUT
			pt 	: ^CHAR;			//! <Variable Comment="pointer at CHAR-String" Name="Bin2Ascii.pt"/>
			value 	: DINT;			//! <Variable Comment="value to convert" Name="Bin2Ascii.value"/>
			format 	: BINT;			//! <Variable Comment="scheme for the conversion" Name="Bin2Ascii.format"/>
		END_VAR;
	
	FUNCTION VIRTUAL Ascii2BinST
		VAR_INPUT
			pta 	: ^CHAR;
			ptb 	: ^BINT;
		END_VAR
		VAR_OUTPUT
			ret_value 	: DINT;
		END_VAR;
				//! <Function Comment="*************************************************************************&#13;&#10;//    ASCII to BIN Konverter&#13;&#10;//  Übergeben Sie der Funktion den Pointer auf einen&#13;&#10;//  Char-String und den Pointer auf das Format(2 Byte Wert BINT).&#13;&#10;//  im Format werden nach der Wandlung folgende Daten für&#13;&#10;//  die gewandelte Zahl angezeigt:&#13;&#10;//&#13;&#10;//   -------------Format------------------------------&#13;&#10;//&#13;&#10;//       xxxx Oxxx 0000 0000&#13;&#10;//       .... .... .... **** Anz. der Stellen&#13;&#10;//       .... .... **** ....    pos. des Komma (von hinten)&#13;&#10;//       .... *... .... ....    Vorzeichen (True ist minus)&#13;&#10;//&#13;&#10;//&#13;&#10;//  Das Ergebnis der Wandlung ist ein direkter Rückgabewert&#13;&#10;//  der Funktion (DINT). Falls der zu wandelnde String fehlerhaft&#13;&#10;//  ist, wird als Ergebnis 0 zurückgegeben und im Format&#13;&#10;//  steht:&#13;&#10;//&#13;&#10;//  16#FFFF ..... ausgegebenes Format bei Wandlungsfehler&#13;&#10;//&#13;&#10;// *************************************************************************&#13;&#10;//    erstellt  :   MS    :     KW 12/02&#13;&#10;//      geändert  :     RV      :      KW 43/08&#13;&#10;// *************************************************************************&#13;&#10;//                    operation of ASCII2BIN function&#13;&#10;// *************************************************************************&#13;&#10;//[&gt;pta]Pointer auf CHAR-String&#13;&#10;//[&gt;ptb]Pointer auf Zahlen-Format&#13;&#10;//[&lt;ret_value]gewandelte Zahl aus ASCII-String&#13;&#10;//[#ENGLISH]&#13;&#10;// *************************************************************************&#13;&#10;//    ASCII to BIN Konverter&#13;&#10;//  The input variables of this function have to be a&#13;&#10;//  pointer  on a  Char-String  and a pointer  on a&#13;&#10;//  scheme(BINT). After the  conversion, the scheme will&#13;&#10;//  contain following data for your result&#13;&#10;//&#13;&#10;//   -------------scheme------------------------------&#13;&#10;//&#13;&#10;//       xxxx Oxxx 0000 0000&#13;&#10;//       .... .... .... **** no. of digits&#13;&#10;//       .... .... **** ....    pos. of decimal point (from lowest sign.)&#13;&#10;//       .... *... .... ....    sign (True ist minus)&#13;&#10;//&#13;&#10;//&#13;&#10;// The result of the conversion is immediately returned from&#13;&#10;//  the function (DINT). If the string contains errors (f.e. wrong&#13;&#10;//  signs, letters, ...) then the function will return zero&#13;&#10;//  and the scheme will be set to:&#13;&#10;//&#13;&#10;//  16#FFFF ...... scheme if error occured&#13;&#10;//&#13;&#10;// *************************************************************************&#13;&#10;//    created   :   MS    :     KW 12/02&#13;&#10;//      modified  :     RV      :      KW 43/08&#13;&#10;// *************************************************************************&#13;&#10;//                    operation of ASCII2BIN function&#13;&#10;// *************************************************************************&#13;&#10;//&#13;&#10;//&#13;&#10;//[&gt;pta]Pointer at CHAR-String&#13;&#10;//[&gt;ptb]Pointer at number-scheme&#13;&#10;//[&lt;ret_value]dec. Number from ASCII-String&#13;&#10;&#13;&#10; //GLOBAL ASCII_BIN::Ascii2Bin" Name="Ascii2Bin"/>
	FUNCTION VIRTUAL GLOBAL Ascii2Bin
		VAR_INPUT
			pta 	: ^CHAR;			//! <Variable Comment="pointer to a buffer where the string is stored" Name="Ascii2Bin.pta"/>
			ptb 	: ^BINT;			//! <Variable Comment="scheme for the conversion" Name="Ascii2Bin.ptb"/>
		END_VAR
		VAR_OUTPUT
			ret_value 	: DINT;			//! <Variable Comment="output variable is the converted value" Name="Ascii2Bin.ret_value"/>
		END_VAR;
				//! <Function Comment="To convert a number (UDINT) to a string!" Name="udBin2Ascii"/>
	FUNCTION VIRTUAL GLOBAL udBin2Ascii
		VAR_INPUT
			pt 	: ^CHAR;			//! <Variable Comment="Pointer to the String where the value be saved" Name="udBin2Ascii.pt"/>
			value 	: UDINT;			//! <Variable Comment="Value which be converted" Name="udBin2Ascii.value"/>
			format 	: BINT;			//! <Variable Comment="scheme for the conversion" Name="udBin2Ascii.format"/>
		END_VAR;
				//! <Function Comment="To convert a string into a number(UDINT)" Name="Ascii2udBin"/>
	FUNCTION VIRTUAL GLOBAL Ascii2udBin
		VAR_INPUT
			pta 	: ^CHAR;			//! <Variable Comment="String which contains the value" Name="Ascii2udBin.pta"/>
			ptb 	: ^BINT;			//! <Variable Comment="contains the format" Name="Ascii2udBin.ptb"/>
		END_VAR
		VAR_OUTPUT
			ret_value 	: UDINT;			//! <Variable Comment="output variable is the converted value" Name="Ascii2udBin.ret_value"/>
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

//}}LSL_DECLARATION


FUNCTION GLOBAL TAB ASCII_BIN::@CT_
0$UINT,
2#0100000000000000$UINT, //TY_ASCII_BIN
1$UINT, 20$UINT, (SIZEOF(::ASCII_BIN))$UINT, 
1$UINT, 0$UINT, 0$UINT, 
TO_UDINT(2897291062), "ASCII_BIN", //Class
TO_UDINT(0), 0, 0$UINT, 0$UINT, //Baseclass
//Servers:
(::ASCII_BIN.Obj_channel.pMeth)$UINT, _CH_CMD$UINT, 2#0000000000000000$UINT, TO_UDINT(1930579080), "Obj_channel", 
//Clients:
END_FUNCTION


#define USER_CNT_ASCII_BIN 5

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_ASCII_BIN] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION ASCII_BIN::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
	END_VAR

	//Command Methods
	InitCmdTable (nCmd := nSTDCMD + USER_CNT_ASCII_BIN, pCmd := #vmt.CmdTable);
#pragma warning (disable : 74)
	vmt.UserFcts[0]		:= #Bin2Ascii();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[1]		:= #Ascii2BinST();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[2]		:= #Ascii2Bin();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[3]		:= #udBin2Ascii();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[4]		:= #Ascii2udBin();

#pragma warning (default : 74)
	Obj_channel.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF Obj_channel.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;

END_FUNCTION

//{{LSL_IMPLEMENTATION


//*********************Inserted from .\code\ASCII_BIN_01_00.st*********************

 



//[#DEUTSCH]
// *************************************************************************
//				ASCII to BIN Konverter
//  Übergeben Sie der Funktion den Pointer auf einen
//  Char-String und den Pointer auf das Format(2 Byte Wert BINT).
//  im Format werden nach der Wandlung folgende Daten für
//  die gewandelte Zahl angezeigt:
//
//   -------------Format------------------------------
//
//       xxxx Oxxx 0000 0000
//       .... .... .... ****	Anz. der Stellen
//       .... .... **** ....    pos. des Komma (von hinten)
//       .... *... .... ....    Vorzeichen (True ist minus)
//
//
//  Das Ergebnis der Wandlung ist ein direkter Rückgabewert
//  der Funktion (DINT). Falls der zu wandelnde String fehlerhaft
//  ist, wird als Ergebnis 0 zurückgegeben und im Format
//  steht:
//
//		16#FFFF ..... ausgegebenes Format bei Wandlungsfehler
//
// *************************************************************************
//  		erstellt 	: 		MS 			:  		 KW 12/02
//      geändert  :     RV      :      KW 43/08
// *************************************************************************
//                    operation of ASCII2BIN function
// *************************************************************************
//[>pta]Pointer auf CHAR-String
//[>ptb]Pointer auf Zahlen-Format
//[<ret_value]gewandelte Zahl aus ASCII-String
//[#ENGLISH]
// *************************************************************************
//				ASCII to BIN Konverter
//  The input variables of this function have to be a
//  pointer  on a  Char-String  and a pointer  on a
//  scheme(BINT). After the  conversion, the scheme will
//  contain following data for your result
//
//   -------------scheme------------------------------
//
//       xxxx Oxxx 0000 0000
//       .... .... .... ****	no. of digits
//       .... .... **** ....    pos. of decimal point (from lowest sign.)
//       .... *... .... ....    sign (True ist minus)
//
//
//	The result of the conversion is immediately returned from
//  the function (DINT). If the string contains errors (f.e. wrong
//  signs, letters, ...) then the function will return zero
//  and the scheme will be set to:
//
//		16#FFFF ...... scheme if error occured
//
// *************************************************************************
//  		created  	: 		MS 			:  		 KW 12/02
//      modified  :     RV      :      KW 43/08
// *************************************************************************
//                    operation of ASCII2BIN function
// *************************************************************************
//
//
//[>pta]Pointer at CHAR-String
//[>ptb]Pointer at number-scheme
//[<ret_value]dec. Number from ASCII-String

 //GLOBAL ASCII_BIN::Ascii2Bin


//[#ENGLISH]
// *************************************************************************
//                BIN to ASCII converter
//  The input variables of this function have to be a
//  pointer  on a  Char-String, the value you want to convert(DINT)
//  and a scheme(BINT). In the scheme you must define the number
//	of digits to convert, the position of the decimal point,
//	hasty zeros or not and if the descendant zeros should be
//	deleted or not.
//
//	-------------scheme------------------------------
//
//       xxxx xx00 0000 0000
//       .... .... .... ****	no. of digits
//       .... .... **** ....    pos. of decimal point (from lowest sign.)
//       .... ...* .... ....    reminding digits fill with hasty zeros
//		 .... ..*. .... ....	delete descendant zeros
//
//
// 		  16#0224$BINT
//   		  |||........   no. of digits
//   		  ||.........   pos. of decimal point
//    		  |..........   0 without hasty zeros
//                    		1 with hasty zeros
//                   		2 delete descendant zeros (the
//							  digits have to be the real number
//							  of digits, without the deleted
//							  zeros! f.e.: 
//							  12.900 => 12.9 that means 3 digits!)
//
//
//	If an error occures during the conversion, the first CHAR in
//	your string will be set to '?' (this f.e. could be the result
// 	of a wrong number of digits). The status of all other CHAR in
//	the String is undefined!
//
// *************************************************************************
//  		created  	: 		MS 			:  		 KW 12/02
// *************************************************************************
//                    operation of BIN2ASCII function
// *************************************************************************
//
//[>pt]pointer at CHAR-String
//[>value]value to convert
//[>format]scheme for the conversion
//
//[#DEUTSCH]
// *************************************************************************
//                BIN to ASCII Konverter
//  
// 	Übergeben Sie der Funktion einen Pointer auf ein CHAR-Feld, die
//	Zahl die in ASCII gewandelt werden soll (vom Typ DINT) und das
//	Format nach welchem die Zahl gewandelt wird. Im Format muss
//	folgendes angegeben werden: die Anzahl der Stellen, die 
// 	Position des Kommas, ob Vornullen verwendet werden und ob 
//	Nachnullen gelöscht werden sollen. 
//
//	-------------Format------------------------------
//
//       xxxx xx00 0000 0000
//       .... .... .... ****	Anz. der Stellen
//       .... .... **** ....    pos. des Komma (von hinten)
//       .... ...* .... ....    restlichen Stellen mit Vornullen auffüllen
//		 .... ..*. .... ....	Nachnullen löschen
//
//
// 		  16#0224$BINT
//   		    |||........   Anz. der Stellen
//   		    ||.........   pos. des Komma (von hinten)
//    		  |..........   0 ohne Vornullen
//                    		1 mit Vornullen auffüllen
//                   		2 Nachnullen löschen (die Anz. der
//							  Stellen muss genau der Anz. der
//							  Gewandelten entsprechen, ohne 
//							  Nachnullen! z.B.:
//							  12.900 => 12.9 d.h. 3 Stellen!)		
//
//	Wenn bei der Wandlung ein Fehler aufgetreten ist, wir das 
//	erste Zeichen im CHAR-String auf '?' gesetzt (könnte z.B.
//  durch eine falsche Anzahl Stellen auftreten). Alle Anderen
//	haben einen nicht definierten Zustand!
//
// *************************************************************************
//  		erstellt  	: 		MS 			:  		 KW 12/02
// *************************************************************************
//                    operation of BIN2ASCII function
// *************************************************************************
//
//[>pt]Pointer auf CHAR-String
//[>value]zu konvertierende Zahl
//[>format]das Format
FUNCTION VIRTUAL GLOBAL ASCII_BIN::Bin2Ascii
	VAR_INPUT
		pt 	: ^CHAR;
		value 	: DINT;
		format 	: BINT;
	END_VAR
VAR
	tmp		: DINT;
	nk		: UINT;
	dig		: UINT;
	hp    : ^CHAR; 
	pd    : UINT; 
	h     : UINT;
  udValue : UDINT;
END_VAR

	if((format AND 16#000F) = 0) then
		format := format OR 16#0800;
	end_if;

	if(format AND 16#0800) then
		tmp  := value;
		if tmp = 0 then
			dig := 1;
		else
			dig := 0;
		end_if;

	    while(tmp) do
	    
			tmp := tmp / 10;
			dig += 1;
	    end_while;

	    nk := ((format SHR 4) AND 16#0F);
	    
		if(nk >= dig) then
	      dig := nk + 1;
		end_if;
	    
		format := (format AND 16#FFF0) OR (dig AND 16#000F);
	end_if;


  dig := (format and 16#0F);		// Anzahl der Stellen
  hp  := pt + dig; 					// pointer auf String-Ende
  tmp := value; 					// Zahl
  pd  := (format shr 4) and 16#0F;	// position des Komma

  
  if(value < 0) then  		// kontrolle ob Zahl negativ
	hp    += 1;    
    //value := -value;		// Zahl * (-1)//BleErn 28.08.2010 15:03
    pt^   := '-';			// Erstes Zeichen auf '-' setzen
  end_if; 	 

  udValue := to_UDINT(abs(value));//BleErn 28.08.2010 15:03

  if(format and 16#0200) then   // Nachnullen löschen
    h := pd; 
	while(h) do					// Nur Nullen hinter Komma
	  h -= 1; 
	  if((udValue mod 10) = 0) then	// Ist Ziffer Null?
	    udValue := udValue / 10; 	// wenn ja, Null löschen
		pd -= 1; 
      else
	    h := 0; 
      end_if; 

	end_while; 
  end_if; 
  
  if(pd <> 0) then    	// Komma noch zu setzen?
    hp += 1;
  end_if; 

  hp^ := 0;           	// String mit Ascii-0 abschließen
  hp  -= 1;   

  repeat
    hp^   := '0' + TO_USINT(udValue mod 10); //akt. Ziffer
	hp    -= 1; 
	pd    -= 1; 
	dig   -= 1; 
	if(pd = 0)then		//	Komma setzen?
	  hp^ := '.';
	  hp -= 1; 
    end_if; 

    udValue := udValue / 10; 	// nächste Ziffer	
    
    if((dig = 0) & (udValue <> 0)) then	// Zahl zu groß 
	  pt^   := '?'; 	// Formatfehler
	  udValue := 0; 
	end_if; 
  until(udValue = 0) end_repeat; 
 
 
  if(dig > 0) then 	// mit Vornullen auffüllen
	repeat			// so lange bis Digits auf Null
      if((format and 16#0100)|(pd$INT >= 0)) then   // Vornullen im 
        hp^ := '0'; 								// Format angegeben?
      else			// formatfehler (digit zu groß und keine Vornullen) 
	    pt^   := '?'; 	// Formatfehler	
	    udValue := 0; 		
      end_if; 
      pd -= 1;
	  hp -= 1;
      if(pd = 0) then	// Komma setzen
	    hp^ := '.';
	    hp -= 1; 
      end_if; 
	  dig -= 1; 	
	until(dig = 0) end_repeat; 	// letzte Ziffer?
  end_if;

END_FUNCTION //GLOBAL ASCII_BIN::Bin2Ascii


FUNCTION VIRTUAL ASCII_BIN::Ascii2BinST
	VAR_INPUT
		pta 	: ^CHAR;
		ptb 	: ^BINT;
	END_VAR
	VAR_OUTPUT
		ret_value 	: DINT;
	END_VAR
VAR
	fehler	    :	UDINT;					// Flag für fehlerhaften String
	m_dec_point	:	SINT;				    // Flag für Komma
	wert	      :	DINT;
	counter	    :	USINT;
  neg         : BOOL;
  cnt_start   : BOOL;
  overflow    : BOOL;
END_VAR
  wert        := 0;
  neg         := false;
  fehler      := 0;
  counter     := 0;
  m_dec_point := -1;
  ptb^        := 0;
  cnt_start   := false;
  overflow    := false;

  
  while (pta^ <> 0 & fehler = 0 & overflow = false) do   //-------------------------------------spimar 17.5.11 
//    if cnt_start = true then FesGue08.08.2011       // counter starts after the 0 before
//      counter += 1;
//    end_if;
    if ( pta^ > '0' | pta^ = '.' | pta^ = '-' | pta^ = '+') & cnt_start = false then
      cnt_start := true;
    end_if; //-------------------------------------
    if cnt_start = true then  //FesGue08.08.2011       // counter starts after the 0 before
      counter += 1;
    end_if;
    if (pta^ = '-') then
      neg := true;
      counter -= 1;
    elsif (pta^ >= '0' & pta^ <= '9') then
      if (wert > 16#7FFFFFFF / 10) then
        overflow := true; // if an overflow occurs, the overflow mark is set
//        fehler := 16#FFFF; // its no error
      elsif (wert * 10 = 16#7FFFFFF8) then
        if (neg = true) then
          if (pta^ <= '8') then
            wert *= 10;
            wert += pta^ - '0';
          else
            overflow := true;
          end_if;
        else
          if (pta^ <= '7') then
            wert *= 10;
            wert += pta^ - '0';
          else
            overflow := true;
          end_if;
        end_if;
      else
        wert *= 10;
        wert += pta^ - '0';
      end_if;
    elsif (pta^ = '.') then
      if (m_dec_point = -1) then
        counter -= 1; //FesGue08.08.2011 ?? // SpiMar 17.5.11 to correct the number places
        m_dec_point := counter$SINT;
      else
        fehler := 16#FFFF;
      end_if;
    elsif (wert > 0) then
      fehler := 1;
    elsif (pta^ = '+') then
      counter -= 1;
    else 
      fehler := 16#FFFF;
    end_if;
    pta += sizeof(USINT);
  end_while;
  
  //if (fehler <> 16#FFFF) then //FesGue 22.11.11
  if (fehler = 0) then // don´t do this when a error is occured
    if (m_dec_point <> -1) & (m_dec_point < counter$SINT) then
      ptb^ := (counter - m_dec_point)$BINT;
    end_if;
    ptb^ := ptb^ shl 4;
    ptb^ += counter;
    if (neg = true) then
      wert *= (-1);
      ptb^.12 := 1;
    end_if;
    if (overflow = true) then // set errorbit if the value runs over
      ptb^.13 := 1;           // anused bit is set
    end_if;
    ret_value := wert;
  else
    ptb^ := 16#FFFF;
    ret_value := 0;
  end_if;
  //ret_value := wert;//FesGue 22.11.11

END_FUNCTION


FUNCTION VIRTUAL GLOBAL ASCII_BIN::Ascii2Bin
VAR_INPUT
  pta 	: ^CHAR;
  ptb 	: ^BINT;
END_VAR
VAR_OUTPUT
  ret_value 	: DINT;
END_VAR

    ret_value := Ascii2BinST(pta:= pta, ptb:= ptb);
    
END_FUNCTION

FUNCTION VIRTUAL GLOBAL ASCII_BIN::udBin2Ascii
	VAR_INPUT
		pt 	: ^CHAR;
		value 	: UDINT;
		format 	: BINT;
	END_VAR
VAR
	tmp		: UDINT;
	nk		: UINT;
	dig		: UINT;
	hp    : ^CHAR; 
	pd    : UINT; 
	h     : UINT;
END_VAR

	if((format AND 16#000F) = 0) then
		format := format OR 16#0800;
	end_if;

	if(format AND 16#0800) then
		tmp  := value;
		if tmp = 0 then
			dig := 1;
		else
			dig := 0;
		end_if;

	    while(tmp) do
	    
			tmp := tmp / 10;
			dig += 1;
	    end_while;

	    nk := ((format SHR 4) AND 16#0F);
	    
		if(nk >= dig) then
	      dig := nk + 1;
		end_if;
	    
		format := (format AND 16#FFF0) OR (dig AND 16#000F);
	end_if;


  dig := (format and 16#0F);		// Anzahl der Stellen
  hp  := pt + dig; 					// pointer auf String-Ende
  tmp := value; 					// Zahl
  pd  := (format shr 4) and 16#0F;	// position des Komma

  if(format and 16#0200) then   // Nachnullen löschen
    h := pd; 
	while(h) do					// Nur Nullen hinter Komma
	  h -= 1; 
	  if((value mod 10) = 0) then	// Ist Ziffer Null?
	    value := value / 10; 	// wenn ja, Null löschen
		pd -= 1; 
      else
	    h := 0; 
      end_if; 

	end_while; 
  end_if; 
  
  if(pd <> 0) then    	// Komma noch zu setzen?
    hp += 1;
  end_if; 

  hp^ := 0;           	// String mit Ascii-0 abschließen
  hp  -= 1;   

  repeat
    hp^   := '0' + TO_USINT(value mod 10); //akt. Ziffer
	hp    -= 1; 
	pd    -= 1; 
	dig   -= 1; 
	if(pd = 0)then		//	Komma setzen?
	  hp^ := '.';
	  hp -= 1; 
    end_if; 

    value := value / 10; 	// nächste Ziffer	
    
    if((dig = 0) & (value <> 0)) then	// Zahl zu groß 
	  pt^   := '?'; 	// Formatfehler
	  value := 0; 
	end_if; 
  until(value = 0) end_repeat; 
 
 
  if(dig > 0) then 	// mit Vornullen auffüllen
	repeat			// so lange bis Digits auf Null
      if((format and 16#0100)|(pd$INT >= 0)) then   // Vornullen im 
        hp^ := '0'; 								// Format angegeben?
      else			// formatfehler (digit zu groß und keine Vornullen) 
	    pt^   := '?'; 	// Formatfehler	
	    value := 0; 		
      end_if; 
      pd -= 1;
	  hp -= 1;
      if(pd = 0) then	// Komma setzen
	    hp^ := '.';
	    hp -= 1; 
      end_if; 
	  dig -= 1; 	
	until(dig = 0) end_repeat; 	// letzte Ziffer?
  end_if;


END_FUNCTION


FUNCTION VIRTUAL GLOBAL ASCII_BIN::Ascii2udBin
	VAR_INPUT
		pta 	: ^CHAR;
		ptb 	: ^BINT;
	END_VAR
	VAR_OUTPUT
		ret_value 	: UDINT;
	END_VAR
VAR
	fehler	    :	UDINT;					// Flag für fehlerhaften String
	m_dec_point	:	SINT;				    // Flag für Komma
	wert	      :	UDINT;
	counter	    :	USINT;
  cnt_start   : BOOL;
  overflow    : BOOL;
END_VAR
  wert        := 0;
  fehler      := 0;
  counter     := 0;
  m_dec_point := -1;
  ptb^        := 0;
  cnt_start   := false;
  overflow    := false;

  while (pta^ <> 0 & fehler = 0 & overflow = false) do 
//    if cnt_start = true then
//      counter += 1;
//    end_if;
    if ( pta^ > '0' | pta^ = '.' | pta^ = '-' | pta^ = '+') & cnt_start = false then
      cnt_start := true;
    end_if;
    if cnt_start = true then
      counter += 1;
    end_if;
    
    if (pta^ = '-') then
      ret_value := 0;
      return;
    elsif (pta^ >= '0' & pta^ <= '9') then
      if (wert > 16#FFFFFFFF / 10) then
        overflow := true;
//        fehler := 16#FFFF;
      elsif (wert * 10 = 16#FFFFFFFA) then
        if (pta^ <= '5') then
          wert *= 10;
          wert += pta^ - '0';
        else
          overflow := true;
        end_if;
      else
        wert *= 10;
        wert += pta^ - '0';
      end_if;
    elsif (pta^ = '.') then
      if (m_dec_point = -1) then
        counter -= 1;
        m_dec_point := counter$SINT;
      else
        fehler := 16#FFFF;
      end_if;
    elsif (wert > 0) then
      fehler := 1;
    elsif (pta^ = '+') then
      counter -= 1;
    else 
      fehler := 16#FFFF;
    end_if;
    pta += sizeof(USINT);
  end_while;
  
  //if (fehler <> 16#FFFF) then //FesGue 22.11.11
  if (fehler = 0) then // don´t do this when a error is occured
    if (m_dec_point <> -1) & (m_dec_point < counter$SINT) then
      ptb^ := (counter - m_dec_point)$BINT;
    end_if;
    ptb^ := ptb^ shl 4;
    ptb^ += counter;
    if (overflow = true) then
      ptb^.13 := 1;
    end_if;
    ret_value := wert;
  else
    ptb^ := 16#FFFF;
    ret_value := 0; 
  end_if;
  //ret_value := wert; FesGue 22.11.11

END_FUNCTION
