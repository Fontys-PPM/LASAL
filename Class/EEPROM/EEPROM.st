//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)

//{{LSL_DEFINES
// Defines for Mutex Geeration
#define EEPROM_STR_MUTEX_NAME_SEPERATOR ".."
#define EEPROM_MUTEX_NAME_END_LENGTH 5
#define EEPROM_MUTEX_NAME_MAX_LENGTH 32
//}}LSL_DEFINES

//{{LSL_DECLARATION

(*!
<Class
	Name               = "EEPROM"
	Revision           = "1.11"
	GUID               = "{55A1BF94-76EA-4EE2-BFE4-BFD1A43BF119}"
	RealtimeTask       = "false"
	CyclicTask         = "false"
	BackgroundTask     = "false"
	Sigmatek           = "true"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	IconPath           = ".\Class\Tool.ico"
	SharedCommandTable = "true"
	Objectsize         = "(284,120)">
	<Channels>
		<Server Name="Server0" GUID="{4348A670-6E90-4B66-BEF6-578A7B610638}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Client Name="MasterConnect" Required="true" Internal="false"/>
	</Channels>
	<RevDoku>
		<Owner Company="Sigmatek"/>
		<Dokumentation Revision="1.11" Date="03.03.2014" Author="PieSte" Company="Sigmatek" Description="corrected methode ClkTyp7 (eeprom typ DAI081)"/>
		<Dokumentation Revision="1.10" Date="06.12.2013" Author="FucHer" Company="Sigmatek" Description="Changed AWL code to Structured Text."/>
	</RevDoku>
</Class>
*)
EEPROM : CLASS
  //Servers:
	Server0 	: SvrChCmd_DINT;
  //Clients:
	MasterConnect 	: CltChCmd_DiasMaster;
  //Variables:
		m_udPortAddr 	: UDINT;
		m_uiStationNo 	: UINT;
		m_usClockOff 	: USINT;
		m_usDataOff 	: USINT;
		m_uiReadType 	: UINT;
		m_usCSOff 	: USINT;
		m_usDataInOff 	: USINT;
		m_DAI081CS : BSINT
		[
		  1 Clock,
		  2 Input,
		  3 CSGround,
		];

		RegBL 	: USINT;
		RegBH 	: USINT;
		RegDX 	: UINT;
		pMutex 	: pVoid;
		mt_api 	: ^LSL_MT_TYPE;
  //Functions:
	
	FUNCTION EEPROM
		VAR_OUTPUT
			ret_code 	: ConfStates;
		END_VAR;
	
	FUNCTION CS_Typ7
		VAR_INPUT
			Enable 	: BOOL;
		END_VAR;
	
	FUNCTION RTOS_IF_Write
		VAR_INPUT
			dActData 	: UDINT;
			udPort 	: UDINT;
		END_VAR;
	
	FUNCTION RTOS_IF_Read
		VAR_INPUT
			udPort 	: UDINT;
		END_VAR
		VAR_OUTPUT
			byActData 	: SINT;
		END_VAR;
	
	FUNCTION CS_Enable
		VAR_INPUT
			udPort 	: UDINT;
		END_VAR;
	
	FUNCTION CS_Disable
		VAR_INPUT
			udPort 	: UDINT;
		END_VAR;
	
	FUNCTION Clk_EE
		VAR_INPUT
			udPort 	: UDINT;
		END_VAR;
	
	FUNCTION LatchAddress
		VAR_INPUT
			udPort 	: UDINT;
		END_VAR;
	
	FUNCTION ReadData
		VAR_INPUT
			udPort 	: UDINT;
		END_VAR;
	
	FUNCTION GetEESpecificData;
	
	FUNCTION GLOBAL InitEE
		VAR_INPUT
			udPortAddr 	: UDINT;
			uiStationNo 	: UINT;
			uiReadType 	: UINT;
		END_VAR;
	
	FUNCTION GLOBAL EE_Rd
		VAR_INPUT
			uiAddr 	: UINT;			//! <Variable Comment="Address in EEPROM" Name="EE_Rd.uiAddr"/>
		END_VAR
		VAR_OUTPUT
			RetDX 	: UINT;
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;" Name="EE_Start_Typ3"/>
	FUNCTION EE_Start_Typ3
		VAR_INPUT
			wAddr 	: UINT;			//! <Variable Comment="address (to set page)" Name="EE_Start_Typ3.wAddr"/>
			bDir 	: USINT;			//! <Variable Comment="0 - write, 1 - read" Name="EE_Start_Typ3.bDir"/>
		END_VAR;
	
	FUNCTION EE_BitIn_Typ3
		VAR_OUTPUT
			bData 	: USINT;
		END_VAR;
	
	FUNCTION EE_ReadByte_Typ3
		VAR_INPUT
			wAddr 	: UINT;
		END_VAR
		VAR_OUTPUT
			bData 	: USINT;
		END_VAR;
	
	FUNCTION EE_AdrOut_Typ3
		VAR_INPUT
			wAddr 	: UINT;
		END_VAR;
	
	FUNCTION EE_ByteIn_Typ3
		VAR_OUTPUT
			bData 	: USINT;
		END_VAR;
	
	FUNCTION EE_Stop_Typ3
		VAR_OUTPUT
			bResult 	: USINT;
		END_VAR;
	
	FUNCTION EE_BitOut_Typ3
		VAR_INPUT
			bBit 	: USINT;
		END_VAR;
	
	FUNCTION EE_RdTyp0_2
		VAR_INPUT
			uiAddr 	: UINT;
		END_VAR
		VAR_OUTPUT
			RetDX 	: UINT;
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;" Name="EE_CHK"/>
	FUNCTION GLOBAL EE_CHK
		VAR_INPUT
			pEEData 	: ^UINT;			//! <Variable Comment="pointer on the first byte of EEprom" Name="EE_CHK.pEEData"/>
			TYP 	: UINT;			//! <Variable Comment="0 .. old , 1 = new 16#73" Name="EE_CHK.TYP"/>
		END_VAR
		VAR_OUTPUT
			ChkOK 	: DINT;			//! <Variable Comment="0 = ok | -1 = Error" Name="EE_CHK.ChkOK"/>
		END_VAR;
	
	FUNCTION ReadTyp004
		VAR_INPUT
			uiAddr 	: UINT;
		END_VAR
		VAR_OUTPUT
			RetDX 	: UINT;
		END_VAR;
	
	FUNCTION LatchAdrTyp7;
	
	FUNCTION CSTyp4
		VAR_INPUT
			Enable 	: BOOL;
		END_VAR;
	
	FUNCTION ClkTyp7;
	
	FUNCTION AuslesTyp7;
	
	FUNCTION ClkTyp4;
	
	FUNCTION LatchAdrTyp4;
	
	FUNCTION SetDataTyp7;
	
	FUNCTION SetDataTyp4;
	
	FUNCTION AuslesTyp4;
	
	FUNCTION EEReadTyp7
		VAR_INPUT
			uiAddr 	: UINT;
		END_VAR
		VAR_OUTPUT
			value 	: UINT;
		END_VAR;
	
	FUNCTION AWL CS_Enable_AWL;
	
	FUNCTION AWL CS_Disable_AWL;
	
	FUNCTION AWL GLOBAL EE_CHK_AWL
		VAR_INPUT
			pEEData 	: ^UINT;
			TYP 	: UINT;
		END_VAR
		VAR_OUTPUT
			ChkOK 	: DINT;
		END_VAR;
	
	FUNCTION AWL Clk_EE_AWL;
	
	FUNCTION AWL EE_RdTyp0_2_AWL
		VAR_INPUT
			uiAddr 	: UINT;
		END_VAR
		VAR_OUTPUT
			DX 	: UINT;
		END_VAR;
	
	FUNCTION AWL LatchAddress_AWL;
	
	FUNCTION AWL ReadData_AWL;
	
	FUNCTION AWL ReadTyp004_AWL
		VAR_INPUT
			uiAddr 	: UINT;
		END_VAR
		VAR_OUTPUT
			DX 	: UINT;
		END_VAR;
	
	FUNCTION AWL LatchAdrTyp7_AWL;
	
	FUNCTION AWL ClkTyp7_AWL;
	
	FUNCTION AWL AuslesTyp7_AWL;
	
	FUNCTION AWL ClkTyp4_AWL;
	
	FUNCTION AWL LatchAdrTyp4_AWL;
	
	FUNCTION AWL SetDataTyp7_AWL;
	
	FUNCTION AWL SetDataTyp4_AWL;
	
	FUNCTION AWL AuslesTyp4_AWL;
	
	FUNCTION CreateMutex
		VAR_INPUT
			MutexName 	: ^CHAR;
			pThis 	: ^VirtualBase;
		END_VAR
		VAR_OUTPUT
			pv_RetMutex 	: pVoid;
		END_VAR;
	
	FUNCTION MutexStart
		VAR_INPUT
			pMutex 	: pVoid;
		END_VAR;
	
	FUNCTION MutexStop
		VAR_INPUT
			pMutex 	: pVoid;
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

#pragma usingLtd DiasMaster


//}}LSL_DECLARATION


FUNCTION GLOBAL TAB EEPROM::@CT_
0$UINT,
2#0100000000000000$UINT, //TY_EEPROM
1$UINT, 11$UINT, (SIZEOF(::EEPROM))$UINT, 
1$UINT, 1$UINT, 0$UINT, 
TO_UDINT(2784851678), "EEPROM", //Class
TO_UDINT(0), 0, 0$UINT, 0$UINT, //Baseclass
//Servers:
(::EEPROM.Server0.pMeth)$UINT, _CH_CMD$UINT, 2#0000000000000000$UINT, TO_UDINT(2759080719), "Server0", 
//Clients:
(::EEPROM.MasterConnect.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(1515240279), "MasterConnect", TO_UDINT(2647887450), "DiasMaster", 2$UINT, 33$UINT, 
END_FUNCTION


#define USER_CNT_EEPROM 0

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_EEPROM] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION EEPROM::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
	END_VAR

	//Command Methods
	InitCmdTable (nCmd := nSTDCMD + USER_CNT_EEPROM, pCmd := #vmt.CmdTable);
	Server0.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF Server0.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	ret_code	:= EEPROM();

END_FUNCTION

//{{LSL_IMPLEMENTATION


//*********************Inserted from .\EEPROM\EEPROM.ST*********************



 



(*****************************************************************************
*	
*	Class to read all EEPROMs on DiasModules
*	Created: Sigmatek / 2003
*	Changes:
*		1.2 => 1.3 / 11.10.2005 / Mark: //ws001
*			reading of EEPRom might cause RT runtime errors on ETT321
*		0.2 => 1.2 / 23.12.2004 / no Mark / ws
*			compatibility with Lasal Class 2
*			removed visible flags from internal servers
*		0.1 => 0.2 / 03.02.2004 / Mark: // #BS000
*			Took out a STI
*
******************************************************************************)

FUNCTION  EEPROM::EEPROM
VAR_OUTPUT
	ret_code		: CONFSTATES;
END_VAR

	ret_code	:= C_OK;

END_FUNCTION //  EEPROM::EEPROM

FUNCTION EEPROM::RTOS_IF_Read
	VAR_INPUT
		udPort 	: UDINT;
	END_VAR
	VAR_OUTPUT
		byActData 	: SINT;
	END_VAR
VAR
	Adress			: UDINT;
END_VAR
#ifdef _LSL_TARGETARCH_X86
	save_Reg();
#endif

	Adress := (m_uiStationNo*16#100) +udPort;
    byActData := (MasterConnect.Rd8Bit(Adress))$SINT;

#ifdef _LSL_TARGETARCH_X86
	restore_Reg();
#endif

END_FUNCTION

FUNCTION EEPROM::RTOS_IF_Write
VAR_INPUT
	dActData		: UDINT;
	udPort			: UDINT;					// port address
END_VAR
VAR
	Adress			: UDINT;
END_VAR

#ifdef _LSL_TARGETARCH_X86
	save_Reg();
#endif
//("FucHer 21.08.2013 17:20 \ via Mutex diesen Bereich schützen")
  MutexStart(pMutex);
  
	Adress := (m_uiStationNo*16#100) +udPort;
    MasterConnect.Wr8Bit(Adress,dActData$USINT);
  
  MutexStop(pMutex);
#ifdef _LSL_TARGETARCH_X86
	restore_Reg();
#endif

END_FUNCTION
FUNCTION EEPROM::CS_Enable
	VAR_INPUT
		udPort 	: UDINT;
	END_VAR

  RTOS_IF_Write(1, udPort);

END_FUNCTION
FUNCTION AWL EEPROM::CS_Enable_AWL
#ifdef _LSL_TARGETARCH_X86

			L.AL			1
			CALL			RTOS_IF_Write
#endif
END_FUNCTION
FUNCTION EEPROM::CS_Disable
	VAR_INPUT
		udPort 	: UDINT;
	END_VAR

  RTOS_IF_Write(0, udPort);

END_FUNCTION
FUNCTION AWL EEPROM::CS_Disable_AWL
#ifdef _LSL_TARGETARCH_X86

			L.AL			0
			CALL			RTOS_IF_Write
#endif
END_FUNCTION
// In : register BH : data
//      register EDI: port
FUNCTION EEPROM::Clk_EE
	VAR_INPUT
		udPort 	: UDINT;
	END_VAR

  RegBH := RegBH OR 16#02;
  RTOS_IF_Write(RegBH, udPort);
  
  RegBH := RegBH AND 16#FD;
  RTOS_IF_Write(RegBH, udPort);

END_FUNCTION
FUNCTION AWL EEPROM::Clk_EE_AWL
#ifdef _LSL_TARGETARCH_X86

			OR.BH			16#02
			L				BH
			CALL			RTOS_IF_Write
			AND.BH			16#FD
			L				BH
			CALL			RTOS_IF_Write
#endif
END_FUNCTION
FUNCTION EEPROM::LatchAddress
	VAR_INPUT
		udPort 	: UDINT;
	END_VAR
VAR
	i   :DINT;
END_VAR

  for i:=0 to 8 do
    RegBL := RegDX$USINT;
    RegBL := RegBL AND 2#00000100;
    RegBH := RegBH AND 2#11111011;
    RegBH := RegBH OR RegBL;

    RTOS_IF_Write(RegBH, udPort);
    Clk_EE(udPort);
    
    RegDX := RegDX ROL 1;
  end_for;

  RegBH := RegBH AND 2#11111011;
  
END_FUNCTION

FUNCTION	AWL	EEPROM::LatchAddress_AWL
#ifdef _LSL_TARGETARCH_X86

			L.ECX			9
LATCH		L.BL			DL
			AND.BL			2#00000100
			AND.BH			2#11111011
			OR.BH			BL
			L				BH
			CALL			RTOS_IF_Write
			CALL			EEPROM::Clk_EE
			ROL.DX			1
			LOOP			LATCH

			AND.BH			2#11111011
#endif
END_FUNCTION
#ifdef DIAS_ACCESS_RTOS
FUNCTION AWL EEPROM::ReadData
VAR
	udClkOff			: UDINT;
END_VAR
			S.EDI			udClkOff

			L.EDX			0
			L.ECX			16

READ_NEXT	SHL.DX			1
			CALL			EEPROM::Clk_EE
			LZXB.EDI		m_usDataOff
			CALL			RTOS_IF_Read
			L.EDI			udClkOff

			PUSH.D			ECX

			L.CX			m_uiReadType
			L				1
			SHL.AL			CL
			AND.BL			AL
			SHR.BL			CL
			OR.DL			BL

			POP.D			ECX

			LOOP			READ_NEXT

END_FUNCTION
#else
FUNCTION AWL EEPROM::ReadData_AWL
VAR
	udClkOff			: UDINT;
	udDataOff			: UDINT;
END_VAR
#ifdef _LSL_TARGETARCH_X86
			push			edi
			S.EDI			udClkOff

			L.EDX			EDI
			AND.EDX			16#FFFFFF00
			LZXB.ECX		m_usDataOff
			ADD.EDX			ECX
			S.EDX			udDataOff		

			L.EDX			0
			L.ECX			16

READ_NEXT	SHL.DX			1
			CALL			EEPROM::Clk_EE
			L.EDI			udDataOff
			CALL			RTOS_IF_Read
			L.EDI			udClkOff

			PUSH.D			ECX

			L.CX			m_uiReadType
			L				1
			SHL.AL			CL
			AND.BL			AL
			SHR.BL			CL
			OR.DL			BL

			POP.D			ECX

			LOOP			READ_NEXT
			pop				edi
#endif
END_FUNCTION
#endif

FUNCTION EEPROM::ReadData
VAR_INPUT
	udPort 	: UDINT;
END_VAR
VAR
	udDataOff			:UDINT;
  shift         :USINT;
  i             :DINT;
END_VAR

#ifdef DIAS_ACCESS_RTOS
  udDataOff := m_usDataOff;
#else
  udDataOff := (udPort AND 16#FFFFFF00) + m_usDataOff;
#endif

  RegDX := 0;
  
  for i:=0 to 15 do
    RegDX := RegDX SHL 1;
    Clk_EE(udPort);     //udClkOff
    RegBL := RTOS_IF_Read(udDataOff)$USINT;
    
    shift := (1$USINT SHL m_uiReadType$USINT);
    RegBL := RegBL AND (shift);
    RegBL := RegBL SHR m_uiReadType$USINT;
    
    RegDX$USINT := RegDX$USINT OR RegBL;
  end_for;

END_FUNCTION


FUNCTION  EEPROM::GetEESpecificData

	CASE m_uiReadType OF

	0:
		m_usClockOff	:= 16#18;		// offsets for address and data
		m_usDataOff		:= 16#19;		// for reading from EEPROM

	1:
		m_usClockOff	:= 4;
		m_usDataOff		:= 2;
	2:
		m_usClockOff	:= 4;
		m_usDataOff		:= 2;
	3:
		m_usClockOff	:= 16#18;		// offsets for address and data
		m_usDataOff		:= 16#19;		// for reading from EEPROM
	4:
		//z.B. DNC011
		m_usClockOff	:= 0;	// Bit 0
		m_usDataOff		:= 0;	// Bit 1
		m_usCSOff		:= 1;	// Bit 6
		m_usDataInOff	:= 8;	// Bit 0

	5: //z.B. DNC115
		m_uiReadType := 0; // Dataread = Bit 0
		m_usClockOff	:= 16#E;
		m_usDataOff		:= 16#F;
		
	6: //z.B. DSS110
		m_uiReadType := 0; // Dataread = Bit 0
		m_usClockOff	:= 16#F;
		m_usDataOff		:= 16#F;

	7:  // DAI081
		//udPortAddr   0 for groundmodul | 1..8 adaptermodul
		//uiStationNo  stationnumber of diasmódul
		//uiReadType   = 7
	
		

	END_CASE;

END_FUNCTION // EEPROM::GetEESpecificData

FUNCTION EEPROM::InitEE
VAR_INPUT
	udPortAddr		: UDINT;
	uiStationNo		: UINT;
	uiReadType		: UINT;
END_VAR

	m_udPortAddr	:= udPortAddr AND 16#FFFFFF00;
	m_uiStationNo	:= uiStationNo;
	m_uiReadType	:= uiReadType;

	GetEESpecificData();

  // create a mutex to protect the EEPROM
  if pMutex = NIL then
    pMutex := CreateMutex("EEPROM", this);
  end_if;


END_FUNCTION
FUNCTION GLOBAL EEPROM::EE_Rd
	VAR_INPUT
	uiAddr		: UINT;
	END_VAR
	VAR_OUTPUT
		RetDX 	: UINT;
	END_VAR
VAR
 	ReadByte :USINT;
END_VAR 		
    case m_uiReadType of
	0,1,2 :
		RegDX := EE_RdTyp0_2(uiAddr); // is already in DX
    RetDX := RegDX;

	3:
		// we read always 0,1,2
		// and this works with byte 
		uiAddr := uiAddr*2;
		ReadByte:=EE_ReadByte_Typ3(uiAddr);
		RegDX := EE_ReadByte_Typ3(uiAddr+1) shl 8;
		RegDX := RegDX OR ReadByte;
    RetDX := RegDX;

	4:	RegDX := ReadTyp004(uiAddr);
      RetDX := RegDX;

	7:	RegDX := EEReadTyp7(uiAddr);
      RetDX := RegDX;
	else
		RegDX:= 16#FFFF; //invalid 
    RetDX := RegDX;
	end_case;

END_FUNCTION

//[#ENGLISH]
//[>wAddr]address (to set page)
//[>bDir]0 - write, 1 - read

FUNCTION  EEPROM::EE_Start_Typ3
VAR_INPUT
	wAddr		: UINT;
	bDir		: USINT;
END_VAR
		//
		//		Clock the start sequence to the EEPROM ($FF)
		//
		RTOS_IF_Write(2#00000111, 0x00FF); //Write-Modus
		RTOS_IF_Write(2#00000111, 0x00FF); //SDA = 1, SCL = 1
		RTOS_IF_Write(2#00000110, 0x00FF); //SDA = 0, SCL = 1

		// 1. Bit (immer 1) --------------------//
		RTOS_IF_Write(2#00000101, 0x00FF); //SDA = 1, SCL = 0
		RTOS_IF_Write(2#00000111, 0x00FF); //SDA = 1, SCL = 1
		RTOS_IF_Write(2#00000101, 0x00FF); //SDA = 1, SCL = 0

		// 2. Bit (immer 0) --------------------//
		RTOS_IF_Write(2#00000100, 0x00FF); //SDA = 0, SCL = 0
		RTOS_IF_Write(2#00000110, 0x00FF); //SDA = 0, SCL = 1
		RTOS_IF_Write(2#00000100, 0x00FF); //SDA = 0, SCL = 0

		// 3. Bit (immer 1) --------------------//
		RTOS_IF_Write(2#00000101, 0x00FF); //SDA = 1, SCL = 0
		RTOS_IF_Write(2#00000111, 0x00FF); //SDA = 1, SCL = 1
		RTOS_IF_Write(2#00000101, 0x00FF); //SDA = 1, SCL = 0
		
		// 4. Bit (immer 0) --------------------//
		RTOS_IF_Write(2#00000100, 0x00FF); //SDA = 0, SCL = 0
		RTOS_IF_Write(2#00000110, 0x00FF); //SDA = 0, SCL = 1
		RTOS_IF_Write(2#00000100, 0x00FF); //SDA = 0, SCL = 0
		
		// 5. Bit (A2 = 0) ---------------------//
		RTOS_IF_Write(2#00000100, 0x00FF); //SDA = 0, SCL = 0
		RTOS_IF_Write(2#00000110, 0x00FF); //SDA = 0, SCL = 1
		RTOS_IF_Write(2#00000100, 0x00FF); //SDA = 0, SCL = 0
		
		// 6. Bit (A1 = 0) ---------------------//
		RTOS_IF_Write(2#00000100, 0x00FF); //SDA = 0, SCL = 0
		RTOS_IF_Write(2#00000110, 0x00FF); //SDA = 0, SCL = 1
		RTOS_IF_Write(2#00000100, 0x00FF); //SDA = 0, SCL = 0
		
		// 7. Bit (P0 = ?) ---------------------//
		if wAddr AND 0x0100 then
			// Page 1
			RTOS_IF_Write(2#00000101, 0x00FF); //SDA = 1, SCL = 0
			RTOS_IF_Write(2#00000111, 0x00FF); //SDA = 1, SCL = 1
			RTOS_IF_Write(2#00000101, 0x00FF); //SDA = 1, SCL = 0
		else
			// Page 0
			RTOS_IF_Write(2#00000100, 0x00FF); //SDA = 0, SCL = 0
			RTOS_IF_Write(2#00000110, 0x00FF); //SDA = 0, SCL = 1
			RTOS_IF_Write(2#00000100, 0x00FF); //SDA = 0, SCL = 0
		end_if;

		// 8. Bit (RD / WR) --------------------//
		if bDir = 0 then
			// Write
			RTOS_IF_Write(2#00000100, 0x00FF); //SDA = 0, SCL = 0
			RTOS_IF_Write(2#00000110, 0x00FF); //SDA = 0, SCL = 1
			RTOS_IF_Write(2#00000100, 0x00FF); //SDA = 0, SCL = 0
		else
			// Read
			RTOS_IF_Write(2#00000101, 0x00FF); //SDA = 1, SCL = 0
			RTOS_IF_Write(2#00000111, 0x00FF); //SDA = 1, SCL = 1
			RTOS_IF_Write(2#00000101, 0x00FF); //SDA = 1, SCL = 0
		end_if;

		// Acknowledge
		EE_BitIn_Typ3();		//Acknowledge (mir wurscht)


END_FUNCTION // EEPROM::EE_Start_Typ3

FUNCTION  EEPROM::EE_BitIn_Typ3
VAR_OUTPUT
	bData		: USINT;
END_VAR
		//
		//		Read the Bit
		//
		RTOS_IF_Write(2#00000000, 0x00FF); //Read-Modus
		RTOS_IF_Write(2#00000010, 0x00FF); //SDA = 0, SCL = 1
		bData$SINT := RTOS_IF_Read(0x00FF); //SDA = 0, SCL = 1
		bData := bData AND 1;
		RTOS_IF_Write(2#00000000, 0x00FF); //SDA = 0, SCL = 0

END_FUNCTION // EEPROM::EE_BitIn_Typ3

FUNCTION  EEPROM::EE_ReadByte_Typ3
VAR_INPUT
	wAddr		: UINT;
END_VAR
VAR_OUTPUT
	bData		: USINT;
END_VAR
		//
		// Prepare the EEPROM and read a byte
		//
		EE_Start_Typ3(wAddr,0);		// set page, write
		EE_AdrOut_Typ3(wAddr);		// send address
		EE_Start_Typ3(wAddr,1);		// set page, read
		bData := EE_ByteIn_Typ3();	// read the data byte
		EE_Stop_Typ3();				// done with EEPROM

END_FUNCTION // EEPROM::EE_ReadByte_Typ3

FUNCTION  EEPROM::EE_AdrOut_Typ3
VAR_INPUT
	wAddr		: UINT;
END_VAR
VAR
	i			: UINT;		// Loop counter
END_VAR

		//	Loop for lower 8 address bits
		// (send out high to low)
		for i := 0 to 7 do
			// Send next bit
			EE_BitOut_Typ3((wAddr AND 0x0080)$USINT);
			wAddr := wAddr SHL 1;
		end_for;

		// Acknowledge (mir wurscht)
		EE_BitIn_Typ3();


END_FUNCTION // EEPROM::EE_AdrOut_Typ3

FUNCTION  EEPROM::EE_ByteIn_Typ3
VAR_OUTPUT
	bData		: USINT;
END_VAR
VAR
	i			: UINT;		// Loop counter
	bBit		: USINT;	// temp bit
END_VAR

		// Reset for output
		bData := 0;

		// Loop and read 8 bits
		for i:=0 to 7 do
			// Read next bit
			bBit := EE_BitIn_Typ3();
			bData := (bData SHL 1) OR bBit;
		end_for;

		// Acknowledge (mir wurscht)
		EE_BitIn_Typ3();

END_FUNCTION // EEPROM::EE_ByteIn_Typ3

FUNCTION  EEPROM::EE_Stop_Typ3
VAR_OUTPUT
	bResult		: USINT;
END_VAR
		//
		//	Stop sequence
		//
		RTOS_IF_Write(2#00000100, 0x00FF); //SDA = 0, SCL = 0
		RTOS_IF_Write(2#00000110, 0x00FF); //SDA = 0, SCL = 1
		RTOS_IF_Write(2#00000111, 0x00FF); //SDA = 1, SCL = 1
		bResult := 0;


END_FUNCTION // EEPROM::EE_Stop_Typ3

FUNCTION  EEPROM::EE_BitOut_Typ3
VAR_INPUT
	bBit		: USINT;	// Zero to clock a 0 bit, non-zero to clock a one
END_VAR

		RTOS_IF_Write(2#00000100, 0x00FF); //SDA = 0, SCL = 0
		if bBit = 0 then
			// Write a 0
			RTOS_IF_Write(2#00000100, 0x00FF); //SDA = 0, SCL = 0
			RTOS_IF_Write(2#00000110, 0x00FF); //SDA = 0, SCL = 1
			RTOS_IF_Write(2#00000100, 0x00FF); //SDA = 0, SCL = 0
		else
			// Write a 1
			RTOS_IF_Write(2#00000101, 0x00FF); //SDA = 1, SCL = 0
			RTOS_IF_Write(2#00000111, 0x00FF); //SDA = 1, SCL = 1
			RTOS_IF_Write(2#00000101, 0x00FF); //SDA = 1, SCL = 0
		end_if;
END_FUNCTION // EEPROM::EE_BitOut_Typ3

FUNCTION EEPROM::EE_RdTyp0_2
	VAR_INPUT
	uiAddr		: UINT;
	END_VAR
	VAR_OUTPUT
		RetDX 	: UINT;
	END_VAR
VAR
	udPort  :UDINT;
END_VAR

  udPort := m_udPortAddr + m_usClockOff;    // usually type0,1 read from +4
  
  CS_Disable(udPort);
  CS_Enable(udPort);
  
  RegBH := 1;
  RegDX := (uiAddr ROR 8 OR 16#8001) ROL 2;

  Clk_EE(udPort);
  LatchAddress(udPort);
  ReadData(udPort);
  RetDX := RegDX;
  
  CS_Disable(udPort);

END_FUNCTION // EEPROM::EE_RdTyp0_2

FUNCTION AWL EEPROM::EE_RdTyp0_2_AWL
	VAR_INPUT
		uiAddr 	: UINT;
	END_VAR
	VAR_OUTPUT
	DX		: UINT;
	END_VAR
#ifdef _LSL_TARGETARCH_X86


	L.EDI			m_udPortAddr
	LZXB.EAX		m_usClockOff		// usually type0,1 read from +4
	ADD.EDI			EAX

	CALL			CS_Disable_AWL
	CALL			CS_Enable_AWL

	L.BH			1

	L.DX			uiAddr

	ROR.DX			8
	OR.DX			16#8001
	ROL.DX			2

	CALL			Clk_EE_AWL
	CALL			LatchAddress_AWL
	CALL			ReadData_AWL
	CALL			CS_Disable_AWL

#endif
END_FUNCTION // EEPROM::EE_RdTyp0_2

//[#ENGLISH]
//[>pEEData]pointer on the first byte of EEprom
//[>TYP]0 .. old , 1 = new 16#73
//[<ChkOK]0 = ok | 1 = Error
FUNCTION GLOBAL EEPROM::EE_CHK
VAR_INPUT
	pEEData		: ^UINT;
	TYP		: UINT;
END_VAR
VAR_OUTPUT
	ChkOK		: DINT;
END_VAR
VAR
  CRC_eeprom  :UINT;    //CRC from EEPROM
  CRC         :UINT;    //computed CRC
  size        :DINT;
  i           :DINT;
END_VAR


  ChkOK := 16#ffffffff$DINT;

  if TYP = 0 then
    // this is typ 0,1,2 for dai0883 dam122 etc
    if (pEEData+2)^ = 12345 then
      CRC        := 16#ffff;
      CRC_eeprom := pEEData^;
      size := (pEEData+4)^ + 2;   // size of block + kennung + laenge

      for i:= 0 to size-1 do
        if CRC and 16#8000 then                   // Ersatz für adc
          CRC := (CRC ROL 1) + (pEEData+2)^ + 1;  // start at adress 1
        else
          CRC := (CRC ROL 1) + (pEEData+2)^;
        end_if;
        pEEData += sizeof(UINT);
      end_for;

      //***CalCRCret
      if CRC_eeprom = CRC then
        ChkOK := 0;
      end_if;
    end_if;
  else
    // new typ 512 byte EEprom
    if (pEEData+2)^ = 12345 then
      CRC        := 16#ffff;
      CRC_eeprom := pEEData^;
        if (pEEData+2)^ = 12345 then
          size := (pEEData+4)^ + 2;   // size of block + kennung + laenge

          for i:= 0 to size-1 do
            if CRC and 16#8000 then                   // Ersatz für adc
              CRC := (CRC ROL 1) + (pEEData+2)^ + 1;  // start at adress 1
            else
              CRC := (CRC ROL 1) + (pEEData+2)^;
            end_if;
            pEEData += sizeof(UINT);
          end_for;

          //***CalCRCret
          if CRC_eeprom = CRC then
            ChkOK := 0;
          end_if;
        end_if;
    end_if;
  end_if;

END_FUNCTION //GLOBAL EEPROM::EE_CHK

FUNCTION AWL GLOBAL EEPROM::EE_CHK_AWL
VAR_INPUT
	pEEData		: ^UINT;
	TYP		: UINT;
END_VAR
VAR_OUTPUT
	ChkOK		: DINT;
END_VAR
#ifdef _LSL_TARGETARCH_X86


	l.d			ChkOK,16#ffffffff

	l.ax		TYP
	o.ax		ax
	jne			TYP73

// this is typ 0,1,2 for dai0883 dam122 etc

	l.bx		16#ffff
	l.edi		pEEData
	cmp.w		(edi+2) , 12345
	jne			EE_ret

	lzxw.ecx	(edi+4)			// size of block
	add.cx		2				// kennung + laenge 

checklp
	rol.bx		1
	adc.bx		(edi+2)			// start at adress 1
	add.edi		2
	loop		checklp

//***CalCRCret
	l.edi		pEEData
	cmp.bx		(edi)			// chk
	jne			EE_ret			// wrong CRC

	l.d			ChkOK,0
	jmp			EE_ret			// CRC ok


// new typ 512 byte EEprom

TYP73
	l.edi		pEEData
	cmp.w		(edi+2) , 12345
	jne			EE_ret

	l.bx		16#ffff
	l.edi		pEEData
	cmp.w		(edi+2) , 12345
	jne			EE_ret

	lzxw.ecx	(edi+4)			// size of block
	add.cx		2				// kennung + laenge 
	jmp			checklp


EE_ret
#endif
END_FUNCTION //GLOBAL EEPROM::EE_CHK

FUNCTION EEPROM::ReadTyp004
VAR_INPUT
	uiAddr		: UINT;
END_VAR
VAR_OUTPUT
	RetDX		: UINT;
END_VAR

  RegBL := RegBH := 0; // CLR EBX

  CSTyp4(0);      // Disable
  CSTyp4(1);      // Enable 

  RegDX := uiAddr ROR 8 OR 2#1000000000000001;
  
  LatchAdrTyp4(); // Adresse
  AuslesTyp4();   // Auslesen
  
  CSTyp4(0);      // Disable
  RetDX := RegDX;
  
END_FUNCTION // EEPROM::ReadTyp004

FUNCTION AWL EEPROM::ReadTyp004_AWL
VAR_INPUT
	uiAddr		: UINT;
END_VAR
VAR_OUTPUT
	DX		: UINT;
END_VAR
#ifdef _LSL_TARGETARCH_X86

         PUSH      EBX
         PUSH      ECX
         PUSH      EAX
         PUSH	   EDI
         PUSHF
         //CLI			//ws001: should not be necessary

         CLR       EBX

		 X		   AL
         CALL      CSTYP4 // Disable
		 L		   1
         CALL      CSTYP4 // Enable

		 L.DX	   uiAddr

         ROR.DX    008
         O.DX      2#1000000000000001
//         ROL.DX    003

		 
         CALL      LatchAdrTyp4     // Adresse
         CALL      AUSLESTYP4      // Auslesen
		 X		   AL
         CALL      CSTYP4 // Disable

         S.DX      AX
// #BS000         STI
		 POPF
         POP	   EDI
		 POP       EAX
         POP       ECX
         POP       EBX

#endif
END_FUNCTION // EEPROM::ReadTyp004

FUNCTION  EEPROM::CSTyp4
	VAR_INPUT
		Enable 	: BOOL;
	END_VAR

#ifdef _LSL_TARGETARCH_X86
	Save_Reg();
#endif

	IF Enable THEN
		MasterConnect.Wr8Bit(m_uiStationNo*16#100+m_usCSOff,(1 SHL 6)); //enable
	ELSE
		MasterConnect.Wr8Bit(m_uiStationNo*16#100+m_usCSOff,0);         //disable
	END_IF;

#ifdef _LSL_TARGETARCH_X86
	Restore_Reg();
#endif

END_FUNCTION // EEPROM::CSTyp4

FUNCTION EEPROM::ClkTyp4

  RegBH := RegBH OR 1;
  RTOS_IF_Write(dActData:=RegBH, udPort:=m_usClockOff);

  RegBH := RegBH AND 16#FE;
  RTOS_IF_Write(dActData:=RegBH, udPort:=m_usClockOff);
  
END_FUNCTION // EEPROM::ClkTyp4

FUNCTION AWL EEPROM::ClkTyp4_AWL
#ifdef _LSL_TARGETARCH_X86

			PUSH			EDI
			X.EAX			EAX
			L				m_usClockOff
			S.EAX			EDI

			OR.BH			1
			L				BH
			CALL			RTOS_IF_Write
			AND.BH			16#FE
			L				BH
			CALL			RTOS_IF_Write
			POP				EDI
#endif
END_FUNCTION // EEPROM::ClkTyp4

FUNCTION EEPROM::LatchAdrTyp4
VAR
	i     :DINT;
END_VAR

  for i:=0 to 9 do
    RegBL := RegDX$USINT;
    RegBL := RegBL AND 2#00000010;
    RegBH := RegBH AND 2#11111101;
    RegBH := RegBH OR RegBL;
    
    SetDataTyp4();
    ClkTyp4();
    
    RegDX := RegDX ROL 1;
  end_for;

  RegBH := RegBH AND 2#11111101;

END_FUNCTION // EEPROM::LatchAdrTyp4

FUNCTION AWL EEPROM::LatchAdrTyp4_AWL
#ifdef _LSL_TARGETARCH_X86

         L.ECX     10
_LTYP003 L.BL      DL
         AND.BL    2#00000010
         AND.BH    2#11111101
         OR.BH     BL
		 cli					//ws001
         CALL      SetDataTyp4
         CALL      ClkTyp4
		 sti					//ws001
         ROL.DX    00001
         LOOP      _LTYP003
         AND.BH    2#11111101
#endif
END_FUNCTION // EEPROM::LatchAdrTyp4

FUNCTION EEPROM::SetDataTyp4

	RTOS_IF_Write(dActData:=RegBH, udPort:=m_usDataOff);

END_FUNCTION // EEPROM::SetDataTyp4

FUNCTION AWL EEPROM::SetDataTyp4_AWL
#ifdef _LSL_TARGETARCH_X86

			PUSH			EDI
			X.EAX			EAX
			L				m_usDataOff
			S.EAX			EDI

			L				BH
			CALL			RTOS_IF_Write
			POP				EDI
	
#endif
END_FUNCTION // EEPROM::SetDataTyp4

FUNCTION EEPROM::AuslesTyp4
// ...................................................
// ... Inhalt auslesen
// ...................................................
VAR
	i     :DINT;
END_VAR

  RegDX := 0;
  
  for i:=0 to 15 do
    RegDX := RegDX SHL 1;
    ClkTyp4();
    RegBL := RTOS_IF_Read(udPort:=m_usDataInOff)$USINT;
    RegBL := RegBL AND 2#00000001;
    RegDX := RegDX OR RegBL;
  end_for;

END_FUNCTION // EEPROM::AuslesTyp4

FUNCTION AWL EEPROM::AuslesTyp4_AWL
// ...................................................
// ... Inhalt auslesen
// ...................................................
#ifdef _LSL_TARGETARCH_X86

		 X.EAX	   EAX
		 L		   m_usDataInOff
		 L.EDI	   EAX 

         CLR       DX
         L.ECX      00016
_ATYP003 SHL.DX    001
         CALL      CLKTYP4
		 CALL	   RTOS_IF_Read
         AND.BL    2#00000001
         OR.DL     BL
         LOOP      _ATYP003
#endif
END_FUNCTION // EEPROM::AuslesTyp4

FUNCTION EEPROM::EEReadTyp7
VAR_INPUT
	uiAddr		: UINT;
END_VAR
VAR_OUTPUT
	value		: UINT;
END_VAR
//udPortAddr   0 for groundmodul | 16#100..16#800 adaptermodul
//uiStationNo  stationnumber of diasmódul
//uiReadType   = 7
#ifdef _LSL_TARGETARCH_X86
		SAVE_FLG();
#endif
		//CLI();		//ws001

		CS_Typ7(0);
		CS_Typ7(1);

		RegDX := uiAddr;
		LatchAdrTyp7();
		AuslesTyp7();
		value := RegDX;
		
		CS_Typ7(0);

#ifdef _LSL_TARGETARCH_X86
		RESTORE_FLG();
#endif


END_FUNCTION // EEPROM::EEReadTyp7

FUNCTION EEPROM::CS_Typ7
VAR_INPUT
	Enable	: BOOL;
END_VAR
VAR
	mm_udPortAddr	: UDINT;
END_VAR

	mm_udPortAddr := m_udPortAddr SHR 8;
	IF mm_udPortAddr = 0 THEN
		MasterConnect.Wr8Bit((m_uiStationNo*16#100)+16#6,0);
		m_DAI081CS := 0;
		m_DAI081CS.CSGround := Enable;
		MasterConnect.Wr8Bit((m_uiStationNo*16#100)+16#4,m_DAI081CS$USINT);
	ELSE
		m_DAI081CS := 0;
		MasterConnect.Wr8Bit((m_uiStationNo*16#100)+16#4,m_DAI081CS$USINT);
		MasterConnect.Wr8Bit((m_uiStationNo*16#100)+16#6,(enable SHL (mm_udPortAddr$USINT-1)));
	END_IF;

END_FUNCTION // EEPROM::CS_Typ7


FUNCTION EEPROM::LatchAdrTyp7
VAR
	i     :DINT;
END_VAR

  RegDX := RegDX ROR 8 OR 2#1000000000000001;
  RegBH := m_DAI081CS;
  
  for i:=0 to 9 do
    RegBL := RegDX$USINT;
    RegBL := RegBL AND 2#00000010;
    RegBH := RegBH AND 2#11111101;
    RegBL := RegBL OR  RegBH;
    
    SetDataTyp7();
    ClkTyp7();
    
    RegDX := RegDX ROL 1;
  end_for;

END_FUNCTION // EEPROM::LatchAdrTyp4
FUNCTION AWL EEPROM::LatchAdrTyp7_AWL
#ifdef _LSL_TARGETARCH_X86

         ROR.DX    008
         O.DX      2#1000000000000001
		 L.BH	   m_DAI081CS

         L.ECX     10
_LTYP007 L.BL      DL
         AND.BL    2#00000010
		 AND.BH	   2#11111101
		 O.BL	   BH
		 cli								//ws001
         CALL      SetDataTyp7
         CALL      ClkTyp7
		 sti								//ws001
         ROL.DX    00001
         LOOP      _LTYP007
#endif
END_FUNCTION // EEPROM::LatchAdrTyp4
FUNCTION EEPROM::SetDataTyp7

  RTOS_IF_Write(dActData:=RegBL, udPort:=16#4);
  
END_FUNCTION // EEPROM::SetDataTyp4
FUNCTION AWL EEPROM::SetDataTyp7_AWL
#ifdef _LSL_TARGETARCH_X86

		L.EDI			16#4
		L				BL
		CALL			RTOS_IF_Write
#endif
END_FUNCTION // EEPROM::SetDataTyp4
FUNCTION EEPROM::ClkTyp7

  RegBL := RegBL OR 1;
  RTOS_IF_Write(dActData:=RegBL, udPort:=16#4);

  RegBL := RegBL AND 16#FE;
  RTOS_IF_Write(dActData:=RegBL, udPort:=16#4);
  
END_FUNCTION // EEPROM::ClkTyp4
FUNCTION AWL EEPROM::ClkTyp7_AWL
#ifdef _LSL_TARGETARCH_X86

			L.EDI			16#4

			OR.BL			1
			L				BL
			CALL			RTOS_IF_Write
			AND.BL			16#FE
			L				BL
			CALL			RTOS_IF_Write
#endif
END_FUNCTION // EEPROM::ClkTyp4
FUNCTION EEPROM::AuslesTyp7
// ...................................................
// ... Inhalt auslesen
// ...................................................
VAR
	i     :DINT;
END_VAR

  RegDX := 0;

  for i:=0 to 15 do
    RegDX := RegDX ROL 1;
    RegBL := m_DAI081CS;
    ClkTyp7();
    RegBL := RTOS_IF_Read(udPort:=2)$USINT;
    RegBL := RegBL AND 2#00000010;
    RegDX := RegDX OR RegBL;
  end_for;

  RegDX := RegDX ROR 1;

END_FUNCTION // EEPROM::AuslesTyp4
FUNCTION AWL EEPROM::AuslesTyp7_AWL
// ...................................................
// ... Inhalt auslesen
// ...................................................
#ifdef _LSL_TARGETARCH_X86

         CLR       DX
         L.ECX     00016
_ATYP007 ROL.DX    001
		 L.BL	   m_DAI081CS
         CALL      CLKTYP7
		 L.EDI	   2
		 CALL	   RTOS_IF_Read		 
         AND.BL    2#00000010
         OR.DL     BL
         LOOP      _ATYP007

		 ROR.DX	   1
#endif
END_FUNCTION // EEPROM::AuslesTyp4


FUNCTION EEPROM::CreateMutex
	VAR_INPUT
		MutexName 	: ^CHAR;
    pThis 	: ^VirtualBase;
	END_VAR
	VAR_OUTPUT
		pv_RetMutex 	: pVoid;
	END_VAR
  VAR
    str_ObjName : array[0..255] of char;
    str_ObjNamePart1 : array[0..EEPROM_MUTEX_NAME_MAX_LENGTH-1] of char;
    str_ObjNamePart2 : array[0..EEPROM_MUTEX_NAME_END_LENGTH] of char; // +1 for 0 Termination
    str_CombinedName : array[0..EEPROM_MUTEX_NAME_MAX_LENGTH-1] of char; 
    str_this : array[0..11] of char; // 2 byty %m, 8 byte Address, 1 byte for 0 Termination
  	
    ud_LenObjName  : UDINT;    
    ud_LenStr  : UDINT;    
    ud_SepLenStr : UDINT;
    ud_LenCombObjName : UDINT;  
    ud_LenThis : UDINT;

  END_VAR
  
  pv_RetMutex := Nil; // Error OS_CILGetv failed
  
  if pThis = nil then
    pthis := this;
  end_if;  
  
  if (mt_api = nil) then
    if(OS_CILGet("LSL_MULTITASK", #mt_api$void)) THEN
      mt_api := NIL;
    end_if;
  end_if;
  
  if mt_api then
  
    _memset(dest:=#str_ObjName[0], usByte:=0, cntr:=sizeof(str_ObjName) );
    _memset(dest:=#str_ObjNamePart1[0], usByte:=0, cntr:=sizeof(str_ObjNamePart1) );
    _memset(dest:=#str_ObjNamePart2[0], usByte:=0, cntr:=sizeof(str_ObjNamePart2) );
    _memset(dest:=#str_CombinedName[0], usByte:=0, cntr:=sizeof(str_CombinedName) );
    _memset(dest:=#str_this[0], usByte:=0, cntr:=sizeof(str_this) );
    
  
    ud_LenStr := _strlen(MutexName);    

    ud_SepLenStr := _strlen(EEPROM_STR_MUTEX_NAME_SEPERATOR);
    ud_LenObjName := _GetObjName(pThis:=pthis, pName:=#str_ObjName[0]);
  
    if (ud_LenStr < EEPROM_MUTEX_NAME_MAX_LENGTH) then
      _strcpy(dest:=#str_CombinedName[0], src:=MutexName);
    else
      _strncpy(dest:=#str_CombinedName[0], src:=MutexName, max:=EEPROM_MUTEX_NAME_MAX_LENGTH-1);
    end_if;
    
    if (ud_LenObjName + ud_LenStr) < EEPROM_MUTEX_NAME_MAX_LENGTH then      
      _strcat(dest:=#str_CombinedName[0], src:=#str_ObjName[0]); 
    else
      _strncpy(dest:=#str_ObjNamePart1[0], src:= #str_ObjName[0], max:= EEPROM_MUTEX_NAME_MAX_LENGTH - ud_LenStr - ud_SepLenStr - EEPROM_MUTEX_NAME_END_LENGTH - 1);    // Copy Beginning of str_ObjName
      _strncpy(dest:=#str_ObjNamePart2[0], src:= #str_ObjName[ud_LenObjName-EEPROM_MUTEX_NAME_END_LENGTH-1], max:=EEPROM_MUTEX_NAME_END_LENGTH);  // Copy Last MUTEX_NAME_END_LENGTH Char of str_ObjName
      
      // Put the Mutex String together
      _strcat(dest:=#str_CombinedName[0], src:= #str_ObjNamePart1[0]);
      _strcat(dest:=#str_CombinedName[0], src:= EEPROM_STR_MUTEX_NAME_SEPERATOR);
      _strcat(dest:=#str_CombinedName[0], src:= #str_ObjNamePart2[0]);      
    end_if;

    pv_RetMutex := OS_MT_CreateSemaphore(MTSEMATYPE_MUTEX, 1, 0, #str_CombinedName[0]);   
    
    if pv_RetMutex = nil then
    
      // If Create Mutex failed: Insert the this pointer into the string
      ud_LenCombObjName := _strlen(#str_CombinedName[0]);
      
      str_this[0] := '%';
      str_this[1] := 'm';
      _itoa(udNumber:=pthis$UDINT, pString:=#str_this[2]);
      ud_LenThis  := _strlen(src:=#str_this[0]);
      
      _strcpy(dest:=#str_CombinedName[ud_LenCombObjName-ud_LenThis], src:=#str_this[0]);      
      
      pv_RetMutex := OS_MT_CreateSemaphore(MTSEMATYPE_MUTEX, 1, 0, #str_CombinedName[0]); 
    
    end_if;

  end_if;    
  
END_FUNCTION

FUNCTION EEPROM::MutexStart
  VAR_INPUT
    pMutex  : pVoid;
  END_VAR

  if(pMutex <> NIL) then
    OS_MT_WAIT(pMutex); 
  end_if;

END_FUNCTION


FUNCTION EEPROM::MutexStop
  VAR_INPUT
    pMutex  : pVoid;
  END_VAR

  if(pMutex <> NIL) then
    OS_MT_SIGNAL(pMutex); 
  end_if;

END_FUNCTION
