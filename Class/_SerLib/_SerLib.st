//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)
//{{LSL_DECLARATION

(*!
<Class
	Name               = "_SerLib"
	Revision           = "1.34"
	GUID               = "{7B3E420B-3FAC-48F3-86CB-F3D0F43789B6}"
	RealtimeTask       = "false"
	CyclicTask         = "false"
	BackgroundTask     = "false"
	Sigmatek           = "true"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	IconPath           = ".\Class\_SerLib\port in out.ico"
	SharedCommandTable = "false"
	Objectsize         = "(284,120)"
	Comment            = "Class for Serial Interface &#13;&#10;to send and receive data on the &#13;&#10;serial interface&#13;&#10;usable modes:&#13;&#10; - RS232&#13;&#10; - RS422&#13;&#10; - RS485">
	<Channels>
		<Server Name="Com" GUID="{D94EFF5B-283A-4927-BF86-6594255D3D0F}" Visualized="true" Initialize="true" WriteProtected="true" Retentive="false" Comment="No. of COM: 1-10"/>
		<Server
			Name           = "Command"
			GUID           = "{E2A17142-EF9E-11D5-BDB2-000103C6CD0D}"
			Visualized     = "true"
			Initialize     = "false"
			WriteProtected = "true"
			Retentive      = "false"
			Comment        = "for calling global methods">
			<NewInst>
				<Function Name="StartUserIPR">
					<InputParameter>
						<Parameter Name="Baudrate"/>
						<Parameter Name="Wordlength"/>
						<Parameter Name="ParityBits"/>
						<Parameter Name="StopBits"/>
					</InputParameter>
					<OutputParameter>
						<Parameter Name="ErrorCom"/>
					</OutputParameter>
				</Function>
				<Function Name="StopUserIPR">
					<OutputParameter>
						<Parameter Name="ErrorCom"/>
					</OutputParameter>
				</Function>
				<Function Name="SerCloseIPR">
				</Function>
				<Function Name="SerSendIPR">
					<InputParameter>
						<Parameter Name="SendValue"/>
					</InputParameter>
					<OutputParameter>
						<Parameter Name="ErrorCom"/>
						<Parameter Name="CorrectSend"/>
					</OutputParameter>
				</Function>
				<Function Name="RecvCharIPR">
					<OutputParameter>
						<Parameter Name="ErrorCom"/>
						<Parameter Name="ReadChar"/>
					</OutputParameter>
				</Function>
				<Function Name="SetOnlineIPR">
					<InputParameter>
						<Parameter Name="state"/>
					</InputParameter>
					<OutputParameter>
						<Parameter Name="ErrorCom"/>
					</OutputParameter>
				</Function>
				<Function Name="GetRecvStateIPR">
					<OutputParameter>
						<Parameter Name="length"/>
					</OutputParameter>
				</Function>
				<Function Name="GetSendStateIPR">
					<OutputParameter>
						<Parameter Name="BytesTooSend"/>
					</OutputParameter>
				</Function>
				<Function Name="GetErrorIPR">
					<OutputParameter>
						<Parameter Name="ErrorCom"/>
					</OutputParameter>
				</Function>
				<Function Name="IsInitializedIPR">
					<OutputParameter>
						<Parameter Name="state"/>
					</OutputParameter>
				</Function>
				<Function Name="ClearRecBufferIPR">
					<OutputParameter>
						<Parameter Name="ErrorCom"/>
					</OutputParameter>
				</Function>
				<Function Name="RtsOnOffIPR">
					<InputParameter>
						<Parameter Name="state"/>
					</InputParameter>
					<OutputParameter>
						<Parameter Name="ErrorCode"/>
					</OutputParameter>
				</Function>
				<Function Name="rdRtsIPR">
					<OutputParameter>
						<Parameter Name="state"/>
					</OutputParameter>
				</Function>
				<Function Name="rdCtsIPR">
					<OutputParameter>
						<Parameter Name="state"/>
					</OutputParameter>
				</Function>
				<Function Name="DtrOnOffIPR">
					<InputParameter>
						<Parameter Name="state"/>
					</InputParameter>
					<OutputParameter>
						<Parameter Name="ErrorCode"/>
					</OutputParameter>
				</Function>
				<Function Name="rdDtrIPR">
					<OutputParameter>
						<Parameter Name="state"/>
					</OutputParameter>
				</Function>
				<Function Name="rdDcdIPR">
					<OutputParameter>
						<Parameter Name="state"/>
					</OutputParameter>
				</Function>
				<Function Name="rdDsrIPR">
					<OutputParameter>
						<Parameter Name="state"/>
					</OutputParameter>
				</Function>
				<Function Name="rdRiIPR">
					<OutputParameter>
						<Parameter Name="state"/>
					</OutputParameter>
				</Function>
				<Function Name="SetRSModeIPR">
					<InputParameter>
						<Parameter Name="Mode"/>
					</InputParameter>
					<OutputParameter>
						<Parameter Name="ErrorCode"/>
					</OutputParameter>
				</Function>
				<Function Name="GetRSModeIPR">
					<OutputParameter>
						<Parameter Name="Mode"/>
					</OutputParameter>
				</Function>
				<Function Name="GetInterfaceTypeIPR">
					<OutputParameter>
						<Parameter Name="Retcode"/>
					</OutputParameter>
				</Function>
			</NewInst>
		</Server>
	</Channels>
	<Dependencies>
		<Files>
			<File Path=".\lsl_st_serial.h" Include="false"/>
		</Files>
	</Dependencies>
	<RevDoku>
		<Owner Company="Sigmatek"/>
		<Dokumentation Revision="1.34" Date="2017-12-20" Author="KaiAnd" Company="Sigmatek" Description="Methods GetSendState () and GetRecvState (): Comments extended to inform about the necessity of a DINT cast to get negative values"/>
		<Dokumentation Revision="1.33" Date="2014-10-30" Author="HlaWol" Company="Sigmatek" Description="changed comment of SetRSMode (4850 was not mentioned)"/>
		<Dokumentation Revision="1.32" Date="2014-10-17" Author="leichr" Company="Sigmatek" Description="-) add bit3 in method getInterfaceType for HZS772 (M-bus)"/>
		<Dokumentation Revision="1.31" Date="2014-07-08" Author="Matthias Schuiki" Company="Sigmatek" Description="-) improvement interface type of serial interfaces&#13;&#10;     -) bit coded interface settings&#13;&#10;          -) bit0 ... character / message timeout check by OS (true / false)&#13;&#10;          -) bit1 ... Modbus RTU interface (HZS557)&#13;&#10;          -) bit2 ... RS485 only with echo (CSI02X)"/>
		<Dokumentation Revision="1.30" Date="2013-12-20" Author="spimar" Company="Sigmatek" Description="SetRSMode() is needed for ARM so it has to be changed"/>
		<Dokumentation Revision="1.20" Date="2013-03-08" Author="spimar" Company="Sigmatek" Description="New method to enter a own interfacetype"/>
		<Dokumentation Revision="1.10" Date="2012-04-20" Author="kiltob" Company="Sigmatek" Description="New methods for ModBus interaction added: RecvTimingChar, RecvTimingBlock, ClearTimingBuffer, SetTimingBufferRecv"/>
		<Dokumentation Revision="1.9" Date="2012-03-12" Author="spimar" Company="Sigmatek" Description="Betterments in code, e.g. memset of one entry of array was deleted;"/>
		<Dokumentation Revision="1.8" Date="30.04.09" Author="hötant" Company="Sigmatek" Description="private Header File lsl_st_serial.h changed to global"/>
	</RevDoku>
</Class>
*)
_SerLib : CLASS
	TYPE
	  CmdCommand :  //! <Type Public="true" Name="CmdCommand"/>
	  (
	    StartUserIPR,
	    StopUserIPR,
	    SerCloseIPR,
	    SerSendIPR,
	    RecvCharIPR,
	    SetOnlineIPR,
	    GetRecvStateIPR,
	    GetSendStateIPR,
	    GetErrorIPR,
	    IsInitializedIPR,
	    ClearRecBufferIPR,
	    RtsOnOffIPR,
	    rdRtsIPR,
	    rdCtsIPR,
	    DtrOnOffIPR,
	    rdDtrIPR,
	    rdDcdIPR,
	    rdDsrIPR,
	    rdRiIPR,
	    SetRSModeIPR,
	    GetRSModeIPR,
	    GetInterfaceTypeIPR
	  )$UINT;
	END_TYPE
  //Servers:
	Command 	: SvrChCmd_DINT;
	Com 	: SvrCh_DINT;
  //Clients:
  //Variables:
		pHandle 	: ^void;
  //Functions:
				//! <Function Comment=" ***************************************************************************&#13;&#10; ****************      _SerLib::SerInit                 ****************&#13;&#10; ***************************************************************************&#13;&#10; **                                    **&#13;&#10; **   Funktion schließt Schnittstelle falls initialisiert          **&#13;&#10; **   und initialisiert sie mit den Übergabeparametern, NEU.        **&#13;&#10; **   Über den Rückgabeparmeter kann entschieden werden ob INIT erfolgreich*&#13;&#10; **   ret0 &lt;= 0 --&gt; NICHT ERFOLGREICH                   **&#13;&#10; ***************************************************************************&#13;&#10;&#13;&#10; ***************************************************************************&#13;&#10; ****************      _SerLib::SerInit                 ****************&#13;&#10; ***************************************************************************&#13;&#10; **                                    **&#13;&#10; **   Closes an initialized COM if initialized and initializes a new one  **&#13;&#10; ** --------------------------------------------------------------------- **&#13;&#10; ***************************************************************************&#13;&#10;[&gt;Com_in]COM 1-4&#13;&#10;[&gt;Baud_in]0..SERUSERBAUD_300, 1..600, 2..1200, 3..2400, 4..4800, 5..9600, 6..14400, 7..19200, 8..38400, 9..56000, 10..115200&#13;&#10;[&gt;wordl_in]&quot;wordlength&quot;  5, 6, 7 or 8&#13;&#10;[&gt;Parity_in]0..SERUSERPARITY_NONE / 1..SERUSERPARITY_ODD / 2..SERUSERPARITY_EVEN / 3..SERUSERPARITY_MARK(HIGH Parity) / 4..SERUSERPARITY_SPACE(LOW Parity)&#13;&#10;[&gt;StopB_in]1=one stop bit, 2=2 stop bits for words of length 6,7 or 8 bits or 1.5 stop bits for word lengths of 5 bits. &#13;&#10;" Name="SerInit"/>
	FUNCTION SerInit
		VAR_INPUT
			Com_in 	: DINT;			//! <Variable Comment="COM 1-4" Name="SerInit.Com_in"/>
			Baud_in 	: DINT;			//! <Variable Comment="0..SERUSERBAUD_300, 1..600, 2..1200, 3..2400, 4..4800, 5..9600, 6..14400, 7..19200, 8..38400, 9..56000, 10..115200" Name="SerInit.Baud_in"/>
			wordl_in 	: DINT;			//! <Variable Comment="&quot;wordlength&quot;  5, 6, 7 oder 8" Name="SerInit.wordl_in"/>
			Parity_in 	: DINT;			//! <Variable Comment="0..SERUSERPARITY_NONE / 1..SERUSERPARITY_ODD / 2..SERUSERPARITY_EVEN / 3..SERUSERPARITY_MARK / 4..SERUSERPARITY_SPACE" Name="SerInit.Parity_in"/>
			StopB_in 	: DINT;			//! <Variable Comment="1=ein Stop Bit, 2=2 Stop Bits für word länge 6,7 oder 8 Bits oder 1.5 stop Bits für word Länge von 5 Bits. " Name="SerInit.StopB_in"/>
		END_VAR
		VAR_OUTPUT
			ErrorCode 	: DINT;			//! <Variable Comment="0=OK; -1:Com&lt;&gt;1-4; -2=Fehler Baud Tabelle; -3=Baudrate&lt;&gt;0-10; -4=Parity&lt;&gt;0-4; - 5=Stoppbits&lt;&gt;1-2; -6=ErrorWORDLEN; -10=COM wird bereits verwendet; -11=Com wird bereits vom OS verwendet; -12=CPU hat keine COM mit der Nr.; -13=OS Error;-14=Kein Initialisierung; -15=falsche Übergabe; -16=Empfangsbuffer zu klein, muss &gt;= 128 Byte&apos;s sein; -17=Übergabe war NIL; -19=keine Daten im Empfangsbuffer; -20=Sendeprozess konnte nicht abgeschlossen werden" Name="SerInit.ErrorCode"/>
		END_VAR;
				//! <Function Comment=" ***************************************************************************&#13;&#10; ****************    _SerLib :: GetRecvPointer            ****************&#13;&#10; ***************************************************************************&#13;&#10; ***                                     ***&#13;&#10; ***        Ermittelt die Empfangs Buffer Adresse eines Handles        ***&#13;&#10; ***************************************************************************&#13;&#10;&#13;&#10; ***************************************************************************&#13;&#10; ****************    _SerLib :: GetRecvPointer           ****************&#13;&#10; ***************************************************************************&#13;&#10; ***                                     ***&#13;&#10; ***    returns the pointer of the receiving buffer             ***&#13;&#10; ***************************************************************************&#13;&#10;[&lt;Buffer_ptr]Pointer of Receivingbuffer with the input handle&#13;&#10;" Name="GetRecvPointer"/>
	FUNCTION GetRecvPointer
		VAR_OUTPUT
			Buffer_ptr 	: ^void;			//! <Variable Comment="Pointer des Empfangsbuffers" Name="GetRecvPointer.Buffer_ptr"/>
		END_VAR;
				//! <Function Comment="&#13;&#10; ***************************************************************************&#13;&#10; ****************    _SerLib::StartUser                   ****************&#13;&#10; ***************************************************************************&#13;&#10; **                                     **&#13;&#10; **   Closes an initialized COM if initialized and initializes a new one  **&#13;&#10; ***************************************************************************&#13;&#10;[&gt;Baud]0..SERUSERBAUD_300, 1..600, 2..1200, 3..2400, 4..4800, 5..9600, 6..14400, 7..19200, 8..38400, 9..56000, 10..115200&#13;&#10;[&gt;wordl]&quot;wordlength&quot;  5, 6, 7 or 8 bit&#13;&#10;[&gt;Parity]0..SERUSERPARITY_NONE 1..SERUSERPARITY_ODD / 2..SERUSERPARITY_EVEN / 3..SERUSERPARITY_MARK(HIGH Parity) / 4..SERUSERPARITY_SPACE(LOW Parity)&#13;&#10;[&gt;StopB]1=one stop bit, 2=2 stop bits for words of length 6,7 or 8 bits or 1.5 stop bits for word lengths of 5 bits.&#13;&#10;[&gt;FifoOnOff]0=FIFO disable, FIFO enable: 1,4,8,14 = Triggerlevel&#13;&#10;" Name="StartUser"/>
	FUNCTION VIRTUAL GLOBAL StartUser
		VAR_INPUT
			Baud 	: DINT;			//! <Variable Comment="0..SERUSERBAUD_300, 1..600, 2..1200, 3..2400, 4..4800, 5..9600, 6..14400, 7..19200, 8..38400, 9..56000, 10..115200" Name="StartUser.Baud"/>
			wordl 	: DINT;			//! <Variable Comment="wordlength  5, 6, 7 or 8 Bit" Name="StartUser.wordl"/>
			Parity 	: DINT;			//! <Variable Comment="0..SERUSERPARITY_NONE / 1..SERUSERPARITY_ODD / 2..SERUSERPARITY_EVEN / 3..SERUSERPARITY_MARK / 4..SERUSERPARITY_SPACE" Name="StartUser.Parity"/>
			StopB 	: DINT;			//! <Variable Comment="1=one Stop Bit, 2=2 Stop Bits for wordlength 6,7 or 8 Bits or 1.5 stop Bits for a wordlength of 5 Bits." Name="StartUser.StopB"/>
			FifoOnOff 	: DINT := 1;			//! <Variable Comment="0=FIFO disable, FIFO enable: 1,4,8,14 = Triggerlevel" Name="StartUser.FifoOnOff"/>
		END_VAR
		VAR_OUTPUT
			ErrorCode 	: DINT;			//! <Variable Comment="returns the errorcode&#13;&#10;0=OK; &#13;&#10;-1=invalid Com; &#13;&#10;-2=Error baudtable; &#13;&#10;-3=baudrate&lt;&gt;0-10; &#13;&#10;-4=parity&lt;&gt;0-4; &#13;&#10;- 5=stopbits&lt;&gt;1-2; &#13;&#10;-6=ErrorWORDLEN; &#13;&#10;-10=Com allready in use; &#13;&#10;-11=Com allready in use of OS; &#13;&#10;-12=CPU has no COM of this No.;&#13;&#10;-13=OS Error;-14=NoInitialization; &#13;&#10;-15=WRONG INPUT; -16=receiving buffer too low, has to be bigger then &gt;= 128 Byte&apos;s; &#13;&#10;-17=INPUT was NIL; &#13;&#10;-19=no DATA in receiving buffer; &#13;&#10;-20=sending process couldn&apos;t be ended (disturbance., sendbuffer overflow, ...)&#13;&#10;-50=FIFO doesn´t exist" Name="StartUser.ErrorCode"/>
		END_VAR;
				//! <Function Comment="&#13;&#10; ***************************************************************************&#13;&#10; ****************    _SerLib::StopUser                   ****************&#13;&#10; ***************************************************************************&#13;&#10; **                                     **&#13;&#10; ** Closes an initialized COM and enables the lasal online-communication  **&#13;&#10; ***************************************************************************&#13;&#10;" Name="StopUser"/>
	FUNCTION VIRTUAL GLOBAL StopUser
		VAR_OUTPUT
			ErrorCode 	: DINT;			//! <Variable Comment="returns the errorcode&#13;&#10;0=OK; &#13;&#10;-1:Com&lt;&gt;1-4; &#13;&#10;-2=Error baudtable; &#13;&#10;-3=baudrate&lt;&gt;0-10; &#13;&#10;-4=parity&lt;&gt;0-4; &#13;&#10;- 5=stopbits&lt;&gt;1-2; &#13;&#10;-6=ErrorWORDLEN; &#13;&#10;-10=Com allready in use; &#13;&#10;-11=Com allready in use of OS; &#13;&#10;-12=CPU has no COM of this No.;&#13;&#10;-13=OS Error;-14=NoInitialization; &#13;&#10;-15=WRONG INPUT; -16=receiving buffer too low, has to be bigger then &gt;= 128 Byte&apos;s; &#13;&#10;-17=INPUT was NIL; &#13;&#10;-19=no DATA in receiving buffer; &#13;&#10;-20=sending process couldn&apos;t be ended (disturbance., sendbuffer overflow, ...)" Name="StopUser.ErrorCode"/>
		END_VAR;
				//! <Function Comment="***************************************&#13;&#10; ****************    _SerLib::SerSend          ***********************&#13;&#10; ***************************************************************************&#13;&#10; ***                                   ******&#13;&#10; *** Sends DATA over the initialized COM                 ******&#13;&#10; *** If there is an Error, wrlen returns how many Bytes were sended   ******&#13;&#10; ***************************************************************************&#13;&#10;[&gt;bufferlength]The length of the data buffer to be sent.&#13;&#10;[&gt;wrlen]number of sent bytes&#13;&#10;" Name="SerSend"/>
	FUNCTION VIRTUAL GLOBAL SerSend
		VAR_INPUT
			Buffer 	: ^void;			//! <Variable Comment="pointer to receive buffer" Name="SerSend.Buffer"/>
			Bufferlength 	: UDINT;			//! <Variable Comment="number of bytes in the buffer" Name="SerSend.Bufferlength"/>
			WrLen 	: ^UDINT;			//! <Variable Comment="pointer to an variable&#13;&#10;the method writes the number of the written bytes&#13;&#10;" Name="SerSend.WrLen"/>
		END_VAR
		VAR_OUTPUT
			ErrorCode 	: DINT;			//! <Variable Comment="returns the errorcode&#13;&#10;0=OK; &#13;&#10;-1:Com&lt;&gt;1-4; &#13;&#10;-2=Error baudtable; &#13;&#10;-3=baudrate&lt;&gt;0-10; &#13;&#10;-4=parity&lt;&gt;0-4; &#13;&#10;- 5=stopbits&lt;&gt;1-2; &#13;&#10;-6=ErrorWORDLEN; &#13;&#10;-10=Com allready in use; &#13;&#10;-11=Com allready in use of OS; &#13;&#10;-12=CPU has no COM of this No.;&#13;&#10;-13=OS Error;-14=NoInitialization; &#13;&#10;-15=WRONG INPUT; -16=receiving buffer too low, has to be bigger then &gt;= 128 Byte&apos;s; &#13;&#10;-17=INPUT was NIL; &#13;&#10;-19=no DATA in receiving buffer; &#13;&#10;-20=sending process couldn&apos;t be ended (disturbance., sendbuffer overflow, ...)" Name="SerSend.ErrorCode"/>
		END_VAR;
				//! <Function Comment=" ************************************************&#13;&#10; *************  _SerLib::Serclose   *************&#13;&#10; ************************************************&#13;&#10; ***                        ***&#13;&#10; *** This Function clears an initialized COM  ***&#13;&#10; *** receiving buffer also will be cleared    ***&#13;&#10; ***                        ***&#13;&#10; *** --&gt; Not in use               ***&#13;&#10; *** &lt;-- Not in use                           ***&#13;&#10; ***                        ***&#13;&#10; ************************************************&#13;&#10;" Name="SerClose"/>
	FUNCTION VIRTUAL GLOBAL SerClose;
				//! <Function Comment=" ***************************************************************************&#13;&#10; ****************    _SerLib::SetOnline                   ****************&#13;&#10; ***************************************************************************&#13;&#10; **                                     **&#13;&#10; **   function enables or disables the lasal online communication     ** &#13;&#10; ***************************************************************************&#13;&#10;[&gt;state]0:Lasal online communication disabled; 1=Lasal online communication enabled&#13;&#10;[&lt;ErrorCode]0=OK; -1:Com&lt;&gt;1-4; -2=Error baudtable; -3=baudrate&lt;&gt;0-10; -4=parity&lt;&gt;0-4; - 5=stopbits&lt;&gt;1-2; -6=ErrorWORDLEN; -10=Com allready in use; -11=Com allready in use of OS; -12=CPU has no COM of this No.;-13=OS Error;-14=NoInitialization; -15=WRONG INPUT; -16=receiving buffer too low, has to be bigger then &gt;= 128 Byte&apos;s; -17=INPUT was NIL; -19=no DATA in receiving buffer; -20=sending process couldn&apos;t be ended (disturbance., sendbuffer overflow, ...)" Name="SetOnline"/>
	FUNCTION VIRTUAL GLOBAL SetOnline
		VAR_INPUT
			state 	: UDINT;			//! <Variable Comment="0=low: shut down lasal online communication&#13;&#10;1=high turn on lasal online communication (standard)" Name="SetOnline.state"/>
		END_VAR
		VAR_OUTPUT
			ErrorCode 	: DINT;			//! <Variable Comment="returns the errorcode&#13;&#10;0=OK; &#13;&#10;-1:Com&lt;&gt;1-4; &#13;&#10;-2=Error baudtable; &#13;&#10;-3=baudrate&lt;&gt;0-10; &#13;&#10;-4=parity&lt;&gt;0-4; &#13;&#10;- 5=stopbits&lt;&gt;1-2; &#13;&#10;-6=ErrorWORDLEN; &#13;&#10;-10=Com allready in use; &#13;&#10;-11=Com allready in use of OS; &#13;&#10;-12=CPU has no COM of this No.;&#13;&#10;-13=OS Error;-14=NoInitialization; &#13;&#10;-15=WRONG INPUT; -16=receiving buffer too low, has to be bigger then &gt;= 128 Byte&apos;s; &#13;&#10;-17=INPUT was NIL; &#13;&#10;-19=no DATA in receiving buffer; &#13;&#10;-20=sending process couldn&apos;t be ended (disturbance., sendbuffer overflow, ...)" Name="SetOnline.ErrorCode"/>
		END_VAR;
				//! <Function Comment=" ***************************************************************************&#13;&#10; ****************       _SerLib::RecvBlock        *********************&#13;&#10; ***************************************************************************&#13;&#10; ****                                 ******&#13;&#10; ****   reads a area of character of the receiving buffer       ******&#13;&#10; ***************************************************************************&#13;&#10;[&gt;rdlength]Bytes you want to read of the receiving buffer&#13;&#10;[&gt;rdlen]number of correct readed Bytes&#13;&#10;" Name="RecvBlock"/>
	FUNCTION VIRTUAL GLOBAL RecvBlock
		VAR_INPUT
			Buffer 	: ^void;			//! <Variable Comment="Pointer to receivbuffer" Name="RecvBlock.Buffer"/>
			rdlength 	: UDINT;			//! <Variable Comment="Number of bytes that should be received" Name="RecvBlock.rdlength"/>
			rdlen 	: ^UDINT;			//! <Variable Comment="number of correct received bytes" Name="RecvBlock.rdlen"/>
		END_VAR
		VAR_OUTPUT
			ErrorCode 	: DINT;			//! <Variable Comment="returns the errorcode&#13;&#10;0=OK; &#13;&#10;-1:Com&lt;&gt;1-4; &#13;&#10;-2=Error baudtable; &#13;&#10;-3=baudrate&lt;&gt;0-10; &#13;&#10;-4=parity&lt;&gt;0-4; &#13;&#10;- 5=stopbits&lt;&gt;1-2; &#13;&#10;-6=ErrorWORDLEN; &#13;&#10;-10=Com allready in use; &#13;&#10;-11=Com allready in use of OS; &#13;&#10;-12=CPU has no COM of this No.;&#13;&#10;-13=OS Error;-14=NoInitialization; &#13;&#10;-15=WRONG INPUT; -16=receiving buffer too low, has to be bigger then &gt;= 128 Byte&apos;s; &#13;&#10;-17=INPUT was NIL; &#13;&#10;-19=no DATA in receiving buffer; &#13;&#10;-20=sending process couldn&apos;t be ended (disturbance., sendbuffer overflow, ...)" Name="RecvBlock.ErrorCode"/>
		END_VAR;
				//! <Function Comment="&#13;&#10; ***************************************************************************&#13;&#10; ****************      _SerLib::RecvChar         ***********************&#13;&#10; ***************************************************************************&#13;&#10; ****                                 ******&#13;&#10; ***    the function reads one byte from the serial drivers receive   ******&#13;&#10; ****    buffer                            ******&#13;&#10; ***************************************************************************&#13;&#10;[&gt;Buffer]Pointer to receiving buffer&#13;&#10;[&lt;ErrorCode]0=OK; -1:Com&lt;&gt;1-4; -2=Error baudtable; -3=baudrate&lt;&gt;0-10; -4=parity&lt;&gt;0-4; - 5=stopbits&lt;&gt;1-2; -6=ErrorWORDLEN; -10=Com allready in use; -11=Com allready in use of OS; -12=CPU has no COM of this No.;-13=OS Error;-14=NoInitialization; -15=WRONG INPUT; -16=receiving buffer too low, has to be bigger then &gt;= 128 Byte&apos;s; -17=INPUT was NIL; -19=no DATA in receiving buffer; -20=sending process couldn&apos;t be ended (disturbance., sendbuffer overflow, ...)" Name="RecvChar"/>
	FUNCTION VIRTUAL GLOBAL RecvChar
		VAR_INPUT
			Buffer 	: ^void;			//! <Variable Comment="pointer to the buffer" Name="RecvChar.Buffer"/>
		END_VAR
		VAR_OUTPUT
			ErrorCode 	: DINT;			//! <Variable Comment="returns the errorcode&#13;&#10;0=OK; &#13;&#10;-1:Com&lt;&gt;1-4; &#13;&#10;-2=Error baudtable; &#13;&#10;-3=baudrate&lt;&gt;0-10; &#13;&#10;-4=parity&lt;&gt;0-4; &#13;&#10;- 5=stopbits&lt;&gt;1-2; &#13;&#10;-6=ErrorWORDLEN; &#13;&#10;-10=Com allready in use; &#13;&#10;-11=Com allready in use of OS; &#13;&#10;-12=CPU has no COM of this No.;&#13;&#10;-13=OS Error;-14=NoInitialization; &#13;&#10;-15=WRONG INPUT; -16=receiving buffer too low, has to be bigger then &gt;= 128 Byte&apos;s; &#13;&#10;-17=INPUT was NIL; &#13;&#10;-19=no DATA in receiving buffer; &#13;&#10;-20=sending process couldn&apos;t be ended (disturbance., sendbuffer overflow, ...)" Name="RecvChar.ErrorCode"/>
		END_VAR;
				//! <Function Comment=" ***************************************************************************&#13;&#10; ****************       _SerLib::GetRecvStatus        *****************&#13;&#10; ***************************************************************************&#13;&#10; ***                                     ***&#13;&#10; ***     returns the number of characters in the receive buffer          ***&#13;&#10; ***     if return value &lt; 0 --&gt; return value = Error Code               ***&#13;&#10; ***************************************************************************&#13;&#10;[&lt;length]number of bytes in receiving buffer&#13;&#10;" Name="GetRecvState"/>
	FUNCTION VIRTUAL GLOBAL GetRecvState
		VAR_OUTPUT
			length 	: UDINT;			//! <Variable Comment="Number of bytes in the OS receive buffer&#13;&#10;(cast the return value to a DINT to get also negative values)" Name="GetRecvState.length"/>
		END_VAR;
				//! <Function Comment=" ***************************************************************************&#13;&#10; ****************        _SerLib::GetSendStatus          *****************&#13;&#10; ***************************************************************************&#13;&#10; ***                                 ******&#13;&#10; ***     returns, how many Bytes are in the &quot;senbuffer&quot;             ******&#13;&#10; ***     if return value &lt; 0 --&gt; return value = Error Code            ******&#13;&#10; ***************************************************************************&#13;&#10;[&lt;to_send]How many Bytes are too send&#13;&#10;" Name="GetSendState"/>
	FUNCTION VIRTUAL GLOBAL GetSendState
		VAR_OUTPUT
			to_send 	: UDINT;			//! <Variable Comment="If the function succeeds, the return value is the number of characters in the send buffer, otherwise a negative error code value is returned.&#13;&#10;(cast the return value to a DINT to get also negative values)" Name="GetSendState.to_send"/>
		END_VAR;
				//! <Function Comment=" *********************************************************************************************&#13;&#10; ****************************     _SerLib::GetError      *************************************&#13;&#10; *********************************************************************************************&#13;&#10; **  returns actual error state                               ***&#13;&#10; ** ---------------------------------------------------------------------------------------***&#13;&#10; ****                                             ***&#13;&#10; **            !!!!    ERROR CODE TABLE   !!!!                         ***&#13;&#10; **                                              ***&#13;&#10; **   0 .. SERERROR_NONE                                   ***&#13;&#10; ** - 1 .. SERERROR_COMNUM     -&gt; Com &lt;&gt; 1-4                         ***&#13;&#10; ** - 2 .. SERERROR_BAUDTABLE  -&gt; Error baudtable                       ***&#13;&#10; ** - 3 .. SERERROR_BAUDRATE   -&gt; baudrate &lt;&gt; 0-10                      ***&#13;&#10; ** - 4 .. SERERROR_PARITY     -&gt; parity &lt;&gt; 0-4                        ***&#13;&#10; ** - 5 .. SERERROR_STOPBIT    -&gt; Stopbits &lt;&gt; 1-2                       ***&#13;&#10; ** - 6 .. SERERROR_WORDLEN   -&gt; wrong wordlength                      ***&#13;&#10; ** -10 .. SERERROR_INUSE      -&gt; Com allready in use                      ***&#13;&#10; ** -11 .. SERERROR_OSINUSE    -&gt; Com allready in use of OS                   ***&#13;&#10; ** -12 .. SERERROR_NOTAVAIL   -&gt; CPU has no COM of this NR                  ***&#13;&#10; ** -13 .. SERERROR_NOMEM      -&gt; OS Error                          ***&#13;&#10; ** -14 .. SERERROR_NOHANDLE  -&gt; Com not initialized                     ***&#13;&#10; ** -15 .. SERERROR_PARAMETER  -&gt; WRONG INPUT                         ***&#13;&#10; ** -16 .. SERERROR_RECVBUF    -&gt; Receiving Buffer too low, has to bigger then &gt;= 128 Byte&apos;s**&#13;&#10; ** -17 .. SERERROR_SENDBUF    -&gt; INPUT was NIL                        ***&#13;&#10; ** -18 .. SERERROR_TOOLONG                                    ***&#13;&#10; ** -19 .. SERERROR_RECVERROR  -&gt; No DATA in Receiving Buffer                 ***&#13;&#10; ** -20 .. SERERROR_SENDERROR  -&gt; sending process couldn&apos;t be ended (disturbance., sendbuffer overflow, ...)&#13;&#10; *********************************************************************************************&#13;&#10;" Name="GetError"/>
	FUNCTION VIRTUAL GLOBAL GetError
		VAR_OUTPUT
			ErrorCode 	: DINT;			//! <Variable Comment="returns the errorcode&#13;&#10;0=OK; &#13;&#10;-1:Com&lt;&gt;1-4; &#13;&#10;-2=Error baudtable; &#13;&#10;-3=baudrate&lt;&gt;0-10; &#13;&#10;-4=parity&lt;&gt;0-4; &#13;&#10;- 5=stopbits&lt;&gt;1-2; &#13;&#10;-6=ErrorWORDLEN; &#13;&#10;-10=Com allready in use; &#13;&#10;-11=Com allready in use of OS; &#13;&#10;-12=CPU has no COM of this No.;&#13;&#10;-13=OS Error;-14=NoInitialization; &#13;&#10;-15=WRONG INPUT; -16=receiving buffer too low, has to be bigger then &gt;= 128 Byte&apos;s; &#13;&#10;-17=INPUT was NIL; &#13;&#10;-19=no DATA in receiving buffer; &#13;&#10;-20=sending process couldn&apos;t be ended (disturbance., sendbuffer overflow, ...)" Name="GetError.ErrorCode"/>
		END_VAR;
				//! <Function Comment=" ***************************************************************&#13;&#10; ******************    _SerLib::IsInitialized   ****************&#13;&#10; ***************************************************************&#13;&#10; **     Checks, if COM is inialized              ***&#13;&#10; **     OUTPUT: 0 = NO Initialization             ****&#13;&#10; **           1 = initialized                ****&#13;&#10; ***************************************************************&#13;&#10;[&lt;Initialization]initialized 0=NO/1=YES&#13;&#10;" Name="IsInitialized"/>
	FUNCTION VIRTUAL GLOBAL IsInitialized
		VAR_OUTPUT
			Initialization 	: UDINT;			//! <Variable Comment="is it initialized &#13;&#10;0 = no&#13;&#10;1 = yes" Name="IsInitialized.Initialization"/>
		END_VAR;
				//! <Function Comment=" ***************************************************************&#13;&#10; ******************      _SerLib::GetInfo      ****************&#13;&#10; ***************************************************************&#13;&#10; ***                              ****&#13;&#10; ***   returns INFO of COM                  ****&#13;&#10; ***   INFO:initialized, ComPortNr, IOPort, IRQNum, ....    ****&#13;&#10; ***** -------------------------------------------------- ******&#13;&#10; ***  --&gt; Info     = Pointer of Strukt LSLAPI_SERIALINFO    ****&#13;&#10; ***  &lt;-- ErrorCode= Error Code                      ****&#13;&#10; ***************************************************************&#13;&#10;[&gt;Info]initialized : USINT; comportnum : USINT; IRQNum : USINT; IOPort : UINT; Baudrate : UINT; Ptr_RecvBuffer : pVoid; Ptr_SendBuffer : pVoid;&#13;&#10;" Name="GetInfo"/>
	FUNCTION VIRTUAL GLOBAL GetInfo
		VAR_INPUT
			Info 	: ^LSLAPI_SERIALINFO;			//! <Variable Comment="initialized : USINT; comportnum : USINT; IRQNum : USINT; IOPort : UINT; Baudrate : UINT; Ptr_RecvBuffer : pVoid; Ptr_SendBuffer : pVoid;" Name="GetInfo.Info"/>
		END_VAR
		VAR_OUTPUT
			ErrorCode 	: DINT;			//! <Variable Comment="returns the errorcode&#13;&#10;0=OK; &#13;&#10;-1:Com&lt;&gt;1-4; &#13;&#10;-2=Error baudtable; &#13;&#10;-3=baudrate&lt;&gt;0-10; &#13;&#10;-4=parity&lt;&gt;0-4; &#13;&#10;- 5=stopbits&lt;&gt;1-2; &#13;&#10;-6=ErrorWORDLEN; &#13;&#10;-10=Com allready in use; &#13;&#10;-11=Com allready in use of OS; &#13;&#10;-12=CPU has no COM of this No.;&#13;&#10;-13=OS Error;-14=NoInitialization; &#13;&#10;-15=WRONG INPUT; -16=receiving buffer too low, has to be bigger then &gt;= 128 Byte&apos;s; &#13;&#10;-17=INPUT was NIL; &#13;&#10;-19=no DATA in receiving buffer; &#13;&#10;-20=sending process couldn&apos;t be ended (disturbance., sendbuffer overflow, ...)" Name="GetInfo.ErrorCode"/>
		END_VAR;
				//! <Function Comment=" ***************************************************************************&#13;&#10; ***************      _SerLib::SetBufferRecv     **************************&#13;&#10; ***************************************************************************&#13;&#10; ***                                   ******&#13;&#10; * function specifies a new receive buffer or a recommended size, in bytes *&#13;&#10; *  of the driver&apos;s internal receive buffer                 *&#13;&#10; **  !!!!   minimumsize 128 Byte    !!!!                ******&#13;&#10; ** If no receivingbuffer is initialized, a DEFAULTbuffer (1024 Byte) ******&#13;&#10; ** will be used                           ******&#13;&#10; ***************************************************************************&#13;&#10;[&gt;RecvBuffer]Pointer of Receiving Buffer&#13;&#10;[&gt;BufferLength]size of buffer (min. 128 byte)&#13;&#10;" Name="SetBufferRecv"/>
	FUNCTION VIRTUAL GLOBAL SetBufferRecv
		VAR_INPUT
			RecvBuffer 	: ^void;			//! <Variable Comment="pointer of new receive buffer" Name="SetBufferRecv.RecvBuffer"/>
			BufferLength 	: UDINT;			//! <Variable Comment="size of new receive buffer (min. 128 byte)" Name="SetBufferRecv.BufferLength"/>
		END_VAR
		VAR_OUTPUT
			ErrorCode 	: DINT;			//! <Variable Comment="returns the errorcode&#13;&#10;0=OK; &#13;&#10;-1:Com&lt;&gt;1-4; &#13;&#10;-2=Error baudtable; &#13;&#10;-3=baudrate&lt;&gt;0-10; &#13;&#10;-4=parity&lt;&gt;0-4; &#13;&#10;- 5=stopbits&lt;&gt;1-2; &#13;&#10;-6=ErrorWORDLEN; &#13;&#10;-10=Com allready in use; &#13;&#10;-11=Com allready in use of OS; &#13;&#10;-12=CPU has no COM of this No.;&#13;&#10;-13=OS Error;-14=NoInitialization; &#13;&#10;-15=WRONG INPUT; -16=receiving buffer too low, has to be bigger then &gt;= 128 Byte&apos;s; &#13;&#10;-17=INPUT was NIL; &#13;&#10;-19=no DATA in receiving buffer; &#13;&#10;-20=sending process couldn&apos;t be ended (disturbance., sendbuffer overflow, ...)" Name="SetBufferRecv.ErrorCode"/>
		END_VAR;
				//! <Function Comment=" ***************************************************************************&#13;&#10; ****************      _SerLib::ClearRecvBuffer          ***************&#13;&#10; ***************************************************************************&#13;&#10; ***                                     ***&#13;&#10; ***      clears the receiving buffer                     ***&#13;&#10; ***      ( puts the reading pointer to the startposition)          ***&#13;&#10; ***************************************************************************&#13;&#10;" Name="ClearRecvBuffer"/>
	FUNCTION VIRTUAL GLOBAL ClearRecvBuffer
		VAR_OUTPUT
			ErrorCode 	: DINT;			//! <Variable Comment="returns the errorcode&#13;&#10;0=OK; &#13;&#10;-1:Com&lt;&gt;1-4; &#13;&#10;-2=Error baudtable; &#13;&#10;-3=baudrate&lt;&gt;0-10; &#13;&#10;-4=parity&lt;&gt;0-4; &#13;&#10;- 5=stopbits&lt;&gt;1-2; &#13;&#10;-6=ErrorWORDLEN; &#13;&#10;-10=Com allready in use; &#13;&#10;-11=Com allready in use of OS; &#13;&#10;-12=CPU has no COM of this No.;&#13;&#10;-13=OS Error;-14=NoInitialization; &#13;&#10;-15=WRONG INPUT; -16=receiving buffer too low, has to be bigger then &gt;= 128 Byte&apos;s; &#13;&#10;-17=INPUT was NIL; &#13;&#10;-19=no DATA in receiving buffer; &#13;&#10;-20=sending process couldn&apos;t be ended (disturbance., sendbuffer overflow, ...)" Name="ClearRecvBuffer.ErrorCode"/>
		END_VAR;
				//! <Function Comment=" **********************************************************************************&#13;&#10; *******************            sets/clr&apos;s   RTS            ***********************&#13;&#10; **********************************************************************************&#13;&#10; *                                                                                *&#13;&#10; *  Functin set&apos;s or clear&apos;s RTS on the SERIAL interfaces                         *&#13;&#10; *  RTS = PIN 7  (9pol. D-SUB)                                                    *&#13;&#10; ** ----------------------------------------------------------------------------- *&#13;&#10; *  -&gt; state=0: LOW                                                               *&#13;&#10; *     state=1: HIGH (normally)                                                   *&#13;&#10; *                                                                                *&#13;&#10; ** ----------------------------------------------------------------------------- *&#13;&#10; ** created    : RM :  KW 38/03                                                   *&#13;&#10; **********************************************************************************&#13;&#10;" Name="RtsOnOff"/>
	FUNCTION VIRTUAL GLOBAL RtsOnOff
		VAR_INPUT
			state 	: BOOL;			//! <Variable Comment="0=low, 1=high (normally)" Name="RtsOnOff.state"/>
		END_VAR
		VAR_OUTPUT
			ErrorCode 	: DINT;			//! <Variable Comment="returns the errorcode&#13;&#10;0=OK; &#13;&#10;-1:Com&lt;&gt;1-4; &#13;&#10;-2=Error baudtable; &#13;&#10;-3=baudrate&lt;&gt;0-10; &#13;&#10;-4=parity&lt;&gt;0-4; &#13;&#10;- 5=stopbits&lt;&gt;1-2; &#13;&#10;-6=ErrorWORDLEN; &#13;&#10;-10=Com allready in use; &#13;&#10;-11=Com allready in use of OS; &#13;&#10;-12=CPU has no COM of this No.;&#13;&#10;-13=OS Error;-14=NoInitialization; &#13;&#10;-15=WRONG INPUT; -16=receiving buffer too low, has to be bigger then &gt;= 128 Byte&apos;s; &#13;&#10;-17=INPUT was NIL; &#13;&#10;-19=no DATA in receiving buffer; &#13;&#10;-20=sending process couldn&apos;t be ended (disturbance., sendbuffer overflow, ...)" Name="RtsOnOff.ErrorCode"/>
		END_VAR;
				//! <Function Comment=" **********************************************************************************&#13;&#10; *******************               read&apos;s   RTS             ***********************&#13;&#10; **********************************************************************************&#13;&#10; *                                                                                *&#13;&#10; *  Functin read&apos;s RTS on the Serial interfaces                                   *&#13;&#10; *  RTS = PIN 7  (9pol. D-SUB)                                                    *&#13;&#10; ** ----------------------------------------------------------------------------- *&#13;&#10; *  &lt;- state=0: LOW                                                               *&#13;&#10; *     state=1: HIGH (normally)                                                   *&#13;&#10; *                                                                                *&#13;&#10; ** ----------------------------------------------------------------------------- *&#13;&#10; ** created    : RM :  KW 38/03                                                   *&#13;&#10; **********************************************************************************&#13;&#10;" Name="rdRts"/>
	FUNCTION VIRTUAL GLOBAL rdRts
		VAR_OUTPUT
			state 	: BOOL;			//! <Variable Comment="0=LOW, 1=HIGH" Name="rdRts.state"/>
		END_VAR;
				//! <Function Comment=" **********************************************************************************&#13;&#10; *******************               read&apos;s   CTS             ***********************&#13;&#10; **********************************************************************************&#13;&#10; *                                                                                *&#13;&#10; *  Functin read&apos;s CTS on the Serial interfaces                                   *&#13;&#10; *  CTS = PIN 8  (9pol. D-SUB)                                                    *&#13;&#10; ** ----------------------------------------------------------------------------- *&#13;&#10; *  &lt;- state=0: LOW                                                               *&#13;&#10; *     state=1: HIGH                                                              *&#13;&#10; *                                                                                *&#13;&#10; ** ----------------------------------------------------------------------------- *&#13;&#10; ** created    : RM :  KW 38/03                                                   *&#13;&#10; **********************************************************************************&#13;&#10;" Name="rdCts"/>
	FUNCTION VIRTUAL GLOBAL rdCts
		VAR_OUTPUT
			state 	: BOOL;			//! <Variable Comment="0=LOW, 1=HIGH" Name="rdCts.state"/>
		END_VAR;
				//! <Function Comment=" **********************************************************************************&#13;&#10; *******************            sets/clr&apos;s   DTR            ***********************&#13;&#10; **********************************************************************************&#13;&#10; *                                                                                *&#13;&#10; *  Functin set&apos;s or clear&apos;s DTR on the SERIAL interfaces                         *&#13;&#10; *  DTR = PIN 4  (9pol. D-SUB)                                                    *&#13;&#10; ** ----------------------------------------------------------------------------- *&#13;&#10; *  -&gt; state=0: LOW                                                               *&#13;&#10; *     state=1: HIGH (normally)                                                   *&#13;&#10; *                                                                                *&#13;&#10; ** ----------------------------------------------------------------------------- *&#13;&#10; ** created    : BS :  KW 48/03                                                   *&#13;&#10; **********************************************************************************&#13;&#10;" Name="DtrOnOff"/>
	FUNCTION VIRTUAL GLOBAL DtrOnOff
		VAR_INPUT
			state 	: BOOL;			//! <Variable Comment="0 = LOW&#13;&#10;1 = HIGH" Name="DtrOnOff.state"/>
		END_VAR
		VAR_OUTPUT
			ErrorCode 	: DINT;			//! <Variable Comment="returns the errorcode&#13;&#10;0=OK; &#13;&#10;-1:Com&lt;&gt;1-4; &#13;&#10;-2=Error baudtable; &#13;&#10;-3=baudrate&lt;&gt;0-10; &#13;&#10;-4=parity&lt;&gt;0-4; &#13;&#10;- 5=stopbits&lt;&gt;1-2; &#13;&#10;-6=ErrorWORDLEN; &#13;&#10;-10=Com allready in use; &#13;&#10;-11=Com allready in use of OS; &#13;&#10;-12=CPU has no COM of this No.;&#13;&#10;-13=OS Error;-14=NoInitialization; &#13;&#10;-15=WRONG INPUT; -16=receiving buffer too low, has to be bigger then &gt;= 128 Byte&apos;s; &#13;&#10;-17=INPUT was NIL; &#13;&#10;-19=no DATA in receiving buffer; &#13;&#10;-20=sending process couldn&apos;t be ended (disturbance., sendbuffer overflow, ...)" Name="DtrOnOff.ErrorCode"/>
		END_VAR;
				//! <Function Comment=" **********************************************************************************&#13;&#10; *******************               read&apos;s   DTR             ***********************&#13;&#10; **********************************************************************************&#13;&#10; *                                                                                *&#13;&#10; *  Functin read&apos;s DTR on the Serial interfaces                                   *&#13;&#10; *  DTR = PIN 4  (9pol. D-SUB)                                                    *&#13;&#10; ** ----------------------------------------------------------------------------- *&#13;&#10; *  &lt;- state=0: LOW                                                               *&#13;&#10; *     state=1: HIGH                                                              *&#13;&#10; *                                                                                *&#13;&#10; ** ----------------------------------------------------------------------------- *&#13;&#10; ** created    : BS :  KW 48/03                                                   *&#13;&#10; **********************************************************************************&#13;&#10;" Name="rdDtr"/>
	FUNCTION VIRTUAL GLOBAL rdDtr
		VAR_OUTPUT
			state 	: BOOL;			//! <Variable Comment="0 = LOW&#13;&#10;1 = HIGH" Name="rdDtr.state"/>
		END_VAR;
				//! <Function Comment=" **********************************************************************************&#13;&#10; *******************               read&apos;s  DCD              ***********************&#13;&#10; **********************************************************************************&#13;&#10; *  Data Carrier Detect                                                           *&#13;&#10; *  Functin read&apos;s DCD on the Serial interfaces                                   *&#13;&#10; *  DCD = PIN 1  (9pol. D-SUB)                                                    *&#13;&#10; ** ----------------------------------------------------------------------------- *&#13;&#10; *  &lt;- state=0: LOW                                                               *&#13;&#10; *     state=1: HIGH                                                              *&#13;&#10; *                                                                                *&#13;&#10; ** ----------------------------------------------------------------------------- *&#13;&#10; ** created    : BS :  KW 48/03                                                   *&#13;&#10; **********************************************************************************&#13;&#10;" Name="rdDCD"/>
	FUNCTION VIRTUAL GLOBAL rdDCD
		VAR_OUTPUT
			state 	: BOOL;			//! <Variable Comment="0 = LOW&#13;&#10;1 = HIGH" Name="rdDCD.state"/>
		END_VAR;
				//! <Function Comment=" **********************************************************************************&#13;&#10; *******************               read&apos;s   DSR             ***********************&#13;&#10; **********************************************************************************&#13;&#10; *                                                                                *&#13;&#10; *  Functin read&apos;s DSR on the Serial interfaces                                   *&#13;&#10; *  DSR = PIN 6  (9pol. D-SUB)                                                    *&#13;&#10; ** ----------------------------------------------------------------------------- *&#13;&#10; *  &lt;- state=0: LOW                                                               *&#13;&#10; *     state=1: HIGH                                                              *&#13;&#10; *                                                                                *&#13;&#10; ** ----------------------------------------------------------------------------- *&#13;&#10; ** created    : BS :  KW 48/03                                                   *&#13;&#10; **********************************************************************************&#13;&#10;" Name="rdDSR"/>
	FUNCTION VIRTUAL GLOBAL rdDSR
		VAR_OUTPUT
			state 	: BOOL;			//! <Variable Comment="0 = LOW&#13;&#10;1 = HIGH" Name="rdDSR.state"/>
		END_VAR;
				//! <Function Comment=" **********************************************************************************&#13;&#10; *******************               read&apos;s  RI               ***********************&#13;&#10; **********************************************************************************&#13;&#10; *  Ring Indicator                                                                *&#13;&#10; *  Functin read&apos;s RI  on the Serial interfaces                                   *&#13;&#10; *  RI  = PIN 9  (9pol. D-SUB)                                                    *&#13;&#10; ** ----------------------------------------------------------------------------- *&#13;&#10; *  &lt;- state=0: LOW                                                               *&#13;&#10; *     state=1: HIGH                                                              *&#13;&#10; *                                                                                *&#13;&#10; ** ----------------------------------------------------------------------------- *&#13;&#10; ** created    : BS :  KW 48/03                                                   *&#13;&#10; **********************************************************************************&#13;&#10;" Name="rdRI"/>
	FUNCTION VIRTUAL GLOBAL rdRI
		VAR_OUTPUT
			state 	: BOOL;			//! <Variable Comment="0 = LOW&#13;&#10;1 = HIGH" Name="rdRI.state"/>
		END_VAR;
				//! <Function Comment="Function sets the mode of the interface                   &#13;&#10; -&gt; MODE : RS232 = 232 (normally) &#13;&#10;           RS422 = 422 &#13;&#10;           RS485 = 485 or 4850 (without echo)&#13;&#10; &lt;- ErrorCode                      &#13;&#10;" Name="SetRSMode"/>
	FUNCTION VIRTUAL GLOBAL SetRSMode
		VAR_INPUT
			Mode 	: UDINT;			//! <Variable Comment="RS232 = 232 &#13;&#10;RS422 = 422; &#13;&#10;RS485 = 485  (with echo)&#13;&#10;        4850 (without echo)" Name="SetRSMode.Mode"/>
		END_VAR
		VAR_OUTPUT
			ErrorCode 	: DINT;			//! <Variable Comment="returns the errorcode&#13;&#10;0=OK; &#13;&#10;-1:Com&lt;&gt;1-4; &#13;&#10;-2=Error baudtable; &#13;&#10;-3=baudrate&lt;&gt;0-10; &#13;&#10;-4=parity&lt;&gt;0-4; &#13;&#10;- 5=stopbits&lt;&gt;1-2; &#13;&#10;-6=ErrorWORDLEN; &#13;&#10;-10=Com allready in use; &#13;&#10;-11=Com allready in use of OS; &#13;&#10;-12=CPU has no COM of this No.;&#13;&#10;-13=OS Error;-14=NoInitialization; &#13;&#10;-15=WRONG INPUT; -16=receiving buffer too low, has to be bigger then &gt;= 128 Byte&apos;s; &#13;&#10;-17=INPUT was NIL; &#13;&#10;-19=no DATA in receiving buffer; &#13;&#10;-20=sending process couldn&apos;t be ended (disturbance., sendbuffer overflow, ...)" Name="SetRSMode.ErrorCode"/>
		END_VAR;
				//! <Function Comment=" **********************************************************************************&#13;&#10; *******************              liest RSMode              ***********************&#13;&#10; **********************************************************************************&#13;&#10; *  Funktion liefert den Modus der Schnittstelle                                  *&#13;&#10; ** ----------------------------------------------------------------------------- *&#13;&#10; *  -&gt; MODE   : Für RS232 = 232 | RS422 = 422  IF Mode&lt;0 =&gt; Mode=ErrorCode        *&#13;&#10; *  &lt;- ErrorCode                                                                  *&#13;&#10; *                                                                                *&#13;&#10; ** ----------------------------------------------------------------------------- *&#13;&#10; ** erstellt   : RM :  KW 48/03                                                   *&#13;&#10; **********************************************************************************&#13;&#10; **********************************************************************************&#13;&#10; *******************            get&apos;s RSMode                ***********************&#13;&#10; **********************************************************************************&#13;&#10; *  function reads the RS Mode                                                    *&#13;&#10; ** ----------------------------------------------------------------------------- *&#13;&#10; *  -&gt; MODE   : For RS232 = 232 | RS422 = 422 IF Mode&lt;0 =&gt; Mode=ErrorCode         *&#13;&#10; *                                                                                *&#13;&#10; *                                                                                *&#13;&#10; ** ----------------------------------------------------------------------------- *&#13;&#10; ** created    : RM :  KW 48/03                                                   *&#13;&#10; **********************************************************************************&#13;&#10;[&gt;Mode]For RS232 = 232 | RS422 = 422; IF Mode&lt;0 =&gt; Mode=ErrorCode&#13;&#10;" Name="GetRSMode"/>
	FUNCTION VIRTUAL GLOBAL GetRSMode
		VAR_OUTPUT
			Mode 	: DINT;			//! <Variable Comment="232 = RS232&#13;&#10;422 = RS422&#13;&#10;" Name="GetRSMode.Mode"/>
		END_VAR;
				//! <Function Comment="Gets the timestamp from received character&#13;&#10;Buffer is used like normal receive buffer (see RecvChar)" Name="RecvTimingChar"/>
	FUNCTION VIRTUAL GLOBAL RecvTimingChar
		VAR_INPUT
			Buffer 	: ^void;			//! <Variable Comment="Buffer where the timestamps are stored" Name="RecvTimingChar.Buffer"/>
		END_VAR
		VAR_OUTPUT
			ErrorCode 	: DINT;			//! <Variable Comment="returns the errorcode&#13;&#10;0=OK; &#13;&#10;-1:Com&lt;&gt;1-4; &#13;&#10;-2=Error baudtable; &#13;&#10;-3=baudrate&lt;&gt;0-10; &#13;&#10;-4=parity&lt;&gt;0-4; &#13;&#10;- 5=stopbits&lt;&gt;1-2; &#13;&#10;-6=ErrorWORDLEN; &#13;&#10;-10=Com allready in use; &#13;&#10;-11=Com allready in use of OS; &#13;&#10;-12=CPU has no COM of this No.;&#13;&#10;-13=OS Error;-14=NoInitialization; &#13;&#10;-15=WRONG INPUT; -16=receiving buffer too low, has to be bigger then &gt;= 128 Byte&apos;s; &#13;&#10;-17=INPUT was NIL; &#13;&#10;-19=no DATA in receiving buffer; &#13;&#10;-20=sending process couldn&apos;t be ended (disturbance., sendbuffer overflow, ...)" Name="RecvTimingChar.ErrorCode"/>
		END_VAR;
				//! <Function Comment="Gets the timestamps of an received block&#13;&#10;Buffer is used like normal receive buffer (see RecvBlock)" Name="RecvTimingBlock"/>
	FUNCTION VIRTUAL GLOBAL RecvTimingBlock
		VAR_INPUT
			Buffer 	: ^void;			//! <Variable Comment="Buffer where the timestamps are stored" Name="RecvTimingBlock.Buffer"/>
			rdlength 	: UDINT;			//! <Variable Comment="Number of timestamps that should be read out of the buffer" Name="RecvTimingBlock.rdlength"/>
			rdlen 	: ^UDINT;			//! <Variable Comment="number of correct received timestamps" Name="RecvTimingBlock.rdlen"/>
		END_VAR
		VAR_OUTPUT
			ErrorCode 	: DINT;			//! <Variable Comment="returns the errorcode&#13;&#10;0=OK; &#13;&#10;-1:Com&lt;&gt;1-4; &#13;&#10;-2=Error baudtable; &#13;&#10;-3=baudrate&lt;&gt;0-10; &#13;&#10;-4=parity&lt;&gt;0-4; &#13;&#10;- 5=stopbits&lt;&gt;1-2; &#13;&#10;-6=ErrorWORDLEN; &#13;&#10;-10=Com allready in use; &#13;&#10;-11=Com allready in use of OS; &#13;&#10;-12=CPU has no COM of this No.;&#13;&#10;-13=OS Error;-14=NoInitialization; &#13;&#10;-15=WRONG INPUT; -16=receiving buffer too low, has to be bigger then &gt;= 128 Byte&apos;s; &#13;&#10;-17=INPUT was NIL; &#13;&#10;-19=no DATA in receiving buffer; &#13;&#10;-20=sending process couldn&apos;t be ended (disturbance., sendbuffer overflow, ...)" Name="RecvTimingBlock.ErrorCode"/>
		END_VAR;
				//! <Function Comment="Clears the buffer where the timestamps are stored&#13;&#10;This function is used like the function clearBuffer" Name="ClearTimingBuffer"/>
	FUNCTION VIRTUAL GLOBAL ClearTimingBuffer
		VAR_OUTPUT
			ErrorCode 	: DINT;			//! <Variable Comment="returns the errorcode&#13;&#10;0=OK; &#13;&#10;-1:Com&lt;&gt;1-4; &#13;&#10;-2=Error baudtable; &#13;&#10;-3=baudrate&lt;&gt;0-10; &#13;&#10;-4=parity&lt;&gt;0-4; &#13;&#10;- 5=stopbits&lt;&gt;1-2; &#13;&#10;-6=ErrorWORDLEN; &#13;&#10;-10=Com allready in use; &#13;&#10;-11=Com allready in use of OS; &#13;&#10;-12=CPU has no COM of this No.;&#13;&#10;-13=OS Error;-14=NoInitialization; &#13;&#10;-15=WRONG INPUT; -16=receiving buffer too low, has to be bigger then &gt;= 128 Byte&apos;s; &#13;&#10;-17=INPUT was NIL; &#13;&#10;-19=no DATA in receiving buffer; &#13;&#10;-20=sending process couldn&apos;t be ended (disturbance., sendbuffer overflow, ...)" Name="ClearTimingBuffer.ErrorCode"/>
		END_VAR;
				//! <Function Comment="With this function it is possible to set a specific receive buffer&#13;&#10;where the timestamps of the received bytes are stored&#13;&#10;This function is used like the function SetBufferRecv" Name="SetTimingBufferRecv"/>
	FUNCTION VIRTUAL GLOBAL SetTimingBufferRecv
		VAR_INPUT
			RecvBuffer 	: ^void;			//! <Variable Comment="pointer of the new buffer" Name="SetTimingBufferRecv.RecvBuffer"/>
			BufferLength 	: UDINT;			//! <Variable Comment="size of the buffer (min. 128 bytes)" Name="SetTimingBufferRecv.BufferLength"/>
		END_VAR
		VAR_OUTPUT
			ErrorCode 	: DINT;			//! <Variable Comment="returns the errorcode&#13;&#10;0=OK; &#13;&#10;-1:Com&lt;&gt;1-4; &#13;&#10;-2=Error baudtable; &#13;&#10;-3=baudrate&lt;&gt;0-10; &#13;&#10;-4=parity&lt;&gt;0-4; &#13;&#10;- 5=stopbits&lt;&gt;1-2; &#13;&#10;-6=ErrorWORDLEN; &#13;&#10;-10=Com allready in use; &#13;&#10;-11=Com allready in use of OS; &#13;&#10;-12=CPU has no COM of this No.;&#13;&#10;-13=OS Error;-14=NoInitialization; &#13;&#10;-15=WRONG INPUT; -16=receiving buffer too low, has to be bigger then &gt;= 128 Byte&apos;s; &#13;&#10;-17=INPUT was NIL; &#13;&#10;-19=no DATA in receiving buffer; &#13;&#10;-20=sending process couldn&apos;t be ended (disturbance., sendbuffer overflow, ...)" Name="SetTimingBufferRecv.ErrorCode"/>
		END_VAR;
				//! <Function Comment="-) interface type of serial interfaces&#13;&#10;     -) bit coded interface settings&#13;&#10;          -) bit0 ... character / message timeout check by OS (true / false)&#13;&#10;          -) bit1 ... Modbus RTU interface (HZS557)&#13;&#10;          -) bit2 ... RS485 only with echo (CSI02X)&#13;&#10;          -) bit3 ... M-Bus interface (HZS772)" Name="GetInterfaceType"/>
	FUNCTION VIRTUAL GLOBAL GetInterfaceType
		VAR_OUTPUT
			Retcode 	: DINT;			//! <Variable Comment="Contains the interface type.&#13;&#10;0..(default) the interface is the standard &#13;&#10;&lt;&gt;0..user defined" Name="GetInterfaceType.Retcode"/>
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL Command::NewInst
		VAR_INPUT
			pPara 	: ^CmdStruct;
			pResult 	: ^results;
		END_VAR
		VAR_OUTPUT
			ret_code 	: iprStates;
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

//}}LSL_DECLARATION


FUNCTION GLOBAL TAB _SerLib::@CT_
0$UINT,
2#0100000000000000$UINT, //TY__SERLIB
1$UINT, 34$UINT, (SIZEOF(::_SerLib))$UINT, 
2$UINT, 0$UINT, 0$UINT, 
TO_UDINT(4078275645), "_SerLib", //Class
TO_UDINT(0), 0, 0$UINT, 0$UINT, //Baseclass
//Servers:
(::_SerLib.Command.pMeth)$UINT, _CH_CMD$UINT, 2#0000000000000000$UINT, TO_UDINT(2978944206), "Command", 
(::_SerLib.Com.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(4061234284), "Com", 
//Clients:
END_FUNCTION


#define USER_CNT__SerLib 29

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT__SerLib] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION _SerLib::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
	END_VAR

	//Command Methods
	InitCmdTable (nCmd := nSTDCMD + USER_CNT__SerLib, pCmd := #vmt.CmdTable);
	vmt.CmdTable.NewInstr		:= #NewInst();
#pragma warning (disable : 74)
	vmt.UserFcts[0]		:= #StartUser();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[1]		:= #StopUser();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[2]		:= #SerSend();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[3]		:= #SerClose();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[4]		:= #SetOnline();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[5]		:= #RecvBlock();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[6]		:= #RecvChar();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[7]		:= #GetRecvState();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[8]		:= #GetSendState();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[9]		:= #GetError();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[10]		:= #IsInitialized();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[11]		:= #GetInfo();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[12]		:= #SetBufferRecv();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[13]		:= #ClearRecvBuffer();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[14]		:= #RtsOnOff();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[15]		:= #rdRts();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[16]		:= #rdCts();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[17]		:= #DtrOnOff();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[18]		:= #rdDtr();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[19]		:= #rdDCD();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[20]		:= #rdDSR();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[21]		:= #rdRI();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[22]		:= #SetRSMode();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[23]		:= #GetRSMode();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[24]		:= #RecvTimingChar();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[25]		:= #RecvTimingBlock();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[26]		:= #ClearTimingBuffer();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[27]		:= #SetTimingBufferRecv();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[28]		:= #GetInterfaceType();

#pragma warning (default : 74)
	Command.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, EXCLUSIVE);

	IF Command.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;

END_FUNCTION

//{{LSL_IMPLEMENTATION


//*********************Inserted from .\code\C_SerLib.st*********************



 



//----------------------------------------------------------------------------------------------
//----------------------------------------------------------------------------------------------

//*******************************************************************
//*   class  : _SerLib																							*
//*   Serial Modul. Library for all available OF functions					*
//*******************************************************************
//*	  created: RM 	: KW38/03																				*
//*******************************************************************
//*   tested :  		: KW38/03																				*
//*******************************************************************

//----------------------------------------------------------------------------------------------
//----------------------------------------------------------------------------------------------

//
// [#DEUTSCH]
// *********************************************************************************************
// ****************************     _SerLib::GetError      *************************************
// *********************************************************************************************
// ** liefert den aktuellen Error Status                                                     ***
// ** ---------------------------------------------------------------------------------------***
// ****																						 																					 ***
// **            !!!!    ERROR CODE TABELLE   !!!!											 									   ***
// **																						 																					   ***
// **   0 .. SERERROR_NONE																	 																 ***
// ** - 1 .. SERERROR_COMNUM     -> Com <> 1-4											 												 ***
// ** - 2 .. SERERROR_BAUDTABLE  -> Fehler Baud Tabelle  						 												 ***
// ** - 3 .. SERERROR_BAUDRATE   -> Baudrate <> 0-10										 										 ***
// ** - 4 .. SERERROR_PARITY     -> Parity <> 0-4											 											 ***
// ** - 5 .. SERERROR_STOPBIT    -> Stopbits <> 1-2											 										 ***
// ** - 6 .. SERERROR_WORDLEN		 -> unzulässige Wortlänge		 																 ***
// ** -10 .. SERERROR_INUSE      -> Com bereits in Verwendung								 								 ***
// ** -11 .. SERERROR_OSINUSE    -> Com wird bereits vom OS verwendet 						 					 ***
// ** -12 .. SERERROR_NOTAVAIL   -> CPU verfügt über die angegebene COM nicht				 				 ***
// ** -13 .. SERERROR_NOMEM      -> OS Error												 												 ***
// ** -14 .. SERERROR_NOHANDLE	 ->	Com nicht initialisiert		 															 ***
// ** -15 .. SERERROR_PARAMETER  -> einer der angegebenen Funktionen wurde einfalscher Pointer überg. (z.B:NIL)
// ** -16 .. SERERROR_RECVBUF    -> SetBuffer erhielt einen zukleinen Wert für Empf.buffergröße: muss >= 128 sein
// ** -17 .. SERERROR_SENDBUF    -> der Sendefunktion wurde NIL übergeben					 					 ***
// ** -18 .. SERERROR_TOOLONG    																			 											 ***
// ** -19 .. SERERROR_RECVERROR  -> RecvChar od. RecvBlock wurden aufgerufen, es befinden sich aber KEINE Daten im Empf.buffer
// ** -20 .. SERERROR_SENDERROR  -> Sendevorgang konnte nicht abgeschlossen werden. (Unterbr., Sendbuffer voll, ...)
// ** ---------------------------------------------------------------------------------------***
// ** erstellt   : RM :  KW 38/03															 															 ***
// *********************************************************************************************
//[<ErrorCode]0=OK; -1:Com<>1-4; -2=Fehler Baud Tabelle; -3=Baudrate<>0-10; -4=Parity<>0-4; - 5=Stoppbits<>1-2; -6=ErrorWORDLEN; -10=COM wird bereits verwendet; -11=Com wird bereits vom OS verwendet; -12=CPU hat keine COM mit der Nr.; -13=OS Error;-14=Kein Initialisierung; -15=falsche Übergabe; -16=Empfangsbuffer zu klein, muss >= 128 Byte's sein; -17=Übergabe war NIL; -19=keine Daten im Empfangsbuffer; -20=Sendeprozess konnte nicht abgeschlossen werden 
//
//[#ENGLISH]
// *********************************************************************************************
// ****************************     _SerLib::GetError      *************************************
// *********************************************************************************************
// **  returns actual error state																														 ***
// ** ---------------------------------------------------------------------------------------***
// ****																						 																					 ***
// **            !!!!    ERROR CODE TABLE   !!!!											 										 	 ***
// **																						 																						 ***
// **   0 .. SERERROR_NONE																	 																 ***
// ** - 1 .. SERERROR_COMNUM     -> Com <> 1-4											 												 ***
// ** - 2 .. SERERROR_BAUDTABLE  -> Error baudtable									 												 ***
// ** - 3 .. SERERROR_BAUDRATE   -> baudrate <> 0-10										 										 ***
// ** - 4 .. SERERROR_PARITY     -> parity <> 0-4											 											 ***
// ** - 5 .. SERERROR_STOPBIT    -> Stopbits <> 1-2											 										 ***
// ** - 6 .. SERERROR_WORDLEN		 -> wrong wordlength				 																 ***
// ** -10 .. SERERROR_INUSE      -> Com allready in use								 										 	 ***
// ** -11 .. SERERROR_OSINUSE    -> Com allready in use of OS 						 		 							 ***
// ** -12 .. SERERROR_NOTAVAIL   -> CPU has no COM of this NR 								 							 ***
// ** -13 .. SERERROR_NOMEM      -> OS Error												 												 ***
// ** -14 .. SERERROR_NOHANDLE	 -> Com not initialized				 															 ***
// ** -15 .. SERERROR_PARAMETER  -> WRONG INPUT												 											 ***
// ** -16 .. SERERROR_RECVBUF    -> Receiving Buffer too low, has to bigger then >= 128 Byte's**
// ** -17 .. SERERROR_SENDBUF    -> INPUT was NIL											 											 ***
// ** -18 .. SERERROR_TOOLONG    																			 											 ***
// ** -19 .. SERERROR_RECVERROR  -> No DATA in Receiving Buffer								 							 ***
// ** -20 .. SERERROR_SENDERROR  -> sending process couldn't be ended (disturbance., sendbuffer overflow, ...)
// *********************************************************************************************
//[<ErrorCode]0=OK; -1:Com<>1-4; -2=Error baudtable; -3=baudrate<>0-10; -4=parity<>0-4; - 5=stopbits<>1-2; -6=ErrorWORDLEN; -10=Com allready in use; -11=Com allready in use of OS; -12=CPU has no COM of this No.;-13=OS Error;-14=NoInitialization; -15=WRONG INPUT; -16=receiving buffer too low, has to be bigger then >= 128 Byte's; -17=INPUT was NIL; -19=no DATA in receiving buffer; -20=sending process couldn't be ended (disturbance., sendbuffer overflow, ...)
FUNCTION VIRTUAL GLOBAL _SerLib::GetError
VAR_OUTPUT
	ErrorCode		: DINT;
END_VAR

		ErrorCode := SERUSER_GetError(pHandle);

END_FUNCTION //GLOBAL _SerLib::GetError
//[#DEUTSCH]
// ***************************************************************
// ******************    _SerLib::IsInitialized   ****************
// ***************************************************************
// **     Prüft ob eine COM die COM initialisiert ist				  ****
// **     Rückgabewert : 0 = keine Initialisierung			  		****
// **	     			 				 1 = initialisiert					  				****
// ***************************************************************
//[<Initialization]Initialisiert 0=NEIN/1=JA
//
//[#ENGLISH]
// ***************************************************************
// ******************    _SerLib::IsInitialized   ****************
// ***************************************************************
// **     Checks, if COM is inialized 												 ***
// **     OUTPUT: 0 = NO Initialization						  					****
// **			     	  1 = initialized							  							****
// ***************************************************************
//[<Initialization]initialized 0=NO/1=YES
FUNCTION VIRTUAL GLOBAL _SerLib::IsInitialized
VAR_OUTPUT
	Initialization	: UDINT;		// 1 = initialized
END_VAR												// 0 = no initialization

		Initialization := SERUSER_IsInitialized(pHandle);

END_FUNCTION //GLOBAL _SerLib::IsInitialized
//[#DEUTSCH]
// ***************************************************************
// ******************     	_SerLib::GetInfo      ****************
// ***************************************************************
// ***  													  													****
// ***   Liefert Informationen zur Initialisierten COM        ****
// ***   INFO über: Initialisiert, ComPortNr, IOPort, IRQNum,.****
// ***** -------------------------------------------------- ******
// ***  --> Info     = Pointer auf Struktur LSLAPI_SERIALINFO ****
// ***  <-- ErrorCode= Error Code 				              			****
// ***************************************************************
//[<ErrorCode]0=OK; -1:Com<>1-4; -2=Fehler Baud Tabelle; -3=Baudrate<>0-10; -4=Parity<>0-4; - 5=Stoppbits<>1-2; -6=ErrorWORDLEN; -10=COM wird bereits verwendet; -11=Com wird bereits vom OS verwendet; -12=CPU hat keine COM mit der Nr.; -13=OS Error;-14=Kein Initialisierung; -15=falsche Übergabe; -16=Empfangsbuffer zu klein, muss >= 128 Byte's sein; -17=Übergabe war NIL; -19=keine Daten im Empfangsbuffer; -20=Sendeprozess konnte nicht abgeschlossen werden 
//[>Info]initialized : USINT; comportnum : USINT; IRQNum : USINT; IOPort : UINT; Baudrate : UINT; Ptr_RecvBuffer : pVoid; Ptr_SendBuffer : pVoid;
//
//[#ENGLISH]
// ***************************************************************
// ******************     	_SerLib::GetInfo      ****************
// ***************************************************************
// ***  													  													****
// ***   returns INFO of COM										  						****
// ***   INFO:initialized, ComPortNr, IOPort, IRQNum, .... 	  ****
// ***** -------------------------------------------------- ******
// ***  --> Info     = Pointer of Strukt LSLAPI_SERIALINFO    ****
// ***  <-- ErrorCode= Error Code 				              			****
// ***************************************************************
//[>Info]initialized : USINT; comportnum : USINT; IRQNum : USINT; IOPort : UINT; Baudrate : UINT; Ptr_RecvBuffer : pVoid; Ptr_SendBuffer : pVoid;
//[<ErrorCode]0=OK; -1:Com<>1-4; -2=Error baudtable; -3=baudrate<>0-10; -4=parity<>0-4; - 5=stopbits<>1-2; -6=ErrorWORDLEN; -10=Com allready in use; -11=Com allready in use of OS; -12=CPU has no COM of this No.;-13=OS Error;-14=NoInitialization; -15=WRONG INPUT; -16=receiving buffer too low, has to be bigger then >= 128 Byte's; -17=INPUT was NIL; -19=no DATA in receiving buffer; -20=sending process couldn't be ended (disturbance., sendbuffer overflow, ...)
FUNCTION VIRTUAL GLOBAL _SerLib::GetInfo
VAR_INPUT
	Info		: ^LSLAPI_SERIALINFO;
END_VAR
VAR_OUTPUT
	ErrorCode	: DINT;
END_VAR
//FUNCTION GLOBAL _SerLib::GetInf           //+> LSLAPI_SERIALINFO     :STRUCT
//VAR_INPUT                                 //|	   initialized : USINT;
//	Info		: ^LSLAPI_SERIALINFO;	//----------+	   IRQNum      : UINT;         
//END_VAR                                   //   	 IOPort      : UINT;
//VAR_OUTPUT                                //     Baudrate    : UINT;
//	ErrorCode: DINT;                        //  Ptr_RecvBuffer : pVoid;
//END_VAR                                   //  Ptr_SendBuffer : pVoid;

	ErrorCode := SERUSER_GetInfo(pHandle, Info);

END_FUNCTION //GLOBAL _SerLib::GetInfo
//[#DEUTSCH]
// ***************************************************************************
// ***************     	_SerLib::SetBufferRecv     **************************
// ***************************************************************************
// ***																    ******
// ** Funktion definiert einen neuen Empfangsbuffer für eine definierte Größe.        ******
// **  !!!!   Minimumgroesse 128 Byte    !!!! 						    ******
// ** Wird kein Empfangsbuffer definiert, wird der Defaultbuffer  		******
// **  mit der Größe von 1K (1024 Byte), verwendet.						******
// ***************************************************************************
//[>RecvBuffer]Pointer des Empfangsbuffers 
//[>BufferLength]Größe des Buffers (min. 128 byte)
//[<ErrorCode]0=OK; -1:Com<>1-4; -2=Fehler Baud Tabelle; -3=Baudrate<>0-10; -4=Parity<>0-4; - 5=Stoppbits<>1-2; -6=ErrorWORDLEN; -10=COM wird bereits verwendet; -11=Com wird bereits vom OS verwendet; -12=CPU hat keine COM mit der Nr.; -13=OS Error;-14=Kein Initialisierung; -15=falsche Übergabe; -16=Empfangsbuffer zu klein, muss >= 128 Byte's sein; -17=Übergabe war NIL; -19=keine Daten im Empfangsbuffer; -20=Sendeprozess konnte nicht abgeschlossen werden 
//
//[#ENGLISH]
// ***************************************************************************
// ***************     	_SerLib::SetBufferRecv     **************************
// ***************************************************************************
// ***																    															******
// * function specifies a new receive buffer or a recommended size, in bytes *
// *  of the driver's internal receive buffer																 *
// **  !!!!   minimumsize 128 Byte    !!!! 															******
// ** If no receivingbuffer is initialized, a DEFAULTbuffer (1024 Byte) ******
// ** will be used																											******
// ***************************************************************************
//[>RecvBuffer]Pointer of Receiving Buffer
//[>BufferLength]size of buffer (min. 128 byte)
//[<ErrorCode]0=OK; -1:Com<>1-4; -2=Error baudtable; -3=baudrate<>0-10; -4=parity<>0-4; - 5=stopbits<>1-2; -6=ErrorWORDLEN; -10=Com allready in use; -11=Com allready in use of OS; -12=CPU has no COM of this No.;-13=OS Error;-14=NoInitialization; -15=WRONG INPUT; -16=receiving buffer too low, has to be bigger then >= 128 Byte's; -17=INPUT was NIL; -19=no DATA in receiving buffer; -20=sending process couldn't be ended (disturbance., sendbuffer overflow, ...)
FUNCTION VIRTUAL GLOBAL _SerLib::SetBufferRecv
VAR_INPUT
	RecvBuffer	: pVoid;	// pointer on RecBuffer
	BufferLength: UDINT;	// buffer size
END_VAR
VAR_OUTPUT
	ErrorCode		: DINT;		// Errorcode (look Error Code Table of GetError)
END_VAR

	ErrorCode := SERUSER_SetBufferRecv(pHandle, RecvBuffer, BufferLength);

END_FUNCTION //GLOBAL _SerLib::SetBufferRecv
//[#DEUTSCH]
// ***************************************************************************
// **************** 		 _SerLib::SerSend       			***********************
// ***************************************************************************
// ***																    															******
// *** Sendet Daten über die initialisierte COM    											******
// *** Über WrLen kann die Anzahl der in den Sendebuffer kopierten Bytes******
// *** rückgelsen werden.					 																			******
// *** Wird für WrLen NIL übergeben, so ist diese Funktionalität deaktivert***
// ***************************************************************************
//
//[>Buffer]Pointer auf Sendebuffer
//[>bufferlength]Anzahl der zusendenden Bytes
//[>wrlen]Anzahl der gesendeten Bytes
//[<ErrorCode]0=OK; -1:Com<>1-4; -2=Fehler Baud Tabelle; -3=Baudrate<>0-10; -4=Parity<>0-4; - 5=Stoppbits<>1-2; -6=ErrorWORDLEN; -10=COM wird bereits verwendet; -11=Com wird bereits vom OS verwendet; -12=CPU hat keine COM mit der Nr.; -13=OS Error;-14=Kein Initialisierung; -15=falsche Übergabe; -16=Empfangsbuffer zu klein, muss >= 128 Byte's sein; -17=Übergabe war NIL; -19=keine Daten im Empfangsbuffer; -20=Sendeprozess konnte nicht abgeschlossen werden 
//[#ENGLISH]
// ***************************************************************************
// **************** 		 _SerLib::SerSend       			***********************
// ***************************************************************************
// ***																    															******
// *** Sends DATA over the initialized COM				   										******
// *** If there is an Error, wrlen returns how many Bytes were sended   ******
// ***************************************************************************
//[>bufferlength]The length of the data buffer to be sent.
//[>wrlen]number of sent bytes
//[>Buffer]Pointer to a buffer containing the data bo be sent.
//[<ErrorCode]0=OK; -1:Com<>1-4; -2=Error baudtable; -3=baudrate<>0-10; -4=parity<>0-4; - 5=stopbits<>1-2; -6=ErrorWORDLEN; -10=Com allready in use; -11=Com allready in use of OS; -12=CPU has no COM of this No.;-13=OS Error;-14=NoInitialization; -15=WRONG INPUT; -16=receiving buffer too low, has to be bigger then >= 128 Byte's; -17=INPUT was NIL; -19=no DATA in receiving buffer; -20=sending process couldn't be ended (disturbance., sendbuffer overflow, ...)
FUNCTION VIRTUAL GLOBAL _SerLib::SerSend
VAR_INPUT
	Buffer			:pVoid;
	bufferlength: UDINT;
	wrlen				:^UDINT;		// how many Bytes were sent
END_VAR										
VAR_OUTPUT
	ErrorCode	: DINT;				// Errorcode (ErrorTable "GerError()" )	
END_VAR

	   
	   		ErrorCode := SERUSER_Send(pHandle, Buffer, bufferlength, wrlen);
	   		//  ret0 = -20  -> SENDERROR  ( in use, break, .. )
				//         -17  -> SENDBUF    ( wrong adress )

END_FUNCTION //GLOBAL _SerLib::SerSend
//[#DEUTSCH]
// ***************************************************************************
// **************** 		   _SerLib::RecvChar         ***********************
// ***************************************************************************
// ****																																	******
// ***    liest "EIN" Zeichen des Empfangsbuffers 											******
// ***     und legt es in den übergebenen Buffer												******
// ***************************************************************************
//[>Buffer]Pointer des Empfangsbuffers
//[<ErrorCode]0=OK; -1:Com<>1-4; -2=Fehler Baud Tabelle; -3=Baudrate<>0-10; -4=Parity<>0-4; - 5=Stoppbits<>1-2; -6=ErrorWORDLEN; -10=COM wird bereits verwendet; -11=Com wird bereits vom OS verwendet; -12=CPU hat keine COM mit der Nr.; -13=OS Error;-14=Kein Initialisierung; -15=falsche Übergabe; -16=Empfangsbuffer zu klein, muss >= 128 Byte's sein; -17=Übergabe war NIL; -19=keine Daten im Empfangsbuffer; -20=Sendeprozess konnte nicht abgeschlossen werden 
//
//[#ENGLISH]
// ***************************************************************************
// **************** 		   _SerLib::RecvChar         ***********************
// ***************************************************************************
// ****																																	******
// ***    the function reads one byte from the serial drivers receive   ******
// ****    buffer																												******
// ***************************************************************************
//[>Buffer]Pointer to receiving buffer
//[<ErrorCode]0=OK; -1:Com<>1-4; -2=Error baudtable; -3=baudrate<>0-10; -4=parity<>0-4; - 5=stopbits<>1-2; -6=ErrorWORDLEN; -10=Com allready in use; -11=Com allready in use of OS; -12=CPU has no COM of this No.;-13=OS Error;-14=NoInitialization; -15=WRONG INPUT; -16=receiving buffer too low, has to be bigger then >= 128 Byte's; -17=INPUT was NIL; -19=no DATA in receiving buffer; -20=sending process couldn't be ended (disturbance., sendbuffer overflow, ...)
FUNCTION VIRTUAL GLOBAL _SerLib::RecvChar
VAR_INPUT
	Buffer		: pVoid;	// Buffer Pointer
END_VAR
VAR_OUTPUT
	ErrorCode		: DINT;		// returns an ErrorCode ("look GetError()")
END_VAR

		ErrorCode := SERUSER_RecvChar( pHandle, Buffer );

END_FUNCTION //GLOBAL _SerLib::RecvChar
//[#DEUTSCH]
// ***************************************************************************
// **************** 		 			_SerLib::RecvBlock        *********************
// ***************************************************************************
// ****																																	******
// ****   liest einen ganzen Block des Empfangsbuffers 									******
// ****   und legt es in den übergebenen Buffer													******
// ***************************************************************************
//[<ErrorCode]0=OK; -1:Com<>1-4; -2=Fehler Baud Tabelle; -3=Baudrate<>0-10; -4=Parity<>0-4; - 5=Stoppbits<>1-2; -6=ErrorWORDLEN; -10=COM wird bereits verwendet; -11=Com wird bereits vom OS verwendet; -12=CPU hat keine COM mit der Nr.; -13=OS Error;-14=Kein Initialisierung; -15=falsche Übergabe; -16=Empfangsbuffer zu klein, muss >= 128 Byte's sein; -17=Übergabe war NIL; -19=keine Daten im Empfangsbuffer; -20=Sendeprozess konnte nicht abgeschlossen werden 
//[>Buffer]Zeiger auf Empfangsbuffer
//[>rdlength]Anzahl der zu lesenden Bytes
//[>rdlen]Anzahl der richtig gelesenen Bytes
//
//[#ENGLISH]
// ***************************************************************************
// **************** 		 			_SerLib::RecvBlock        *********************
// ***************************************************************************
// ****																																	******
// ****	  reads a area of character of the receiving buffer							******
// ***************************************************************************
//[>Buffer]Pointer to receivbuffer
//[>rdlength]Bytes you want to read of the receiving buffer
//[>rdlen]number of correct readed Bytes
//[<ErrorCode]0=OK; -1:Com<>1-4; -2=Error baudtable; -3=baudrate<>0-10; -4=parity<>0-4; - 5=stopbits<>1-2; -6=ErrorWORDLEN; -10=Com allready in use; -11=Com allready in use of OS; -12=CPU has no COM of this No.;-13=OS Error;-14=NoInitialization; -15=WRONG INPUT; -16=receiving buffer too low, has to be bigger then >= 128 Byte's; -17=INPUT was NIL; -19=no DATA in receiving buffer; -20=sending process couldn't be ended (disturbance., sendbuffer overflow, ...)
FUNCTION VIRTUAL GLOBAL _SerLib::RecvBlock			
VAR_INPUT
	Buffer		:pVoid;			// pointer of buffer
	rdlength	: UDINT;		// No. of bytes to read
	rdlen			:^UDINT;		// number of readed bytes 
END_VAR
VAR_OUTPUT
	ErrorCode	: DINT;			
END_VAR

			ErrorCode := SERUSER_RecvBlock( pHandle, Buffer, rdlength, rdlen);

END_FUNCTION //GLOBAL _SerLib::RecvBlock
//[#DEUTSCH]
// ***************************************************************************
// **************** 		     _SerLib::GetSendState           *****************
// ***************************************************************************
// ***																	  																 ***
// ***     liefert Anzahl der im Sendebuffer befindlichen Bytes            ***
// ***  	 Ist der Rückgabewert < 0, entspricht dies einem ErrorCode       ***
// ***     (für negative Werte muss der Wert auf DINT gecasted werden)     ***
// ***************************************************************************
//
//[<to_send]If the function succeeds, the return value is the number of characters in the send buffer, otherwise a negative error code value is returned.
//
//[#ENGLISH]
// ***************************************************************************
// **************** 		     _SerLib::GetSendState           *****************
// ***************************************************************************
// ***																																	   ***
// ***   returns, how many Bytes are in the "senbuffer"          			     ***
// ***   if return value < 0 --> return value = Error Code                 ***
// ***   (cast the return value to a DINT to get also negative values)     ***
// ***************************************************************************
//
//[<to_send]How many Bytes are too send
FUNCTION VIRTUAL GLOBAL _SerLib::GetSendState
VAR_OUTPUT
	to_send		: UDINT;	// How many Bytes are too send
END_VAR
	
		to_send := SERUSER_GetSendStatus( pHandle );

END_FUNCTION //GLOBAL _SerLib::GetSendState
//[#DEUTSCH]
// ***************************************************************************
// **************** 		 		 _SerLib::GetRecvState           *****************
// ***************************************************************************
// ***																	   																 ***
// ***     liefert Anzahl der im Empfangsbuffer befindlichen Bytes         ***
// ***  	 Ist der Rückgabewert < 0, entspricht dies einem ErrorCode       ***
// ***     (für negative Werte muss der Wert auf DINT gecasted werden)     ***
// ***************************************************************************
//
//[<length]Anzahl der Bytes, die neu empfangen wurden
//
//[#ENGLISH]
// ***************************************************************************
// **************** 		 		 _SerLib::GetRecvState           *****************
// ***************************************************************************
// ***	  															   																 ***
// ***    returns the number of characters in the receive buffer           ***
// ***    if return value < 0 --> return value = Error Code                ***
// ***    (cast the return value to a DINT to get also negative values)    ***
// ***************************************************************************
//
//[<length]number of bytes in receiving buffer
FUNCTION VIRTUAL GLOBAL _SerLib::GetRecvState
VAR_OUTPUT
	length		: UDINT;	// length of received Data
END_VAR
	
		length :=  SERUSER_GetRecvStatus(pHandle);

END_FUNCTION //GLOBAL _SerLib::GetRecvState
//[#DEUTSCH]
// ***************************************************************************
// **************** 		 		_SerLib::ClearRecvBuffer        	***************
// ***************************************************************************
// ***																	   																 ***
// ***      löscht nicht die Zeichen des Empfangsbuffers,                  ***
// ***       sondern setzt den Lesezeiger gleich mit dem Schreibzeiger     ***
// ***************************************************************************
//
//[<ErrorCode]0=OK; -1:Com<>1-4; -2=Fehler Baud Tabelle; -3=Baudrate<>0-10; -4=Parity<>0-4; - 5=Stoppbits<>1-2; -6=ErrorWORDLEN; -10=COM wird bereits verwendet; -11=Com wird bereits vom OS verwendet; -12=CPU hat keine COM mit der Nr.; -13=OS Error;-14=Kein Initialisierung; -15=falsche Übergabe; -16=Empfangsbuffer zu klein, muss >= 128 Byte's sein; -17=Übergabe war NIL; -19=keine Daten im Empfangsbuffer; -20=Sendeprozess konnte nicht abgeschlossen werden 
//
//[#ENGLISH]
// ***************************************************************************
// **************** 		 		_SerLib::ClearRecvBuffer        	 ***************
// ***************************************************************************
// ***																	   																 ***
// ***      clears the receiving buffer									   								 ***
// ***      ( puts the reading pointer to the startposition)				   		 ***
// ***************************************************************************
//
//[<ErrorCode]0=OK; -1:Com<>1-4; -2=Error baudtable; -3=baudrate<>0-10; -4=parity<>0-4; - 5=stopbits<>1-2; -6=ErrorWORDLEN; -10=Com allready in use; -11=Com allready in use of OS; -12=CPU has no COM of this No.;-13=OS Error;-14=NoInitialization; -15=WRONG INPUT; -16=receiving buffer too low, has to be bigger then >= 128 Byte's; -17=INPUT was NIL; -19=no DATA in receiving buffer; -20=sending process couldn't be ended (disturbance., sendbuffer overflow, ...)
FUNCTION VIRTUAL GLOBAL _SerLib::ClearRecvBuffer
VAR_OUTPUT
	ErrorCode		: DINT;  	// Error Code
END_VAR

		ErrorCode := SERUSER_ClearRecvBuffer(pHandle);

END_FUNCTION //GLOBAL _SerLib::ClearRecvBuffer
//[#DEUTSCH]
// ***************************************************************************
// **************** 		 _SerLib :: GetRecvPointer            ****************
// ***************************************************************************
// ***																	   																 ***
// ***        Ermittelt die Empfangs Buffer Adresse eines Handles		   		 ***
// ***************************************************************************
//
//[<Buffer_ptr]Pointer des Empfangsbuffers
//
//[#ENGLISH]
// ***************************************************************************
// **************** 		 _SerLib :: GetRecvPointer        	  ****************
// ***************************************************************************
// ***																	   																 ***
// ***		  returns the pointer of the receiving buffer				   					 ***
// ***************************************************************************
//
//[<Buffer_ptr]Pointer of Receivingbuffer with the input handle
FUNCTION _SerLib::GetRecvPointer
VAR_OUTPUT
	Buffer_ptr		: pVoid;		// Pointer of Receiving Buffer
END_VAR

	//IF pHandle > 0 THEN
		Buffer_ptr := SERUSER_GetRecvPointer(pHandle);
	//END_IF;


END_FUNCTION //GLOBAL _SerLib::GetRecvPointer
//[#DEUTSCH]
// ************************************************
// *************  _SerLib::Serclose   *************
// ************************************************
// ***     																			***
// *** Sender ausschalten, Sendepuffer löschen  ***
// *** und aktuell anstehenden Sendeauftrag     ***
// *** abbrechen. 															***
// ***     																			***
// *** --> Kein Uebergabeparameter    					***
// *** <-- Kein Rueckgabeparameter              ***
// ***     																			***
// ************************************************
//
//[#ENGLISH]
// ************************************************
// *************  _SerLib::Serclose   *************
// ************************************************
// ***     																			***
// *** This Function clears an initialized COM  ***
// *** receiving buffer also will be cleared    ***
// ***     																			***
// *** --> Not in use  													***
// *** <-- Not in use                           ***
// ***     																			***
// ************************************************
FUNCTION VIRTUAL GLOBAL _SerLib::Serclose

	// if it is initialized, it must be closed
	IF SERUSER_IsInitialized( pHandle ) = 1 THEN
		SERUSER_Close( pHandle );
		pHandle := NIL;	
		// Now Receiving Buffer is also cleared
	END_IF;

END_FUNCTION //GLOBAL _SerLib::Serclose

//[#DEUTSCH]
// ***************************************************************************
// **************** 		 		_SerLib::SerInit                 ****************
// ***************************************************************************
// ** 																																			**
// **   Funktion schließt Schnittstelle falls initialisiert  								**
// **   und initialisiert sie mit den Übergabeparametern, NEU.		 					**
// **   Über den Rückgabeparmeter kann entschieden werden ob INIT erfolgreich*
// **   ret0 <= 0 --> NICHT ERFOLGREICH																			**
// ***************************************************************************
//[>Com_in]COM 1-4
//[>Baud_in]0..SERUSERBAUD_300, 1..600, 2..1200, 3..2400, 4..4800, 5..9600, 6..14400, 7..19200, 8..38400, 9..56000, 10..115200
//[>wordl_in]"wordlength"  5, 6, 7 oder 8
//[>Parity_in]0..SERUSERPARITY_NONE / 1..SERUSERPARITY_ODD / 2..SERUSERPARITY_EVEN / 3..SERUSERPARITY_MARK / 4..SERUSERPARITY_SPACE
//[>StopB_in]1=ein Stop Bit, 2=2 Stop Bits für word länge 6,7 oder 8 Bits oder 1.5 stop Bits für word Länge von 5 Bits. 
//[<ErrorCode]0=OK; -1:Com<>1-4; -2=Fehler Baud Tabelle; -3=Baudrate<>0-10; -4=Parity<>0-4; - 5=Stoppbits<>1-2; -6=ErrorWORDLEN; -10=COM wird bereits verwendet; -11=Com wird bereits vom OS verwendet; -12=CPU hat keine COM mit der Nr.; -13=OS Error;-14=Kein Initialisierung; -15=falsche Übergabe; -16=Empfangsbuffer zu klein, muss >= 128 Byte's sein; -17=Übergabe war NIL; -19=keine Daten im Empfangsbuffer; -20=Sendeprozess konnte nicht abgeschlossen werden 
//
//[#ENGLISH]
// ***************************************************************************
// **************** 		 		_SerLib::SerInit                 ****************
// ***************************************************************************
// ** 																																			**
// **   Closes an initialized COM if initialized and initializes a new one  **
// ** --------------------------------------------------------------------- **
// ***************************************************************************
//[>Com_in]COM 1-4
//[>Baud_in]0..SERUSERBAUD_300, 1..600, 2..1200, 3..2400, 4..4800, 5..9600, 6..14400, 7..19200, 8..38400, 9..56000, 10..115200
//[>wordl_in]"wordlength"  5, 6, 7 or 8
//[>Parity_in]0..SERUSERPARITY_NONE / 1..SERUSERPARITY_ODD / 2..SERUSERPARITY_EVEN / 3..SERUSERPARITY_MARK(HIGH Parity) / 4..SERUSERPARITY_SPACE(LOW Parity)
//[>StopB_in]1=one stop bit, 2=2 stop bits for words of length 6,7 or 8 bits or 1.5 stop bits for word lengths of 5 bits. 
//[<ErrorCode]0=OK; -1:Com<>1-4; -2=Error baudtable; -3=baudrate<>0-10; -4=parity<>0-4; - 5=stopbits<>1-2; -6=ErrorWORDLEN; -10=Com allready in use; -11=Com allready in use of OS; -12=CPU has no COM of this No.;-13=OS Error;-14=NoInitialization; -15=WRONG INPUT; -16=receiving buffer too low, has to be bigger then >= 128 Byte's; -17=INPUT was NIL; -19=no DATA in receiving buffer; -20=sending process couldn't be ended (disturbance., sendbuffer overflow, ...)
FUNCTION _SerLib::SerInit
VAR_INPUT
	Com_in		: DINT;			// number of new COM to initialize
	Baud_in		: DINT;			// Baudrate for new init
	wordl_in	: DINT;			// BitFormat for new initialization
	Parity_in	: DINT;			// ParityBits for new init
	StopB_in	: DINT;			// Stopbits
END_VAR
VAR_OUTPUT
	ErrorCode	: DINT;			// ErrorCode
END_VAR

	// if it is initialized, it must be closed
	IF SERUSER_IsInitialized(pHandle) = 1 THEN
		SERUSER_Close(pHandle);	// at first it must be close
	END_IF;
	
	// now we are able to initialize the new COM
	pHandle   := SERUSER_Init(Com_in$UINT, Baud_in$UINT, Parity_in$UINT, to_UINT(StopB_in), wordl_in$UINT);
	
	ErrorCode := SERUSER_GetError( pHandle );

	IF pHandle <> 0 THEN
		ErrorCode := SERUSER_EnableFifo( pHandle, 1 );
	END_IF;

END_FUNCTION //GLOBAL _SerLib::SerInit
//[#DEUTSCH]
// **********************************************************************************
// *******************           setzt/loescht RTS            ***********************
// **********************************************************************************
// *                                                                                *
// *  Funktion setzt oder loescht RTS an der Seriellen Schnittstelle                *
// *  RTS = PIN 7 an der 9 poligen D-Sub                                            *
// ** ----------------------------------------------------------------------------- *
// *  -> state=0: low                                                               *
// *     state=1: high (standard)                                                   *
// *                                                                                *
// ** ----------------------------------------------------------------------------- *
// ** erstellt   : RM :  KW 38/03                                                   *
// **********************************************************************************
//[>state]0=low, 1=high (standard)
//[<ErrorCode]0=OK; -1:Com<>1-4; -2=Fehler Baud Tabelle; -3=Baudrate<>0-10; -4=Parity<>0-4; - 5=Stoppbits<>1-2; -6=ErrorWORDLEN; -10=COM wird bereits verwendet; -11=Com wird bereits vom OS verwendet; -12=CPU hat keine COM mit der Nr.; -13=OS Error;-14=Kein Initialisierung; -15=falsche Übergabe; -16=Empfangsbuffer zu klein, muss >= 128 Byte's sein; -17=Übergabe war NIL; -19=keine Daten im Empfangsbuffer; -20=Sendeprozess konnte nicht abgeschlossen werden 
//[#ENGLISH]
// **********************************************************************************
// *******************            sets/clr's   RTS            ***********************
// **********************************************************************************
// *                                                                                *
// *  Functin set's or clear's RTS on the SERIAL interfaces                         *
// *  RTS = PIN 7  (9pol. D-SUB)                                                    *
// ** ----------------------------------------------------------------------------- *
// *  -> state=0: LOW                                                               *
// *     state=1: HIGH (normally)                                                   *
// *                                                                                *
// ** ----------------------------------------------------------------------------- *
// ** created    : RM :  KW 38/03                                                   *
// **********************************************************************************
//[>state]0=low, 1=high (normally)
//[<ErrorCode]0=OK; -1:Com<>1-4; -2=Error baudtable; -3=baudrate<>0-10; -4=parity<>0-4; - 5=stopbits<>1-2; -6=ErrorWORDLEN; -10=Com allready in use; -11=Com allready in use of OS; -12=CPU has no COM of this No.;-13=OS Error;-14=NoInitialization; -15=WRONG INPUT; -16=receiving buffer too low, has to be bigger then >= 128 Byte's; -17=INPUT was NIL; -19=no DATA in receiving buffer; -20=sending process couldn't be ended (disturbance., sendbuffer overflow, ...)
FUNCTION VIRTUAL GLOBAL _SerLib::RtsOnOff
VAR_INPUT
	state		: BOOL;
END_VAR
VAR_OUTPUT
    ErrorCode	: DINT;
END_VAR

	IF pHandle <> 0 THEN
		ErrorCode := SERUSER_SetModemControl(pHandle, NOT(State), SERUSER_RTS); //(handle)
	ELSE
	    ErrorCode := -14; // not initialized
	END_IF;

END_FUNCTION //GLOBAL _SerLib::RtsOnOff
//[#DEUTSCH]
// **********************************************************************************
// *******************               liest RTS                ***********************
// **********************************************************************************
// *                                                                                *
// *  Funktion liest RTS an der Seriellen Schnittstelle                             *
// *  RTS = PIN 7 an der 9 poligen D-Sub                                            *
// ** ----------------------------------------------------------------------------- *
// *  <- state=0: LOW                                                               *
// *     state=1: HIGH (standard)                                                   *
// *                                                                                *
// ** ----------------------------------------------------------------------------- *
// ** erstellt   : RM :  KW 38/03                                                   *
// **********************************************************************************
//[<state]0=LOW, 1=HIGH standard
//[#ENGLISH]
// **********************************************************************************
// *******************               read's   RTS             ***********************
// **********************************************************************************
// *                                                                                *
// *  Functin read's RTS on the Serial interfaces                                   *
// *  RTS = PIN 7  (9pol. D-SUB)                                                    *
// ** ----------------------------------------------------------------------------- *
// *  <- state=0: LOW                                                               *
// *     state=1: HIGH (normally)                                                   *
// *                                                                                *
// ** ----------------------------------------------------------------------------- *
// ** created    : RM :  KW 38/03                                                   *
// **********************************************************************************
//[<state]0=LOW, 1=HIGH=normally
FUNCTION VIRTUAL GLOBAL _SerLib::rdRts
VAR_OUTPUT
	state		: BOOL;
END_VAR

	IF pHandle <> 0 THEN
		SERUSER_GetModemControl(pHandle,#state$USINT);
		// wenn bit gesetz state=1 else state=0
		state := (state AND SERUSER_RTS) <> 0;
	END_IF;

END_FUNCTION //GLOBAL _SerLib::rdRts
//[#DEUTSCH]
// **********************************************************************************
// *******************               liest CTS                ***********************
// **********************************************************************************
// *                                                                                *
// *  Funktion liest CTS an der Seriellen Schnittstelle                             *
// *  CTS = PIN 8  (9pol. D-SUB)                                                    *
// ** ----------------------------------------------------------------------------- *
// *  <- state=0: LOW                                                               *
// *     state=1: HIGH                                                              *
// *                                                                                *
// ** ----------------------------------------------------------------------------- *
// ** erstellt   : RM :  KW 38/03                                                   *
// **********************************************************************************
//[<state]0=LOW, 1=HIGH
//[#ENGLISH]
// **********************************************************************************
// *******************               read's   CTS             ***********************
// **********************************************************************************
// *                                                                                *
// *  Functin read's CTS on the Serial interfaces                                   *
// *  CTS = PIN 8  (9pol. D-SUB)                                                    *
// ** ----------------------------------------------------------------------------- *
// *  <- state=0: LOW                                                               *
// *     state=1: HIGH                                                              *
// *                                                                                *
// ** ----------------------------------------------------------------------------- *
// ** created    : RM :  KW 38/03                                                   *
// **********************************************************************************
//
//[<state]0=LOW, 1=HIGH
FUNCTION VIRTUAL GLOBAL _SerLib::rdCts
VAR_OUTPUT
	state		: BOOL;
END_VAR

	State := 0;
	IF pHandle <> 0 THEN
		SERUSER_GetModemStatus(pHandle,#state$USINT);
		state := (state AND 16#10) <> 0;
	END_IF;

END_FUNCTION //GLOBAL _SerLib::rdCts
//[#DEUTSCH]
// ***************************************************************************
// **************** 		 	_SerLib::StartUser                 *****************
// ***************************************************************************
// ** 																																			**
// **   Funktion schließt Schnittstelle falls initialisiert  								**
// **   und initialisiert sie mit den Übergabeparametern, NEU.		 					**
// ***************************************************************************
//[>Baud]0..SERUSERBAUD_300, 1..600, 2..1200, 3..2400, 4..4800, 5..9600, 6..14400, 7..19200, 8..38400, 9..56000, 10..115200
//[>wordl]"Wortlänge"  5, 6, 7 oder 8 Bit
//[>Parity]0..SERUSERPARITY_NONE / 1..SERUSERPARITY_ODD / 2..SERUSERPARITY_EVEN / 3..SERUSERPARITY_MARK / 4..SERUSERPARITY_SPACE
//[>StopB]1=ein Stop Bit, 2=2 Stop Bits für Wortlänge von 6,7 oder 8 Bits oder 1.5 stop Bits für eine Wortlänge von 5 Bits.
//[>FifoOnOff]0=FIFO disable, FIFO enable: 1,4,8,14 = Triggerlevel
//[<ErrorCode]0=OK; -1:invalid Com; -2=Fehler Baud Tabelle; -3=Baudrate<>0-10; -4=Parity<>0-4; - 5=Stoppbits<>1-2; -6=ErrorWORDLEN; -10=COM wird bereits verwendet; -11=Com wird bereits vom OS verwendet; -12=CPU hat keine COM mit der Nr.; -13=OS Error;-14=Kein Initialisierung; -15=falsche Übergabe; -16=Empfangsbuffer zu klein, muss >= 128 Byte's sein; -17=Übergabe war NIL; -19=keine Daten im Empfangsbuffer; -20=Sendeprozess konnte nicht abgeschlossen werden; -50= FIFO doesn´t exist
//
//[#ENGLISH]
// ***************************************************************************
// **************** 		 _SerLib::StartUser                  	****************
// ***************************************************************************
// ** 																																		  **
// **   Closes an initialized COM if initialized and initializes a new one  **
// ***************************************************************************
//[>Baud]0..SERUSERBAUD_300, 1..600, 2..1200, 3..2400, 4..4800, 5..9600, 6..14400, 7..19200, 8..38400, 9..56000, 10..115200
//[>wordl]"wordlength"  5, 6, 7 or 8 bit
//[>Parity]0..SERUSERPARITY_NONE / 1..SERUSERPARITY_ODD / 2..SERUSERPARITY_EVEN / 3..SERUSERPARITY_MARK(HIGH Parity) / 4..SERUSERPARITY_SPACE(LOW Parity)
//[>StopB]1=one stop bit, 2=2 stop bits for words of length 6,7 or 8 bits or 1.5 stop bits for word lengths of 5 bits.
//[>FifoOnOff]0=FIFO disable, FIFO enable: 1,4,8,14 = Triggerlevel
//[<ErrorCode]0=OK; -1:invalid Com; -2=Error baudtable; -3=baudrate<>0-10; -4=parity<>0-4; - 5=stopbits<>1-2; -6=ErrorWORDLEN; -10=Com allready in use; -11=Com allready in use of OS; -12=CPU has no COM of this No.;-13=OS Error;-14=NoInitialization; -15=WRONG INPUT; -16=receiving buffer too low, has to be bigger then >= 128 Byte's; -17=INPUT was NIL; -19=no DATA in receiving buffer; -20=sending process couldn't be ended (disturbance., sendbuffer overflow, ...); -50= FIFO doesn´t exist
FUNCTION VIRTUAL GLOBAL _SerLib::StartUser
VAR_INPUT
	Baud      : DINT;		// Baudrate for new init
	wordl     : DINT;		// BitFormat for new initialization
	Parity    : DINT;		// ParityBits for new init
	StopB     : DINT;		// Stopbits
	FifoOnOff : DINT;       // 0=FIFO disable, FIFO enable: 1,4,8,14 = Triggerlevel
END_VAR
VAR_OUTPUT
	ErrorCode	: DINT;
END_VAR

	// if it is initialized, it must be closed
	IF	SERUSER_IsInitialized(pHandle) = 1 THEN
		SERUSER_Close(pHandle);	// at first it must be close
	END_IF;

	// now we are able to initialize the new COM
	pHandle   := SERUSER_Init(COM$UINT,Baud$UINT, Parity$UINT, StopB$UINT, wordl$UINT);
	
	ErrorCode := SERUSER_GetError( pHandle );
	
	IF pHandle <> 0 THEN
      
    //no FIFO on the COM 7 - 10
    IF(Com < 7 | Com > 10)THEN    

      //the function returns -1 if the FIFO doesn´t exist
      ErrorCode := SERUSER_EnableFifo(pHandle, FifoOnOff$UDINT);
      IF(ErrorCode = -1)THEN
        ErrorCode := -50;
      END_IF;
      
    ELSE
      //if the user want to activate the fifo but it doesn´t exist
      IF(FifoOnOff <> 0)THEN
        ErrorCode := -50; //no FIFO
      END_IF;
      
    END_IF;
    

	END_IF;

END_FUNCTION //GLOBAL _SerLib::StartUser
//[#DEUTSCH]
// ***************************************************************************
// **************** 		 	_SerLib::SetOnline                 *****************
// ***************************************************************************
// ** 																																			**
// **  Ein-/Ausschalten der Onlinekommunikation										 					**
// ***************************************************************************
//[>state]0:Lasal Onlinekommunikation abschalten; 1=Lasal Onlinekommunikation aktivieren
//[<ErrorCode]0=OK; -1:Com<>1-4; -2=Fehler Baud Tabelle; -3=Baudrate<>0-10; -4=Parity<>0-4; - 5=Stoppbits<>1-2; -6=ErrorWORDLEN; -10=COM wird bereits verwendet; -11=Com wird bereits vom OS verwendet; -12=CPU hat keine COM mit der Nr.; -13=OS Error;-14=Kein Initialisierung; -15=falsche Übergabe; -16=Empfangsbuffer zu klein, muss >= 128 Byte's sein; -17=Übergabe war NIL; -19=keine Daten im Empfangsbuffer; -20=Sendeprozess konnte nicht abgeschlossen werden 
//
//[#ENGLISH]
// ***************************************************************************
// **************** 		 _SerLib::SetOnline                  	****************
// ***************************************************************************
// ** 																																		  **
// **   function enables or disables the lasal online communication					** 
// ***************************************************************************
//[>state]0:Lasal online communication disabled; 1=Lasal online communication enabled
//[<ErrorCode]0=OK; -1:Com<>1-4; -2=Error baudtable; -3=baudrate<>0-10; -4=parity<>0-4; - 5=stopbits<>1-2; -6=ErrorWORDLEN; -10=Com allready in use; -11=Com allready in use of OS; -12=CPU has no COM of this No.;-13=OS Error;-14=NoInitialization; -15=WRONG INPUT; -16=receiving buffer too low, has to be bigger then >= 128 Byte's; -17=INPUT was NIL; -19=no DATA in receiving buffer; -20=sending process couldn't be ended (disturbance., sendbuffer overflow, ...)
FUNCTION VIRTUAL GLOBAL _SerLib::SetOnline
VAR_INPUT
	state			: UDINT;
END_VAR
VAR_OUTPUT
	ErrorCode	:  DINT;
END_VAR

	
	IF state=TRUE THEN
	
		// if it is initialized, it must be closed
	
		IF SERUSER_IsInitialized( pHandle ) = 1 THEN
			SERUSER_Close( pHandle );	
		END_IF;
	  pHandle   := NIL;
	END_IF;	
		
	ErrorCode := SERUSER_SetOnline( state );	
		
END_FUNCTION //GLOBAL _SerLib::SetOnline
//[#DEUTSCH]
// ***************************************************************************
// **************** 		 	_SerLib::StopUser                 *****************
// ***************************************************************************
// ** 																																			**
// **   Funktion schließt eine initialisiert Schnittstelle 									**
// **    und stellt Schnittstelle auf SIGMATEK Protokoll										**
// ***************************************************************************
//[<ErrorCode]0=OK; -1:Com<>1-4; -2=Fehler Baud Tabelle; -3=Baudrate<>0-10; -4=Parity<>0-4; - 5=Stoppbits<>1-2; -6=ErrorWORDLEN; -10=COM wird bereits verwendet; -11=Com wird bereits vom OS verwendet; -12=CPU hat keine COM mit der Nr.; -13=OS Error;-14=Kein Initialisierung; -15=falsche Übergabe; -16=Empfangsbuffer zu klein, muss >= 128 Byte's sein; -17=Übergabe war NIL; -19=keine Daten im Empfangsbuffer; -20=Sendeprozess konnte nicht abgeschlossen werden 
//
//[#ENGLISH]
// ***************************************************************************
// **************** 		 _SerLib::StopUser                  	****************
// ***************************************************************************
// ** 																																		  **
// ** Closes an initialized COM and enables the lasal online-communication  **
// ***************************************************************************
//[<ErrorCode]0=OK; -1:Com<>1-4; -2=Error baudtable; -3=baudrate<>0-10; -4=parity<>0-4; - 5=stopbits<>1-2; -6=ErrorWORDLEN; -10=Com allready in use; -11=Com allready in use of OS; -12=CPU has no COM of this No.;-13=OS Error;-14=NoInitialization; -15=WRONG INPUT; -16=receiving buffer too low, has to be bigger then >= 128 Byte's; -17=INPUT was NIL; -19=no DATA in receiving buffer; -20=sending process couldn't be ended (disturbance., sendbuffer overflow, ...)
FUNCTION VIRTUAL GLOBAL _SerLib::StopUser
VAR_OUTPUT
	ErrorCode	: DINT;
END_VAR

	IF SERUSER_IsInitialized( pHandle ) = 1 THEN
		SERUSER_Close( pHandle );	
		pHandle := NIL;
	END_IF;

	ErrorCode := SERUSER_SetOnline( TRUE );	

END_FUNCTION //GLOBAL _SerLib::StopUser
//[#DEUTSCH]
// **********************************************************************************
// *******************           setzt/loescht DTR            ***********************
// **********************************************************************************
// *                                                                                *
// *  Funktion setzt oder loescht DTR an der Seriellen Schnittstelle                *
// *  DTR = PIN 4 an der 9 poligen D-Sub                                            *
// ** ----------------------------------------------------------------------------- *
// *  -> state=0: low                                                               *
// *     state=1: high (standard)                                                   *
// *                                                                                *
// ** ----------------------------------------------------------------------------- *
// ** erstellt   : BS :  KW 48/03                                                   *
// **********************************************************************************
//[>state]0=low, 1=high (standard)
//[<ErrorCode]0=OK; -1:Com<>1-4; -2=Fehler Baud Tabelle; -3=Baudrate<>0-10; -4=Parity<>0-4; - 5=Stoppbits<>1-2; -6=ErrorWORDLEN; -10=COM wird bereits verwendet; -11=Com wird bereits vom OS verwendet; -12=CPU hat keine COM mit der Nr.; -13=OS Error;-14=Kein Initialisierung; -15=falsche Übergabe; -16=Empfangsbuffer zu klein, muss >= 128 Byte's sein; -17=Übergabe war NIL; -19=keine Daten im Empfangsbuffer; -20=Sendeprozess konnte nicht abgeschlossen werden
//[#ENGLISH]
// **********************************************************************************
// *******************            sets/clr's   DTR            ***********************
// **********************************************************************************
// *                                                                                *
// *  Functin set's or clear's DTR on the SERIAL interfaces                         *
// *  DTR = PIN 4  (9pol. D-SUB)                                                    *
// ** ----------------------------------------------------------------------------- *
// *  -> state=0: LOW                                                               *
// *     state=1: HIGH (normally)                                                   *
// *                                                                                *
// ** ----------------------------------------------------------------------------- *
// ** created    : BS :  KW 48/03                                                   *
// **********************************************************************************
//[>state]0=low, 1=high (normally)
//[<ErrorCode]0=OK; -1:Com<>1-4; -2=Error baudtable; -3=baudrate<>0-10; -4=parity<>0-4; - 5=stopbits<>1-2; -6=ErrorWORDLEN; -10=Com allready in use; -11=Com allready in use of OS; -12=CPU has no COM of this No.;-13=OS Error;-14=NoInitialization; -15=WRONG INPUT; -16=receiving buffer too low, has to be bigger then >= 128 Byte's; -17=INPUT was NIL; -19=no DATA in receiving buffer; -20=sending process couldn't be ended (disturbance., sendbuffer overflow, ...)
FUNCTION VIRTUAL GLOBAL _SerLib::DtrOnOff
VAR_INPUT
	state		: BOOL;
END_VAR
VAR_OUTPUT
	ErrorCode	: DINT;
END_VAR

	IF pHandle <> 0 THEN
		ErrorCode := SERUSER_SetModemControl(pHandle,NOT(State),SERUSER_DTR); //(handle)
	ELSE
		ErrorCode := -14;
	END_IF;

END_FUNCTION //VIRTUAL GLOBAL _SerLib::DtrOnOff

//[#DEUTSCH]
// **********************************************************************************
// *******************               liest DTR                ***********************
// **********************************************************************************
// *                                                                                *
// *  Funktion liest DTR an der Seriellen Schnittstelle                             *
// *  DTR = PIN 4  (9pol. D-SUB)                                                    *
// ** ----------------------------------------------------------------------------- *
// *  <- state=0: LOW                                                               *
// *     state=1: HIGH                                                              *
// *                                                                                *
// ** ----------------------------------------------------------------------------- *
// ** erstellt   : BS :  KW 48/03                                                   *
// **********************************************************************************
//[<state]0=LOW, 1=HIGH
//[#ENGLISH]
// **********************************************************************************
// *******************               read's   DTR             ***********************
// **********************************************************************************
// *                                                                                *
// *  Functin read's DTR on the Serial interfaces                                   *
// *  DTR = PIN 4  (9pol. D-SUB)                                                    *
// ** ----------------------------------------------------------------------------- *
// *  <- state=0: LOW                                                               *
// *     state=1: HIGH                                                              *
// *                                                                                *
// ** ----------------------------------------------------------------------------- *
// ** created    : BS :  KW 48/03                                                   *
// **********************************************************************************
//
//[<state]0=LOW, 1=HIGH
FUNCTION VIRTUAL GLOBAL _SerLib::rdDtr
VAR_OUTPUT
	state		: BOOL;
END_VAR

	state := 0;
	IF pHandle <> 0 THEN
		SERUSER_GetModemControl(pHandle,#state$USINT);
		state := (state AND SERUSER_DTR) <> 0;
	END_IF;

END_FUNCTION //VIRTUAL GLOBAL _SerLib::rdDtr
//[#DEUTSCH]
// **********************************************************************************
// *******************           setzt/loescht RSMode         ***********************
// **********************************************************************************
// *  Funktion setzt den modus der Schnittstelle                                    *
// ** ----------------------------------------------------------------------------- *
// *  -> MODE   : Für RS232 = 232 (standard) | RS422 = 422 | RS485 = 485                          *
// *  <- ErrorCode                                                                  *
// *                                                                                *
// ** ----------------------------------------------------------------------------- *
// ** erstellt   : BS :  KW 48/03                                                   *
// **********************************************************************************
//[>Mode]For RS232 = 232 | RS422 = 422 | CIPC & RS485 = 485
//[#ENGLISH]
// **********************************************************************************
// *******************            sets/clr's RSMode           ***********************
// **********************************************************************************
// *  Funktion sets the mode of the interface                                       *
// ** ----------------------------------------------------------------------------- *
// *  -> MODE   : For RS232 = 232 (normally) | RS422 = 422 | RS485 = 485                    *
// *  <- ErrorCode                                                                  *
// *                                                                                *
// ** ----------------------------------------------------------------------------- *
// ** created    : BS :  KW 48/03                                                   *
// **********************************************************************************
//[>Mode]For RS232 = 232 | RS422 = 422 | CIPC & RS485 = 485
FUNCTION VIRTUAL GLOBAL _SerLib::SetRSMode
VAR_INPUT
	Mode		: UDINT;
END_VAR
VAR_OUTPUT
	ErrorCode	: DINT;
END_VAR

	IF pHandle THEN 
		IF Mode = 422 THEN
			ErrorCode := SERUSER_Set422Mode( pHandle, 1 );
		ELSIF Mode = 232 THEN
			ErrorCode := SERUSER_Set422Mode( pHandle, 0 );
		
    
    
    ELSIF Mode = 485 THEN
      
      //PH 19.05.05
      //if OS >= 01.01.049 and the destination plc is a C-IPC 
      //			IF _RtosVersion >= 16#550 & (_WhoAmI=16#20) THEN //DESTPLC_C_IPC) THEN  // V OS >= 5.80
			IF ((_RtosVersion >= 16#01131) & ((_WhoAmI=16#20) | (_WhoAmI=16#10001))) THEN
				ErrorCode := SERUSER_Set485Mode( pHandle, 1, 1 );
			ELSE
				ErrorCode := -21; // not supported
			END_IF;
         
		//PH 11.11.05 - changes from 1.5 to 1.6
		ELSIF Mode = 4850 then //new mode RS485 without echo
			IF ((_RtosVersion >= 16#01131) & ((_WhoAmI=16#20) | (_WhoAmI=16#10001))) THEN
				
				//RS485 Modus ohne ECHO
				ErrorCode := SERUSER_Set485Mode( pHandle, 1, 0 );
			ELSE
				ErrorCode := -21; // not supported
			END_IF;
      
		ELSE
			ErrorCode := -21; // not supported
		END_IF;
	ELSE
		ErrorCode := -1;
	END_IF;


END_FUNCTION //VIRTUAL GLOBAL _SerLib::SetRSMode
//[#DEUTSCH]
// **********************************************************************************
// *******************              liest RSMode              ***********************
// **********************************************************************************
// *  Funktion liefert den Modus der Schnittstelle                                  *
// ** ----------------------------------------------------------------------------- *
// *  -> MODE   : Für RS232 = 232 | RS422 = 422  IF Mode<0 => Mode=ErrorCode        *
// *  <- ErrorCode                                                                  *
// *                                                                                *
// ** ----------------------------------------------------------------------------- *
// ** erstellt   : RM :  KW 48/03                                                   *
// **********************************************************************************
//[>Mode]For RS232 = 232 | RS422 = 422; IF Mode<0 => Mode=ErrorCode
//[#ENGLISH]
// **********************************************************************************
// *******************            get's RSMode                ***********************
// **********************************************************************************
// *  function reads the RS Mode                                                    *
// ** ----------------------------------------------------------------------------- *
// *  -> MODE   : For RS232 = 232 | RS422 = 422 IF Mode<0 => Mode=ErrorCode         *
// *                                                                                *
// *                                                                                *
// ** ----------------------------------------------------------------------------- *
// ** created    : RM :  KW 48/03                                                   *
// **********************************************************************************
//[>Mode]For RS232 = 232 | RS422 = 422; IF Mode<0 => Mode=ErrorCode
FUNCTION VIRTUAL GLOBAL _SerLib::GetRSMode
VAR_OUTPUT
	Mode		: DINT;
END_VAR

	IF pHandle <> 0 THEN 
		
		Mode := 0;
		SERUSER_Get422Mode(pHandle, #Mode$UDINT);
		
		IF Mode = 1 THEN
		  Mode := 422;
		ELSIF Mode = 0 THEN
		  Mode := 232;
		ELSE
		  Mode := -21; // not supported
		END_IF;

	ELSE
	  Mode := -14;
	END_IF;

END_FUNCTION //VIRTUAL GLOBAL _SerLib::GetRSMode


//[#DEUTSCH]
// **********************************************************************************
// *******************               liest DSR                ***********************
// **********************************************************************************
// *                                                                                *
// *  Funktion liest DSR an der Seriellen Schnittstelle                             *
// *  DSR = PIN 6  (9pol. D-SUB)                                                    *
// ** ----------------------------------------------------------------------------- *
// *  <- state=0: LOW                                                               *
// *     state=1: HIGH                                                              *
// *                                                                                *
// ** ----------------------------------------------------------------------------- *
// ** erstellt   : BS :  KW 48/03                                                   *
// **********************************************************************************
//[<state]0=LOW, 1=HIGH
//[#ENGLISH]
// **********************************************************************************
// *******************               read's   DSR             ***********************
// **********************************************************************************
// *                                                                                *
// *  Functin read's DSR on the Serial interfaces                                   *
// *  DSR = PIN 6  (9pol. D-SUB)                                                    *
// ** ----------------------------------------------------------------------------- *
// *  <- state=0: LOW                                                               *
// *     state=1: HIGH                                                              *
// *                                                                                *
// ** ----------------------------------------------------------------------------- *
// ** created    : BS :  KW 48/03                                                   *
// **********************************************************************************
//
//[<state]0=LOW, 1=HIGH
FUNCTION VIRTUAL GLOBAL _SerLib::rdDSR
VAR_OUTPUT
	state		: BOOL;
END_VAR

	State := 0;
	IF pHandle <> 0 THEN
		SERUSER_GetModemStatus(pHandle,#state$USINT);
		state := (state AND 2#00100000) <> 0;
	END_IF;

END_FUNCTION //VIRTUAL GLOBAL _SerLib::rdDSR

//[#DEUTSCH]
// **********************************************************************************
// *******************               liest RI                 ***********************
// **********************************************************************************
// *  Ring Indicator                                                                *
// *  Funktion liest RI  an der Seriellen Schnittstelle                             *
// *  RI  = PIN 9  (9pol. D-SUB)                                                    *
// ** ----------------------------------------------------------------------------- *
// *  <- state=0: LOW                                                               *
// *     state=1: HIGH                                                              *
// *                                                                                *
// ** ----------------------------------------------------------------------------- *
// ** erstellt   : BS :  KW 48/03                                                   *
// **********************************************************************************
//[<state]0=LOW, 1=HIGH
//[#ENGLISH]
// **********************************************************************************
// *******************               read's  RI               ***********************
// **********************************************************************************
// *  Ring Indicator                                                                *
// *  Functin read's RI  on the Serial interfaces                                   *
// *  RI  = PIN 9  (9pol. D-SUB)                                                    *
// ** ----------------------------------------------------------------------------- *
// *  <- state=0: LOW                                                               *
// *     state=1: HIGH                                                              *
// *                                                                                *
// ** ----------------------------------------------------------------------------- *
// ** created    : BS :  KW 48/03                                                   *
// **********************************************************************************
//
//[<state]0=LOW, 1=HIGH
FUNCTION VIRTUAL GLOBAL _SerLib::rdRI
VAR_OUTPUT
	state		: BOOL;
END_VAR

	State := 0;
	IF pHandle <> 0 THEN
		SERUSER_GetModemStatus(pHandle,#state$USINT);
		state := (state AND 2#01000000) <> 0;
	END_IF;

END_FUNCTION //VIRTUAL GLOBAL _SerLib::rdRI
//[#DEUTSCH]
// **********************************************************************************
// *******************               liest DCD                ***********************
// **********************************************************************************
// *  Data Carrier Detect                                                           *
// *  Funktion liest DCD an der Seriellen Schnittstelle                             *
// *  DCD = PIN 1  (9pol. D-SUB)                                                    *
// ** ----------------------------------------------------------------------------- *
// *  <- state=0: LOW                                                               *
// *     state=1: HIGH                                                              *
// *                                                                                *
// ** ----------------------------------------------------------------------------- *
// ** erstellt   : BS :  KW 48/03                                                   *
// **********************************************************************************
//[<state]0=LOW, 1=HIGH
//[#ENGLISH]
// **********************************************************************************
// *******************               read's  DCD              ***********************
// **********************************************************************************
// *  Data Carrier Detect                                                           *
// *  Functin read's DCD on the Serial interfaces                                   *
// *  DCD = PIN 1  (9pol. D-SUB)                                                    *
// ** ----------------------------------------------------------------------------- *
// *  <- state=0: LOW                                                               *
// *     state=1: HIGH                                                              *
// *                                                                                *
// ** ----------------------------------------------------------------------------- *
// ** created    : BS :  KW 48/03                                                   *
// **********************************************************************************
//
//[<state]0=LOW, 1=HIGH
FUNCTION VIRTUAL GLOBAL _SerLib::rdDCD
VAR_OUTPUT
	state		: BOOL;
END_VAR

	State := 0;
	IF pHandle <> 0 THEN
		SERUSER_GetModemStatus(pHandle,#state$USINT);
		state := (state AND 2#10000000) <> 0;
	END_IF;

END_FUNCTION //VIRTUAL GLOBAL _SerLib::rdDCD
FUNCTION VIRTUAL GLOBAL _SerLib::Command::NewInst
VAR_INPUT
	pPara		: ^CmdStruct;
	pResult		: ^Results;
END_VAR
VAR_OUTPUT
	ret_code	: IprStates;
END_VAR


	pResult^.uiLng := 0;
	CASE pPara^.uiCmd$CmdCommand OF 
	  
	  //[!StartUserNI]
	  StartUserIPR: pResult^.aData[0]$DINT 	:= StartUser(Baud:=pPara^.aPara[0], wordl:=pPara^.aPara[1], Parity:=pPara^.aPara[2], StopB:=pPara^.aPara[3]);
      				pResult^.uiLng 			:= sizeof(pResult^.uiLng) + sizeof(DINT);

	  //[!StopUserNI]
	  StopUserIPR:	pResult^.aData[0]$DINT  := StopUser();
					pResult^.uiLng 			:= sizeof(pResult^.uiLng) + sizeof(DINT);

	  //[!SerCloseNI]
	  SerCloseIPR:	SerClose();

	  //[!SerSendNI]
	  SerSendIPR:	pResult^.aData[0]$DINT	:= SerSend(Buffer:=#pPara^.aPara[0], bufferlength:=sizeof(pPara^.aPara[0]), wrlen:=#pResult^.aData[4]$UDINT );
					pResult^.uiLng 			:= sizeof(pResult^.uiLng) + sizeof(DINT) + sizeof(DINT);

	  //[!RecvCharNI]
	  RecvCharIPR:	//_MemSet(#pResult^.aData[4], 0, sizeof(DINT)); //spimar rev. 1.9
          pResult^.aData[4] := 0;
					pResult^.aData[0]$DINT	:= RecvChar(Buffer := #pResult^.aData[4]);
					pResult^.uiLng 			:= sizeof(pResult^.uiLng) + sizeof(DINT) + sizeof(DINT);

	  //[!SetOnlineNI]
	  SetOnlineIPR:	pResult^.aData[0]$DINT	:= SetOnline(state := pPara^.aPara[0]$UDINT);
					pResult^.uiLng 			:= sizeof(pResult^.uiLng) + sizeof(DINT);

	  //[!GetRecvStateNI]
	  GetRecvStateIPR: 
	  				pResult^.aData[0]$UDINT := GetRecvState();
 	 				pResult^.uiLng 			:= sizeof(pResult^.uiLng) + sizeof(UDINT);

	  //[!GetSendStateNI]
	  GetSendStateIPR: 
	  				pResult^.aData[0]$UDINT := GetSendState();
					pResult^.uiLng 			:= sizeof(pResult^.uiLng) + sizeof(UDINT);

	  //[!GetErrorNI]
	  GetErrorIPR: 	pResult^.aData[0]$DINT 	:= GetError();
					pResult^.uiLng 			:= sizeof(pResult^.uiLng) + sizeof(DINT);

	  //[!IsInitializedNI]
	  IsInitializedIPR:
	  				pResult^.aData[0]$UDINT := IsInitialized();
					pResult^.uiLng 			:= sizeof(pResult^.uiLng) + sizeof(UDINT);

	  //[!ClearRecBufferNI]
	  ClearRecBufferIPR: 
	  				pResult^.aData[0]$DINT	:= ClearRecvBuffer();
					pResult^.uiLng 			:= sizeof(pResult^.uiLng) + sizeof(DINT);

		//[!SerInitNI]
		//for each com you have to create an objekt
		//	SerInitIPR:	pResult^.aData[0]$DINT := SerInit(Com_in:=pPara^.aPara[0], Baud_in:=pPara^.aPara[1], wordl_in:=pPara^.aPara[2], Parity_in:=pPara^.aPara[3], StopB_in:=pPara^.aPara[4]); 
						
		//		   			pResult^.uiLng := sizeof(pResult^.uiLng) + sizeof(DINT);
		
	  //[!RtsOnOffNI]
	  RtsOnOffIPR: 	pResult^.aData[0]$DINT := RtsOnOff(state:=pPara^.aPara[0]$BOOL);
					pResult^.uiLng 	       := sizeof(pResult^.uiLng) + sizeof(DINT);

	  //[!rdRtsNI]
	  rdRtsIPR:		//_MemSet(#pResult^.aData[0], 0, sizeof(DINT)); //spimar rev. 1.9
          pResult^.aData[0] := 0;
					pResult^.aData[0] 		:= rdRts();
					pResult^.uiLng 			:= sizeof(pResult^.uiLng) + sizeof(BOOL);

	  //[!rdCtsNI]
	  rdCtsIPR:		//_MemSet(#pResult^.aData[0], 0, sizeof(DINT)); //spimar rev. 1.9
          pResult^.aData[0] := 0;
					pResult^.aData[0]	:= rdCts();
					pResult^.uiLng 		:= sizeof(pResult^.uiLng) + sizeof(BOOL);

	  //[!DtrOnOffIPR]
	  DtrOnOffIPR:	pResult^.aData[0]$DINT := DtrOnOff(state:=pPara^.aPara[0]$BOOL);
					pResult^.uiLng 	       := sizeof(pResult^.uiLng) + sizeof(DINT);

	  //[!rdDtrIPR]
	  rdDtrIPR:		//_MemSet(#pResult^.aData[0], 0, sizeof(DINT)); //spimar rev. 1.9
          pResult^.aData[0] := 0;
					pResult^.aData[0] 		:= rdDtr();
					pResult^.uiLng 			:= sizeof(pResult^.uiLng) + sizeof(BOOL);

	  //[!rdDcdIPR]
	  rdDcdIPR:		//_MemSet(#pResult^.aData[0], 0, sizeof(DINT)); //spimar rev. 1.9
          pResult^.aData[0] := 0;
					pResult^.aData[0] 		:= rdDcd();
					pResult^.uiLng 			:= sizeof(pResult^.uiLng) + sizeof(BOOL);

	  //[!rdDsrIPR]
	  rdDsrIPR:		//_MemSet(#pResult^.aData[0], 0, sizeof(DINT)); //spimar rev. 1.9
          pResult^.aData[0] := 0;
					pResult^.aData[0] 		:= rdDsr();
					pResult^.uiLng 			:= sizeof(pResult^.uiLng) + sizeof(BOOL);

	  //[!rdRiIPR]
	  rdRiIPR:		//_MemSet(#pResult^.aData[0], 0, sizeof(DINT)); //spimar rev. 1.9
          pResult^.aData[0] := 0;
					pResult^.aData[0] 		:= rdRi();
					pResult^.uiLng 			:= sizeof(pResult^.uiLng) + sizeof(BOOL);

	  //[!SetRSModeIPR]
	  SetRSModeIPR: pResult^.aData[0]$DINT	:= SetRSMode(Mode:=(pPara^.aPara[0])$UDINT);
					pResult^.uiLng 			:= sizeof(pResult^.uiLng) + sizeof(DINT) + sizeof(DINT);

	  //[!GetRSModeIPR]
	  GetRSModeIPR: pResult^.aData[0]$DINT	:= GetRSMode();
					pResult^.uiLng 			:= sizeof(pResult^.uiLng) + sizeof(DINT) + sizeof(DINT);


    GetInterfaceTypeIPR:
          pResult^.aData[0]$DINT := GetInterfaceType();
					pResult^.uiLng := sizeof(pResult^.uiLng) + sizeof(DINT); 

	END_CASE;

	ret_code := READY;

END_FUNCTION //VIRTUAL GLOBAL _SerLib::Command::NewInst




FUNCTION VIRTUAL GLOBAL _SerLib::RecvTimingChar
	VAR_INPUT
		Buffer 	: pVoid;
	END_VAR
	VAR_OUTPUT
		ErrorCode 	: DINT;
	END_VAR
  
  ErrorCode := SERUSER_RecvTimingChar( pHandle, Buffer );

END_FUNCTION



FUNCTION VIRTUAL GLOBAL _SerLib::RecvTimingBlock
	VAR_INPUT
		Buffer 	: ^void;
		rdlength 	: UDINT;
		rdlen 	: ^UDINT;
	END_VAR
	VAR_OUTPUT
		ErrorCode 	: DINT;
	END_VAR
  
  ErrorCode := SERUSER_RecvTimingBlock( pHandle, Buffer, rdlength, rdlen);

END_FUNCTION


FUNCTION VIRTUAL GLOBAL _SerLib::ClearTimingBuffer
	VAR_OUTPUT
		ErrorCode 	: DINT;
	END_VAR

  ErrorCode := SERUSER_ClearTimingBuffer(pHandle);
  
END_FUNCTION


FUNCTION VIRTUAL GLOBAL _SerLib::SetTimingBufferRecv
	VAR_INPUT
		RecvBuffer 	: ^void;
		BufferLength 	: UDINT;
	END_VAR
	VAR_OUTPUT
		ErrorCode 	: DINT;
	END_VAR
  
  ErrorCode := SERUSER_SetTimingBufferRecv(pHandle, RecvBuffer, BufferLength);

END_FUNCTION

FUNCTION VIRTUAL GLOBAL _SerLib::GetInterfaceType
VAR_OUTPUT
  Retcode 	: DINT;
END_VAR

  Retcode := 2#000;

END_FUNCTION
