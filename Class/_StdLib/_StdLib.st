//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)
//{{LSL_DECLARATION

(*!
<Class
	Name               = "_StdLib"
	Revision           = "0.0"
	GUID               = "{4294CD93-628C-11D6-8832-0048545E88BC}"
	RealtimeTask       = "false"
	CyclicTask         = "false"
	BackgroundTask     = "false"
	Sigmatek           = "true"
	OSInterface        = "true"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	SharedCommandTable = "true"
	Objectsize         = "(284,120)"
	Comment            = "provides standard OS functions like malloc, memcpy, etc..">
	<Channels>
		<Server Name="Server0" GUID="{4294CD94-628C-11D6-8832-0048545E88BC}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false"/>
	</Channels>
	<Dependencies>
		<Files>
			<File Path=".\Source\code\OsiBaseNew.st"/>
			<File Path=".\Source\code\OsiBaseNew.h" Include="false"/>
		</Files>
	</Dependencies>
</Class>
*)
_StdLib : CLASS
	TYPE
	  OS_SSR : STRUCT
	    InstallIRQ : pVoid;
	    InstallIRQObject : pVoid;
	    CreateMailbox : pVoid;
	    MailboxGet : pVoid;
	    MailboxPut : pVoid;
	    MailboxDelete : pVoid;
	    CreateSemaphore : pVoid;
	    SemSignal : pVoid;
	    SemPulse : pVoid;
	    SemWait : pVoid;
	    SemWaitCond : pVoid;
	    SemDelete : pVoid;
	    OutW : pVoid;
	    OutB : pVoid;
	    InpW : pVoid;
	    InpB : pVoid;
	    MemoryAccess : pVoid;
	    CanTxObj : pVoid;
	    AddCanObj : pVoid;
	    Malloc : pVoid;
	    Free : pVoid;
	    SetSysTime : pVoid;
	    SetSysDate : pVoid;
	    GetSysTime : pVoid;
	    GetSysDate : pVoid;
	    Realloc : pVoid;
	    InstallIRQLasal : pVoid;
	    Memmove : pVoid;
	    Memcpy : pVoid;
	    memset : pVoid;
	    Memcmp : pVoid;
	    LoginIntoCANNew : pVoid;
	    GetObjectInfo : pVoid;
	    dummy1 : pVoid;
	    dummy2 : pVoid;
	    dummy3 : pVoid;
	    dummy4 : pVoid;
	    OSDelaay : pVoid;
	    InstallDiasHandler : pVoid;
	    AddToServiceProvider : pVoid;
	    dummy11 : pVoid;
	    dummy12 : pVoid;
	    EE_read : pVoid;
	    EE_write : pVoid;
	    ButtonPressed : pVoid;
	    SetTimerIntVal : pVoid;
	    GetTimerIntVal : pVoid;
	    dummy20 : pVoid;
	    dummy21 : pVoid;
	    dummy22 : pVoid;
	    PROMGetInfo_socket : pVoid;
	    PROMSetData_Socket : pVoid;
	    PROMGetData_Socket : pVoid;
	    PROMGetInfo_Modul : pVoid;
	    PROMSetData_Modul : pVoid;
	    PROMGetData_Modul : pVoid;
	    PROMGetInfo_Flash : pVoid;
	    PROMSetDataFlash : pVoid;
	    PROMGetData_Flash : pVoid;
	    dummy30 : pVoid;
	    dummy31 : pVoid;
	    dummy32 : pVoid;
	    MallocV1 : pVoid;
	    ReallocV1 : pVoid;
	    dummy33 : pVoid;
	    dummy34 : pVoid;
	  END_STRUCT;
	END_TYPE
  //Servers:
	Server0 	: SvrChCmd_DINT;
  //Clients:
  //Variables:
  //Functions:
	
	FUNCTION _StdLib
		VAR_OUTPUT
			ret_code 	: ConfStates;
		END_VAR;
				//! <Function Comment="This function allocates memory in the Users Data Region." Name="Malloc"/>
	FUNCTION __CDECL VIRTUAL GLOBAL Malloc
		VAR_INPUT
			size 	: UDINT;			//! <Variable Comment="Paramter Size specifies the size of the memory-block." Name="Malloc.size"/>
		END_VAR
		VAR_OUTPUT
			retptr (EAX) 	: pVoid;			//! <Variable Comment="If the function succeeds, it returns a pointer to the allocated space. If the function fails, a NIL pointer is returned." Name="Malloc.retptr"/>
		END_VAR;
				//! <Function Comment="This function re-allocates memory in the Users Data Region." Name="ReAlloc"/>
	FUNCTION __CDECL VIRTUAL GLOBAL ReAlloc
		VAR_INPUT
			mptr 	: pVoid;			//! <Variable Comment="Parameter MPtr points to the previously allocated mem-pointer returned by Malloc." Name="ReAlloc.mptr"/>
			newsize 	: UDINT;			//! <Variable Comment="Parameter Size specifies the size of the memory-block." Name="ReAlloc.newsize"/>
		END_VAR
		VAR_OUTPUT
			retptr (EAX) 	: pVoid;			//! <Variable Comment="If the function succeeds, it returns a pointer to the newly allocated space, and data of the old malloc-pointer is copied to the new space, as far as there is enough space available to copy, else only a part of it is being copied. If the function fails, a NIL pointer is returned." Name="ReAlloc.retptr"/>
		END_VAR;
				//! <Function Comment="This function de-allocates memory in the Users Data Region." Name="Free"/>
	FUNCTION __CDECL VIRTUAL GLOBAL Free
		VAR_INPUT
			mptr 	: pVoid;			//! <Variable Comment="Parameter MPtr points to the previously allocated mem-pointer returned by Malloc or ReAlloc." Name="Free.mptr"/>
		END_VAR;
				//! <Function Comment="This function copies data between two buffers." Name="MemCpy"/>
	FUNCTION __CDECL VIRTUAL GLOBAL MemCpy
		VAR_INPUT
			dest 	: pVoid;			//! <Variable Comment="Paramter Dest points to the destination buffer." Name="MemCpy.dest"/>
			source 	: pVoid;			//! <Variable Comment="Paramter Source points to the source buffer." Name="MemCpy.source"/>
			size 	: UDINT;			//! <Variable Comment="Paramter Size specifies the count of copied characters." Name="MemCpy.size"/>
		END_VAR
		VAR_OUTPUT
			retval (EAX) 	: pVoid;			//! <Variable Comment="The function returns the value of the destination buffer." Name="MemCpy.retval"/>
		END_VAR;
				//! <Function Comment="This function moves one buffer to another." Name="MemMove"/>
	FUNCTION __CDECL VIRTUAL GLOBAL MemMove
		VAR_INPUT
			dest 	: pVoid;			//! <Variable Comment="Paramter Dest points to the destination buffer." Name="MemMove.dest"/>
			source 	: pVoid;			//! <Variable Comment="Paramter Source points to the source buffer." Name="MemMove.source"/>
			size 	: UDINT;			//! <Variable Comment="Paramter Size specifies the count of characters to be moved." Name="MemMove.size"/>
		END_VAR
		VAR_OUTPUT
			retval (EAX) 	: pVoid;			//! <Variable Comment="The function returns the value of the destination buffer." Name="MemMove.retval"/>
		END_VAR;
				//! <Function Comment="This function sets a count of bytes, specified in Parameter Size of a buffer pointed to by Paramter Dest to characters given in Parameter Value." Name="MemSet"/>
	FUNCTION __CDECL VIRTUAL GLOBAL MemSet
		VAR_INPUT
			dest 	: pVoid;
			value 	: CHAR;
			size 	: UDINT;
		END_VAR
		VAR_OUTPUT
			retval (EAX) 	: pVoid;			//! <Variable Comment="The function returns the value of the destination buffer." Name="MemSet.retval"/>
		END_VAR;
				//! <Function Comment="This function compares two buffers." Name="MemCmp"/>
	FUNCTION __CDECL VIRTUAL GLOBAL MemCmp
		VAR_INPUT
			dest 	: pVoid;			//! <Variable Comment="Paramter Dest points to the destination buffer." Name="MemCmp.dest"/>
			source 	: pVoid;			//! <Variable Comment="Paramter Source points to the source buffer." Name="MemCmp.source"/>
			size 	: UDINT;			//! <Variable Comment="Paramter Size specifies the count of characters to be compared." Name="MemCmp.size"/>
		END_VAR
		VAR_OUTPUT
			retval (AX) 	: UINT;			//! <Variable Comment="The return value indicates the relationship between the two buffers: &#10; If the RetVal is smaller then ZERO, Dest is less than Source, if RetVal returns ZERO, the buffers are identical. &#10; If the RetVal is greater then ZERO, buffer Dest is greater than Source." Name="MemCmp.retval"/>
		END_VAR;
	
	FUNCTION __CDECL VIRTUAL GLOBAL MallocV1
		VAR_INPUT
			size0 	: UDINT;
			mark0 	: USINT;
		END_VAR
		VAR_OUTPUT
			retptr (EAX) 	: pVoid;
		END_VAR;
	
	FUNCTION __CDECL VIRTUAL GLOBAL ReallocV1
		VAR_INPUT
			mptr0 	: pVoid;
			newsize 	: UDINT;
			mark0 	: USINT;
		END_VAR
		VAR_OUTPUT
			retptr (EAX) 	: pVoid;
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

//}}LSL_DECLARATION


FUNCTION GLOBAL TAB _StdLib::@CT_
0$UINT,
2#0100000000001000$UINT, //TY__STDLIB
0$UINT, 0$UINT, (SIZEOF(::_StdLib))$UINT, 
1$UINT, 0$UINT, 0$UINT, 
TO_UDINT(3689364044), "_StdLib", //Class
TO_UDINT(0), 0, 0$UINT, 0$UINT, //Baseclass
//Servers:
(::_StdLib.Server0.pMeth)$UINT, _CH_CMD$UINT, 2#0000000000000000$UINT, TO_UDINT(2759080719), "Server0", 
//Clients:
END_FUNCTION


#define USER_CNT__StdLib 9

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT__StdLib] OF ^Void;
	END_STRUCT;
END_TYPE



//{{LSL_IMPLEMENTATION


//*********************Inserted from <.\OS Interface\code\StdLib_00_00.st>*********************



 



#include <Rtos_interfaces.h> // we need this for the SysCIL functions
#include "..\..\Source\code\OsiBaseNew.h"


FUNCTION  _StdLib::_StdLib
VAR_OUTPUT
	ret_code		: CONFSTATES;
END_VAR
VAR
    pSSR    : ^OS_SSR;
	aMeths	: ARRAY[0..USER_CNT__StdLib] OF ^void;
	retv    : SYS_ERROR;
END_VAR;

	retv := OS_CILGet("SSR", #pSSR$void);

	if retv <> SYS_ERR_NONE then

		TRACE("ERROR: Standard-Lib Interface not available with this version/platform!");
		ret_code	:= C_UNKNOWN_CONSTR;
    else

		aMeths [0]	:= pSSR^.Malloc;
		aMeths [1]	:= pSSR^.Realloc;
		aMeths [2]	:= pSSR^.Free;

		aMeths [3]	:= pSSR^.Memcpy;
		aMeths [4]	:= pSSR^.Memmove;
		aMeths [5]	:= pSSR^.memset;
		aMeths [6]	:= pSSR^.Memcmp;

		aMeths [7]  := pSSR^.MallocV1;
		aMeths [8]  := pSSR^.ReallocV1;

		ret_code	:= InitOsiM_new(#aMeths[0]$void, USER_CNT__StdLib);
	end_if;

END_FUNCTION //  StdLib::StdLib

