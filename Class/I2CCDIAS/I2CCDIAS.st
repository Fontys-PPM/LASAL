//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)
//{{LSL_DECLARATION

(*!
<Class
	Name               = "I2CCDIAS"
	Revision           = "1.6"
	GUID               = "{A2878E60-0FDA-43B3-881D-B8E0ED92A1CF}"
	RealtimeTask       = "false"
	CyclicTask         = "false"
	BackgroundTask     = "false"
	Sigmatek           = "true"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	IconPath           = ".\Class\Tool.ico"
	SharedCommandTable = "true"
	Objectsize         = "(284,120)">
	<Channels>
		<Server Name="Control" GUID="{C1929590-C7E6-444D-B2C8-1C2C332325F8}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Client Name="MasterConnect" Required="true" Internal="false"/>
		<Client Name="To_OSKernel" Required="false" Internal="false"/>
	</Channels>
	<Dependencies>
		<Files>
			<File Path=".\Class\I2CCDIAS\EEFuncDef.h" Include="false"/>
		</Files>
	</Dependencies>
	<RevDoku>
		<Owner/>
		<Dokumentation Revision="1.6" Date="21.08.2013" Author="FucHer" Company="Sigmatek" Description="Changed AWL code to Structured Text."/>
	</RevDoku>
</Class>
*)
I2CCDIAS : CLASS
	TYPE
	  s_DiasInfoType : STRUCT
	    DiasType : UDINT;
	    DiasHWPointer : UDINT;
	    CDIASType : UDINT;
	    CDIASHWPointer : UDINT;
	    CfgRegsType : UDINT;
	    CfgRegsHWPointer : UDINT;
	    XregsType : UDINT;
	    XregsHWPointer : UDINT;
	    PLLType : UDINT;
	    PLLHWPointer : UDINT;
	    EERType : UDINT;
	    EERPointer : UDINT;
	  END_STRUCT;
	END_TYPE
  //Servers:
	Control 	: SvrChCmd_DINT;
  //Clients:
	MasterConnect 	: CltChCmd_DiasMaster;
	To_OSKernel 	: CltChCmd__OSKernel;
  //Variables:
		ReadError 	: DINT;
		FirstScan 	: DINT;
		noCDias 	: DINT;
		I2CType 	: UDINT;
		CDiasI2CPointer 	: ^USINT;
		CDiasI2CPointerEnable 	: ^USINT;
		_LSL_CDIAS_EEPROM 	: ^_LSL_CDIAS_EEPROM;
		ptrx 	: ^DINT;
		pFlashInfo 	: ^LSL_IFLASH;
		b_NoCIDASWrite 	: BOOL;
		RegEDI 	: UDINT;
  //Functions:
	
	FUNCTION VIRTUAL GLOBAL Init;
	
	FUNCTION VIRTUAL GLOBAL I2CReadOneByte
		VAR_INPUT
			AdressCDIAS 	: UINT;
			pData 	: ^USINT;
		END_VAR
		VAR_OUTPUT
			result 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL I2CWriteOneByte
		VAR_INPUT
			AdressCDIAS 	: UINT;
			pData 	: ^USINT;
		END_VAR
		VAR_OUTPUT
			result 	: DINT;
		END_VAR;
	
	FUNCTION AWL RdOutI2C;
	
	FUNCTION AWL ClkI2CHigh;
	
	FUNCTION AWL ClkI2CLo;
	
	FUNCTION AWL ClkI2C;
	
	FUNCTION AWL AdrOutI2C;
	
	FUNCTION AWL GetNAK;
	
	FUNCTION AWL GetAKN;
				//! <Function Comment="&#13;&#10; .. daten von seriellen reinholen ..&#13;&#10;&#13;&#10; p1.0 clk&#13;&#10; p1.3 data (p3.6 =1)&#13;&#10; p3.6 enable treiber)&#13;&#10; p3.7 data out&#13;&#10;" Name="DatInI2C"/>
	FUNCTION AWL DatInI2C;
				//! <Function Comment=" this is the stop&#13;&#10; data = lo clock = high data=high clock= lo&#13;&#10;" Name="StopI2C"/>
	FUNCTION AWL StopI2C;
				//! <Function Comment=" this is the start&#13;&#10; data = hi clock = high data=lo   clock= lo&#13;&#10; p1.0 clk&#13;&#10; p1.3 data (p3.6 =1)&#13;&#10; p3.6 enable treiber)&#13;&#10; p3.7 data out&#13;&#10;" Name="StartI2C"/>
	FUNCTION AWL StartI2C;
	
	FUNCTION AWL I2CREADIPC
		VAR_INPUT
			Adress 	: UDINT;
		END_VAR
		VAR_OUTPUT
			value 	: UDINT;
		END_VAR;
	
	FUNCTION AWL I2CREAD
		VAR_INPUT
			Adress 	: UDINT;
		END_VAR
		VAR_OUTPUT
			value 	: UDINT;
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

#pragma usingLtd _OSKernel
#pragma usingLtd DiasMaster


//}}LSL_DECLARATION


FUNCTION GLOBAL TAB I2CCDIAS::@CT_
0$UINT,
2#0100000000000000$UINT, //TY_I2CCDIAS
1$UINT, 6$UINT, (SIZEOF(::I2CCDIAS))$UINT, 
1$UINT, 2$UINT, 0$UINT, 
TO_UDINT(2326720416), "I2CCDIAS", //Class
TO_UDINT(0), 0, 0$UINT, 0$UINT, //Baseclass
//Servers:
(::I2CCDIAS.Control.pMeth)$UINT, _CH_CMD$UINT, 2#0000000000000000$UINT, TO_UDINT(3533623889), "Control", 
//Clients:
(::I2CCDIAS.MasterConnect.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(1515240279), "MasterConnect", TO_UDINT(2647887450), "DiasMaster", 2$UINT, 33$UINT, 
(::I2CCDIAS.To_OSKernel.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(2681344549), "To_OSKernel", TO_UDINT(3045737964), "_OSKernel", 0$UINT, 5$UINT, 
END_FUNCTION


#define USER_CNT_I2CCDIAS 2

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_I2CCDIAS] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION I2CCDIAS::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
	END_VAR

	//Command Methods
	InitCmdTable (nCmd := nSTDCMD + USER_CNT_I2CCDIAS, pCmd := #vmt.CmdTable);
	vmt.CmdTable.Init		:= #Init();
#pragma warning (disable : 74)
	vmt.UserFcts[0]		:= #I2CReadOneByte();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[1]		:= #I2CWriteOneByte();

#pragma warning (default : 74)
	Control.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF Control.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;

END_FUNCTION

//{{LSL_IMPLEMENTATION


//*********************Inserted from .\I2CCDIAS\I2CCDIAS_00_00.st*********************



 



(*********************************************************************************
*
*	Class to read a eeprom from CDIAS-Bus
*	Created: Sigmatek / 2003
*	Changes: 
*		1.4 => 1.5	/	16.03.2007	/	Mark:	//#SR000
*			- [DB 528]: insert functions to write to cdias eeprom
*		1.3 => 1.4 / 07.06.2005 / Mark: // ws001
*			replacement of pointer offsets with data structures
*		0.3 => 1.3 / 23.12.2004 / no Mark / ws
*			compatibility with Lasal Class 2
*			removed visible flags from internal servers
*		0.2 => 0.3 / 11.08.2004 / Mark: // #BS000
*			In the future the OS will read the I2C EEProm
*
*********************************************************************************)

#DEFINE I2C_P1CFG 16#f820
#DEFINE I2C_P1DIR 16#f864
#DEFINE I2C_P1PIN 16#f860
#DEFINE I2C_P1LTC 16#f862

#DEFINE I2C_P3CFG 16#f824                            //Port 3 - Konfiguration
#DEFINE I2C_P3LTC 16#F872                                   //Ausg„nge Port 3
#DEFINE I2C_P3DIR 16#F874                                //Port 3 - Direction

#DEFINE I2C_Prescaler 16 // prescaler = WBCLK/(5*SCLK) ca. 375kHz (max 400kHz)

FUNCTION VIRTUAL GLOBAL I2CCDIAS::Init
VAR
	//P2Cil     : ^UDINT;              // pointer auf die schnistelle
	P2Cil	: ^s_DiasInfoType;	//ws001
END_VAR	

	If FirstScan = 0 then
	  FirstScan :=1;
	  noCDias :=0;
	  if OS_CILGET("DiasInfo", #P2Cil) then
	  else
	  	IF _RtOSversion >= 16#553 THEN 				// #BS000
	 		//IF (P2Cil+8)^ THEN // if we have a CDIAS Bus
			if( P2Cil^.CDIASType )then				//ws001
				noCDias:=3; // function os				// #BS000
				//ptrx$udint := (p2Cil+44)^;				// #BS000
				ptrx$udint := P2CIL^.EERPointer;	//ws001
				_LSL_CDIAS_EEPROM$^dint := (#ptrx)$^dint; // #BS000
			END_IF;
		ELSE
		    //if (P2cil+8)^ = 1 then
			if( P2Cil^.CDIASType = 1)then	//ws001
			  noCDias:=1; // vorhanden 386 
			//elsif (P2cil+8)^ = 2 then
			elsif( P2Cil^.CDIASType = 2 )then	//ws001
			  noCDias:=2; // IPC 
			 //I2CType  := (p2Cil+16)^$UDINT;
			 I2CType := P2Cil^.CfgRegsType;		//ws001

	 	  	//CDiasI2CPointerEnable$UDINT := (p2Cil+28)^$UDINT + 4;
			CDiasI2CPointerEnable$UDINT := P2Cil^.XregsHWPointer + 4;	//ws001
		  	(CDiasI2CPointerEnable)^ := 1; // set from DVI EEPROM to CDIAS EEProm

	 	  	//CDiasI2CPointer$UDINT := (p2Cil+20)^$UDINT;
			CDiasI2CPointer$UDINT := P2Cil^.CfgRegsHWPointer;	//ws001
		  	(CDiasI2CPointer+2)^ := 16#80; // enable device
		  	(CDiasI2CPointer$^UINT)^ := I2C_prescaler;
   		   END_IF;
		end_if;
	  end_if;

		///#SR000 start
		// get pointer to interface
		If ( OS_CILGET( "IFLASH", #pFlashInfo ) ) then
			b_NoCIDASWrite := TRUE;
		end_if;
		//#SR000 end
	end_if;

END_FUNCTION //VIRTUAL GLOBAL I2CCDIAS::Init

//FUNCTION I2CCDIAS::I2CREAD_ST       not tested
//	VAR_INPUT
//		Adress 	: UDINT;
//	END_VAR
//	VAR_OUTPUT
//		value 	: UDINT;
//	END_VAR
//VAR
//	Data        : UINT;
//  Addr16Bit   : UINT;
//  AddrHi8Bit  : UINT;
//END_VAR
//
//
//  save_flg();
//  cli();
//  
//  ReadError := 0;
//  value     := 16#FFFFFFFF;
//
//// p1.0 clk
//// p1.3 data (p3.6 =1)
//// p3.6 enable treiber)
//// p3.7 data out
//  Data := To_OSKernel.InByte(Portnumber:=I2C_P1LTC) OR 16#11;   // DATA = 1
//  To_OSKernel.OutByte(Portnumber:=I2C_P1LTC, value:=Data);
//  
//  Data := To_OSKernel.InByte(Portnumber:=I2C_P3LTC) AND 2#00111111 OR 16#80;
//  To_OSKernel.OutByte(Portnumber:=I2C_P3LTC, value:=Data);
//  
//  StartI2C();
//  
//// start ist erledigt
//  
//  Addr16Bit  := Adress$UINT;
//  AddrHi8Bit := (Addr16Bit AND 0xFF00) SHL 1;
//  Addr16Bit  := Addr16Bit  AND 0x00FF  OR AddrHi8Bit OR 2#1010000000000000;
//    
//  AdrOutI2C(Addr16Bit);             // Adresse ausgeben
//
//  Addr16Bit := Addr16Bit OR 0x0100; // read
//  StartI2C();
//  RdOutI2C(Addr16Bit);
//  
//  Data := To_OSKernel.InByte(Portnumber:=I2C_P3LTC);
//  Data := Data OR 0x40;             // Treiber disable
//  To_OSKernel.OutByte(Portnumber:=I2C_P3LTC, value:=Data);
//  
//  DatInI2C();                       // Daten reinholen
//  
//// clock fuer AKN
//
//  GetNAK();
//  Data := To_OSKernel.InByte(Portnumber:=I2C_P3LTC) AND 2#00111111;
//  To_OSKernel.OutByte(Portnumber:=I2C_P3LTC, value:=Data);  // Daten auf 0
//  
//  StopI2C();
//  
//  if ReadError = 0 then
//    value := RegEDI;
//  end_if;
//  
//  restore_flg();
//
//END_FUNCTION // I2CCDIAS::I2CREAD

FUNCTION AWL I2CCDIAS::I2CREAD
	VAR_INPUT
	Adress		: UDINT;
	END_VAR
	VAR_OUTPUT
	value		: UDINT;
	END_VAR
#ifdef _LSL_TARGETARCH_X86
         PUSHF
         CLI
         PUSH      DX
         PUSH      ECX
         PUSH      BX
         PUSH      EDI

		 CLR	   EDI	
         L.D       ReadError   , 00000
		 l.d	   value,16#FFFFFFFF	
		 L.BX	   Adress+0	


// p1.0 clk
// p1.3 data (p3.6 =1)
// p3.6 enable treiber)
// p3.7 data out

         L.DX      I2C_P1LTC
         INB
         OR        001
   		 OR		   16#10		// DATA = 1	
		 OUTB

         L.DX      I2C_P3LTC
         INB
         AND       2#00111111
         OR        16#80
         OUTB

         CALL      STARTI2C

// start ist erledigt

         SHL.BH    001
         O.BX      2#1010000000000000

         PUSH      BX
         CALL      ADROUTI2C           // adresse ausgeben
         POP       BX

         O.BH      001                 // read
         CALL      STARTI2C
         CALL      RDOUTI2C

//
         L.DX      I2C_P3LTC
         INB
         O         16#40               // treiber disable
         OUTB

         CALL      DATINI2C            // daten reinholen

// clock fuer AKN

         CALL      GETNAK

         L.DX      I2C_P3LTC
         INB
         AND       2#00111111
         OUTB                          // daten auf 0

         CALL      STOPI2C

		 cmp.d	   ReadError,0
		 jnz	   I2CReadEnd
		 s.edi	   value	
I2CReadEnd		 				
         POP       EDI
         POP       BX
         POP       ECX
         POP       DX
         POPF
#endif
END_FUNCTION // I2CCDIAS::I2CREAD
// this is the start
// data = hi clock = high data=lo   clock= lo
// p1.0 clk
// p1.3 data (p3.6 =1)
// p3.6 enable treiber)
// p3.7 data out

//FUNCTION I2CCDIAS::StartI2C_ST       not tested
//VAR
//	Data    : UINT;
//END_VAR
//
//  // 2#00111111 = direction write, 0x80 = DATA1
//  Data := To_OSKernel.InByte(Portnumber:=I2C_P3LTC) AND 2#00111111 OR 0x80;   
//
//  To_OSKernel.OutByte(Portnumber:=I2C_P3LTC, value:=Data);  // daten auf 1
//  To_OSKernel.OutByte(Portnumber:=I2C_P3LTC, value:=Data);
//  To_OSKernel.OutByte(Portnumber:=I2C_P3LTC, value:=Data);
//  To_OSKernel.OutByte(Portnumber:=I2C_P3LTC, value:=Data);
//  To_OSKernel.OutByte(Portnumber:=I2C_P3LTC, value:=Data);
//  To_OSKernel.OutByte(Portnumber:=I2C_P3LTC, value:=Data);
//  To_OSKernel.OutByte(Portnumber:=I2C_P3LTC, value:=Data);
//  To_OSKernel.OutByte(Portnumber:=I2C_P3LTC, value:=Data);
//  To_OSKernel.OutByte(Portnumber:=I2C_P3LTC, value:=Data);
//  To_OSKernel.OutByte(Portnumber:=I2C_P3LTC, value:=Data);
//  To_OSKernel.OutByte(Portnumber:=I2C_P3LTC, value:=Data);
//  To_OSKernel.OutByte(Portnumber:=I2C_P3LTC, value:=Data);
//
//// start definition ist CL =1 = Daten von 1 auf 0
//
//  Data := To_OSKernel.InByte(Portnumber:=I2C_P1LTC) OR 1;
//  
//  To_OSKernel.OutByte(Portnumber:=I2C_P1LTC, value:=Data);  // zu kurz
//  To_OSKernel.OutByte(Portnumber:=I2C_P1LTC, value:=Data);
//  To_OSKernel.OutByte(Portnumber:=I2C_P1LTC, value:=Data);
//  To_OSKernel.OutByte(Portnumber:=I2C_P1LTC, value:=Data);
//  To_OSKernel.OutByte(Portnumber:=I2C_P1LTC, value:=Data);
//  To_OSKernel.OutByte(Portnumber:=I2C_P1LTC, value:=Data);
//  To_OSKernel.OutByte(Portnumber:=I2C_P1LTC, value:=Data);
//  To_OSKernel.OutByte(Portnumber:=I2C_P1LTC, value:=Data);
//  To_OSKernel.OutByte(Portnumber:=I2C_P1LTC, value:=Data);
//  To_OSKernel.OutByte(Portnumber:=I2C_P1LTC, value:=Data);
//  To_OSKernel.OutByte(Portnumber:=I2C_P1LTC, value:=Data);
//  To_OSKernel.OutByte(Portnumber:=I2C_P1LTC, value:=Data);
//
//  Data := To_OSKernel.InByte(Portnumber:=I2C_P3LTC) AND 2#01111111; // direction write
//  
//  To_OSKernel.OutByte(Portnumber:=I2C_P3LTC, value:=Data);  // daten auf 0
//  To_OSKernel.OutByte(Portnumber:=I2C_P3LTC, value:=Data);
//  To_OSKernel.OutByte(Portnumber:=I2C_P3LTC, value:=Data);
//  To_OSKernel.OutByte(Portnumber:=I2C_P3LTC, value:=Data);
//  To_OSKernel.OutByte(Portnumber:=I2C_P3LTC, value:=Data);
//  To_OSKernel.OutByte(Portnumber:=I2C_P3LTC, value:=Data);
//  To_OSKernel.OutByte(Portnumber:=I2C_P3LTC, value:=Data);
//  To_OSKernel.OutByte(Portnumber:=I2C_P3LTC, value:=Data);
//  To_OSKernel.OutByte(Portnumber:=I2C_P3LTC, value:=Data);
//  To_OSKernel.OutByte(Portnumber:=I2C_P3LTC, value:=Data);
//
//  Data := To_OSKernel.InByte(Portnumber:=I2C_P1LTC) AND 16#FE;
//  
//  To_OSKernel.OutByte(Portnumber:=I2C_P1LTC, value:=Data);
//
//END_FUNCTION // I2CCDIAS::StartI2C


// this is the start
// data = hi clock = high data=lo   clock= lo
// p1.0 clk
// p1.3 data (p3.6 =1)
// p3.6 enable treiber)
// p3.7 data out

FUNCTION AWL I2CCDIAS::StartI2C
#ifdef _LSL_TARGETARCH_X86
         L.DX      I2C_P3LTC
         INB
         AND       2#00111111          // direction write
         OR        16#80               // DATA1
         OUTB                          // daten auf 1
         OUTB
         OUTB
         OUTB
         OUTB
         OUTB
         OUTB
         OUTB
         OUTB
         OUTB
         OUTB
         OUTB

// start definition ist CL =1 = Daten von 1 auf 0

         L.DX      I2C_P1LTC
         INB
         OR        001
         OUTB                          // zu kurz
         OUTB
         OUTB
         OUTB
         OUTB
         OUTB
         OUTB
         OUTB
         OUTB
         OUTB
         OUTB
         OUTB

         L.DX      I2C_P3LTC
         INB
         AND       2#01111111          // direction write
         OUTB                          // daten auf 0
         OUTB
         OUTB
         OUTB
         OUTB
         OUTB
         OUTB
         OUTB
         OUTB
         OUTB

         L.DX      I2C_P1LTC
         INB
         AND       16#FE
         OUTB
#endif         
END_FUNCTION // I2CCDIAS::StartI2C

// this is the stop
// data = lo clock = high data=high clock= lo

//FUNCTION I2CCDIAS::StopI2C_ST       not tested
//VAR
//	Data    : UINT;
//END_VAR
//
//  Data := To_OSKernel.InByte(Portnumber:=I2C_P1LTC) OR 2#00000001;
//  
//  To_OSKernel.OutByte(Portnumber:=I2C_P1LTC, value:=Data);
//  To_OSKernel.OutByte(Portnumber:=I2C_P1LTC, value:=Data);
//
//  Data := To_OSKernel.InByte(Portnumber:=I2C_P3LTC) OR 16#80;
//  
//  To_OSKernel.OutByte(Portnumber:=I2C_P3LTC, value:=Data);  // daten auf 1
//
//END_FUNCTION // I2CCDIAS::StopI2C


// this is the stop
// data = lo clock = high data=high clock= lo

FUNCTION AWL I2CCDIAS::StopI2C
#ifdef _LSL_TARGETARCH_X86

  		 L.DX      I2C_P1LTC
         INB
         O         2#00000001
         OUTB
         OUTB

         L.DX      I2C_P3LTC
         INB
         O         16#80
         OUTB                          // daten auf 1
#endif
END_FUNCTION // I2CCDIAS::StopI2C
//
// .. daten von seriellen reinholen ..
//
// p1.0 clk
// p1.3 data (p3.6 =1)
// p3.6 enable treiber)
// p3.7 data out

//FUNCTION I2CCDIAS::DatInI2C_ST       not tested
//VAR
//	i       : DINT;
//  Data    : UINT;
//END_VAR
//
//  RegEDI := 0;
//  
//  for i:=0 to 7 do
//    ClkI2CHigh();
//    
//    Data := To_OSKernel.InByte(Portnumber:=I2C_P1PIN);
//  
//    RegEDI := RegEDI SHL 1;
//    if Data AND 0x10 then
//      RegEDI := RegEDI OR 1;
//    end_if;
//
//    ClkI2CLo();
//  end_for;
//
//END_FUNCTION // I2CCDIAS::DatInI2C


//
// .. daten von seriellen reinholen ..
//
// p1.0 clk
// p1.3 data (p3.6 =1)
// p3.6 enable treiber)
// p3.7 data out


FUNCTION AWL I2CCDIAS::DatInI2C
#ifdef _LSL_TARGETARCH_X86
         L.DX      I2C_P1PIN
         L.ECX     00008
         CLR       DI

DATINI2CL
         CALL      CLKI2CHIGH
         INB
         SHR       005
         RCL.DI    00001
         CALL      CLKI2CLO
         LOOP      DATINI2CL
         
#endif
END_FUNCTION // I2CCDIAS::DatInI2C
//
// .. 8 bit header noch mal ausgeben
// mit read auf 1

//FUNCTION I2CCDIAS::RdOutI2C_ST       not tested
//	VAR_INPUT
//		Address 	: UINT;
//	END_VAR
//VAR
//	i       : DINT;
//  Data    : UINT;
//  RegAH   : UINT;
//END_VAR
//
//// 1. Header+device
//
//  for i:=0 to 7 do
//    if Address AND 0x8000 then
//      RegAH := 0x8000;
//    else
//      RegAH := 0;
//    end_if;
//    Address := Address SHL 1;
//    
//    Data := To_OSKernel.InByte(Portnumber:=I2C_P3LTC) AND 2#01111111 OR RegAH;
//    To_OSKernel.OutByte(Portnumber:=I2C_P3LTC, value:=Data);
//  end_for;
//
//  GetAKN();
//
//END_FUNCTION // I2CCDIAS::RdOutI2C

//
// .. 8 bit header noch mal ausgeben
// mit read auf 1

FUNCTION AWL I2CCDIAS::RdOutI2C
#ifdef _LSL_TARGETARCH_X86
         L.ECX     00008
         L.DX      I2C_P3LTC

// 1. Header+device

RDOI2CL  CLR       AH
         SHL.BX    00001               // ab ins carry
         RCR.AH    001                 // carry ins ah

         INB
         AND       2#01111111
         O         AH
         OUTB

         CALL      CLKI2C
         LOOP      RDOI2CL

         CALL      GETAKN
#endif
END_FUNCTION // I2CCDIAS::RdOutI2C

//FUNCTION I2CCDIAS::ClkI2CHigh_ST       not tested
//VAR
//	Data    : UINT;
//END_VAR
//
//// *******************************************************************
////  clock high ausgeben
//// *******************************************************************
//  Data := To_OSKernel.InByte(Portnumber:=I2C_P1LTC) OR 2#00000001;  // clock
//  
//  To_OSKernel.OutByte(Portnumber:=I2C_P1LTC, value:=Data);
//  To_OSKernel.OutByte(Portnumber:=I2C_P1LTC, value:=Data);
//  To_OSKernel.OutByte(Portnumber:=I2C_P1LTC, value:=Data);
//  To_OSKernel.OutByte(Portnumber:=I2C_P1LTC, value:=Data);
//  To_OSKernel.OutByte(Portnumber:=I2C_P1LTC, value:=Data);
//  To_OSKernel.OutByte(Portnumber:=I2C_P1LTC, value:=Data);
//  To_OSKernel.OutByte(Portnumber:=I2C_P1LTC, value:=Data);
//  To_OSKernel.OutByte(Portnumber:=I2C_P1LTC, value:=Data);
//  To_OSKernel.OutByte(Portnumber:=I2C_P1LTC, value:=Data);
//
//END_FUNCTION // I2CCDIAS::ClkI2CHigh

FUNCTION AWL I2CCDIAS::ClkI2CHigh
#ifdef _LSL_TARGETARCH_X86
// *******************************************************************
//  clock high ausgeben
// *******************************************************************
         PUSH      DX
         L.DX      I2C_P1LTC
         INB
         O         2#00000001          // clock
         OUTB
         OUTB
         OUTB
         OUTB
         OUTB
         OUTB
         OUTB
         OUTB
         OUTB
         POP       DX
#endif
END_FUNCTION // I2CCDIAS::ClkI2CHigh

//FUNCTION I2CCDIAS::ClkI2CLo_ST       not tested
//VAR
//	Data    : UINT;
//END_VAR
//
//// *******************************************************************
//// einen clock am i2c ausgeben
//// *******************************************************************
//
//  Data := To_OSKernel.InByte(Portnumber:=I2C_P1LTC) AND 2#11111110;   // clock
//  
//  To_OSKernel.OutByte(Portnumber:=I2C_P1LTC, value:=Data);
//  To_OSKernel.OutByte(Portnumber:=I2C_P1LTC, value:=Data);
//  To_OSKernel.OutByte(Portnumber:=I2C_P1LTC, value:=Data);
//
//END_FUNCTION // I2CCDIAS::ClkI2CLo

FUNCTION AWL I2CCDIAS::ClkI2CLo
#ifdef _LSL_TARGETARCH_X86

// *******************************************************************
// einen clock am i2c ausgeben
// *******************************************************************

         PUSH      DX
         L.DX      I2C_P1LTC
         INB
         A         2#11111110          // clock
         OUTB
         OUTB
         OUTB
         POP       DX
#endif
END_FUNCTION // I2CCDIAS::ClkI2CLo

//FUNCTION I2CCDIAS::ClkI2C_ST       not tested
//VAR
//	Data    : UINT;
//END_VAR
//
//// *******************************************************************
//// einen clock am i2c ausgeben
//// *******************************************************************
//  Data := To_OSKernel.InByte(Portnumber:=I2C_P1LTC) OR 2#00000001;    // clock
//  
//  To_OSKernel.OutByte(Portnumber:=I2C_P1LTC, value:=Data);
//  To_OSKernel.OutByte(Portnumber:=I2C_P1LTC, value:=Data);
//  To_OSKernel.OutByte(Portnumber:=I2C_P1LTC, value:=Data);
//  To_OSKernel.OutByte(Portnumber:=I2C_P1LTC, value:=Data);
//  To_OSKernel.OutByte(Portnumber:=I2C_P1LTC, value:=Data);
//  To_OSKernel.OutByte(Portnumber:=I2C_P1LTC, value:=Data);
//  To_OSKernel.OutByte(Portnumber:=I2C_P1LTC, value:=Data);
//  To_OSKernel.OutByte(Portnumber:=I2C_P1LTC, value:=Data);
//  To_OSKernel.OutByte(Portnumber:=I2C_P1LTC, value:=Data);
//
//  Data := Data AND 2#11111110;    // clock
//
//  To_OSKernel.OutByte(Portnumber:=I2C_P1LTC, value:=Data);
//  To_OSKernel.OutByte(Portnumber:=I2C_P1LTC, value:=Data);
//  To_OSKernel.OutByte(Portnumber:=I2C_P1LTC, value:=Data);
//
//END_FUNCTION // I2CCDIAS::ClkI2C

FUNCTION AWL I2CCDIAS::ClkI2C
#ifdef _LSL_TARGETARCH_X86


// *******************************************************************
// einen clock am i2c ausgeben
// *******************************************************************
         PUSH      DX
         L.DX      I2C_P1LTC
         INB
         O         2#00000001          // clock
         OUTB
         OUTB
         OUTB
         OUTB
         OUTB
         OUTB
         OUTB
         OUTB
         OUTB
         A         2#11111110          // clock
         OUTB
         OUTB
         OUTB
         POP       DX

#endif
END_FUNCTION // I2CCDIAS::ClkI2C

//FUNCTION I2CCDIAS::AdrOutI2C_ST       not tested
//	VAR_INPUT
//		Address 	: UINT;
//	END_VAR
//  VAR
//  	i         : DINT;
//    Data      : UINT;
//    RegAH     : UINT;
//  END_VAR
//
////
//// .. device und befehl ausgeben (7 Takte) ..
////
//// --> Address = Adresse linksbuendig
////
//// p1.0 clk
//// p1.3 datain (p3.6 =1)
//// p3.6 enable treiber
//// p3.7 data out
//
//
//// 1. Header+device
//
//  for i:=0 to 7 do
//    if Address AND 0x8000 then
//      RegAH := 0x8000;
//    else
//      RegAH := 0;
//    end_if;
//    Address := Address SHL 1;
//    
//    Data := To_OSKernel.InByte(Portnumber:=I2C_P3LTC) AND 2#01111111 OR RegAH;
//    To_OSKernel.OutByte(Portnumber:=I2C_P3LTC, value:=Data);
//    
//    ClkI2C();
//  end_for;
//
//// 3. AKN (we dont care)in the moment
//
//  GetAKN();
//  
//// 4. Adresse
//
//  for i:=0 to 7 do
//    if Address AND 0x8000 then
//      RegAH := 0x8000;
//    else
//      RegAH := 0;
//    end_if;
//    Address := Address SHL 1;
//    
//    Data := To_OSKernel.InByte(Portnumber:=I2C_P3LTC) AND 2#01111111 OR RegAH;
//    To_OSKernel.OutByte(Portnumber:=I2C_P3LTC, value:=Data);
//    
//    ClkI2C();
//  end_for;
//
//// 5. AKN (we dont care)in the moment
//
//  GetAKN();
//
//END_FUNCTION // I2CCDIAS::AdrOutI2C

FUNCTION AWL I2CCDIAS::AdrOutI2C
//
// .. device und befehl ausgeben (7 Takte) ..
//
// --> BX ist adresse linksbndig
//
// p1.0 clk
// p1.3 datain (p3.6 =1)
// p3.6 enable treiber)
// p3.7 data out
#ifdef _LSL_TARGETARCH_X86

         L.ECX     00008
         L.DX      I2C_P3LTC

// 1. Header+device

HDOI2CL  CLR       AH
         SHL.BX    00001               // ab ins carry
         RCR.AH    001                 // carry ins ah

         INB
         AND       2#01111111
         O         AH
         OUTB
         CALL      CLKI2C
         LOOP      HDOI2CL

// 3. AKN (we dont care)in the moment

         CALL      GETAKN

// 4. Adresse

         L.ECX     00008

ADOI2CL  CLR       AH
         SHL.BX    00001               // ab ins carry
         RCR.AH    001                 // carry ins ah

         INB
         AND       2#01111111
         O         AH
         OUTB

         CALL      CLKI2C
         LOOP      ADOI2CL

// 5. AKN (we dont care)in the moment

         CALL      GETAKN

#endif
END_FUNCTION // I2CCDIAS::AdrOutI2C

//FUNCTION I2CCDIAS::GetNAK_ST       not tested
//VAR
//  i       : DINT;
//	Data    : UINT;
//END_VAR
//
//// akn auslesen
//
//  Data := (To_OSKernel.InByte(Portnumber:=I2C_P3LTC) OR 16#40) AND 2#01111111;
//  
//  To_OSKernel.OutByte(Portnumber:=I2C_P3LTC, value:=Data);
//
//  ClkI2C();
//
//  for i:=0 to 9 do
//    Data := To_OSKernel.InByte(Portnumber:=I2C_P1PIN);
//    if Data AND 2#00010000 then
//      exit;
//    end_if;
//
//    if i >= 10 then
//      ReadError += 1;
//    end_if;
//
//  end_for;
//
//  Data := To_OSKernel.InByte(Portnumber:=I2C_P3LTC) AND 2#10111111;
//  
//  To_OSKernel.OutByte(Portnumber:=I2C_P3LTC, value:=Data);
//
//END_FUNCTION // I2CCDIAS::GetNAK

FUNCTION AWL I2CCDIAS::GetNAK
#ifdef _LSL_TARGETARCH_X86

// akn auslesen

         PUSH      DX
         PUSH      ECX
         L.DX      I2C_P3LTC

         INB
         O         16#40
         AND       2#01111111
         OUTB

         CALL      CLKI2C

         L.ECX     00010

NAKWL    L.DX      I2C_P1PIN
         INB
         TEST      2#00010000
         JNZ       NAKOK
         LOOP      NAKWL
         INC.D     ReadError

NAKOK

         L.DX      I2C_P3LTC
         INB
         AND       2#10111111
         OUTB
         POP       ECX
         POP       DX
#endif
END_FUNCTION // I2CCDIAS::GetNAK

//FUNCTION I2CCDIAS::GetAKN_ST       not tested
//VAR
//  i       : DINT;
//	Data    : UINT;
//END_VAR
//
//// akn auslesen
//
//  Data := (To_OSKernel.InByte(Portnumber:=I2C_P3LTC) OR 16#40) AND 2#01111111;
//  To_OSKernel.OutByte(Portnumber:=I2C_P3LTC, value:=Data);
//
//  ClkI2C();
//  
//  for i:=0 to 9 do
//    Data := To_OSKernel.InByte(Portnumber:=I2C_P1PIN);
//    if (Data AND 2#00010000) = 0 then
//      exit;
//    end_if;
//  end_for;
//
//  Data := To_OSKernel.InByte(Portnumber:=I2C_P3LTC) AND 2#10111111;
//  To_OSKernel.OutByte(Portnumber:=I2C_P3LTC, value:=Data);
//
//END_FUNCTION // I2CCDIAS::GetAKN

FUNCTION AWL I2CCDIAS::GetAKN
#ifdef _LSL_TARGETARCH_X86
// akn auslesen

         PUSH      DX
         PUSH      ECX
         L.DX      I2C_P3LTC

         INB
         O         16#40
         AND       2#01111111
         OUTB

         CALL      CLKI2C

         L.ECX     00010

AKNWL    L.DX      I2C_P1PIN
         INB
         TEST      2#00010000
         JZ        AKNOK
         LOOP      AKNWL
//**         INC.D     ReadError
AKNOK

         L.DX      I2C_P3LTC
         INB
         AND       2#10111111
         OUTB
         POP       ECX
         POP       DX


#endif
END_FUNCTION // I2CCDIAS::GetAKN


FUNCTION VIRTUAL GLOBAL I2CCDIAS::I2CReadOneByte
VAR_INPUT
	AdressCDIAS		: UINT;
	pData		: ^USINT;
END_VAR
VAR_OUTPUT
	result		: DINT;
END_VAR
// CDIAS Adress => 1.Byte Offset in EEprom // 2.Byte Station

	IF firstscan = 0 THEN	// #BS000 to be faster
		Init();				// #BS000
	END_IF;					// #BS000

    result :=-1;
  
	case noCDias of
	// nicht vorhanden
	0:
	// 386 mit ports 
	1:
//"FucHer 21.08.2013 17:22 \ bei Typ 1 und 2 die Methoden mit dem AWL Code aufrufen, da wir uns hier fix auf einem INTEL befinden (mit uralter OS Version)")
//                      ARM: bei Typ 1 und 2 wird result :=-1; zurück gegeben
#ifdef _LSL_TARGETARCH_X86
	  pData^:= I2CREAD(Adress:=AdressCDIAS)$USINT;
	  if ReadError = 0 then
	   result := 0;
	  end_if;
#endif
	2:
#ifdef _LSL_TARGETARCH_X86
	  pData^:= I2CREADIPC(Adress:=AdressCDIAS)$USINT;
	  if ReadError = 0 then
	   result := 0;
	  end_if;
#endif
	// #BS000
	3:IF OS_READ_CDIAS_EEPROM((AdressCDIAS SHR 8)$USINT, (AdressCDIAS AND 16#FF), (pData$^Void)) THEN
			result := 0;
	  END_IF;
	// #BS000

	end_case;

END_FUNCTION //VIRTUAL GLOBAL I2CCDIAS::I2CReadOneByte

//FUNCTION I2CCDIAS::I2CREADIPC_ST       not tested
//	VAR_INPUT
//		Adress 	: UDINT;
//	END_VAR
//	VAR_OUTPUT
//		value 	: UDINT;
//	END_VAR
//VAR
//  Addr16Bit   : UINT;
//  AddrHi8Bit  : UINT;
//  Err         : BOOL;
//END_VAR
//
//  ReadError := 0;
//  value     := 16#FFFFFFFF;
//  Err       := FALSE;
//
//  Addr16Bit  := Adress$UINT;
//  AddrHi8Bit := (((Addr16Bit SHR 8) SHL 1) AND 2#1110) OR 16#A0;  // Write
//
//  (CDiasI2CPointer+3)^ := AddrHi8Bit$USINT;
//  (CDiasI2CPointer+4)^ := 2#10010000;
//
//  AddrHi8Bit := AddrHi8Bit OR 1;  // Read
//  
//  repeat
//  //Wait_RD_Ctrl_SetAdr
//  until (CDiasI2CPointer+4)^ = 2#10 end_repeat;
//
//  if (CDiasI2CPointer+4)^ = 16#80 then
//    (CDiasI2CPointer+3)^ := Addr16Bit$USINT;
//    (CDiasI2CPointer+4)^ := 2#10000;
//    
//    repeat
//    //Wait_RD_Ctrl_Dev
//    until (CDiasI2CPointer+4)^ = 2#10 end_repeat;
//    
//    if (CDiasI2CPointer+4)^ = 16#80 then
//      (CDiasI2CPointer+3)^ := AddrHi8Bit$USINT;
//      (CDiasI2CPointer+4)^ := 2#10010000;
//
//      repeat
//      //RD_Byte1
//      until (CDiasI2CPointer+4)^ = 2#10 end_repeat;
//      
//      if (CDiasI2CPointer+4)^ = 16#80 then
//        (CDiasI2CPointer+4)^ := 2#101000;
//
//        repeat
//        //RD_Stop
//        until (CDiasI2CPointer+4)^ = 2#10 end_repeat;
//
//        value := (CDiasI2CPointer+3)^;
//        (CDiasI2CPointer+4)^ := 2#1000000;
//      else
//        //I2C_Error
//        Err := TRUE;
//      end_if;
//
//    else
//      //I2C_Error
//      Err := TRUE;
//    end_if;
//
//  else
//    //I2C_Error
//    Err := TRUE;
//  end_if;
//
//  if Err then
//    (CDiasI2CPointer+4)^ := 2#1000000;
//    ReadError += 1;
//  end_if;
//
//END_FUNCTION // I2CCDIAS::I2CREADIPC

FUNCTION AWL I2CCDIAS::I2CREADIPC
	VAR_INPUT
	Adress		: UDINT;
	END_VAR
	VAR_OUTPUT
	value		: UDINT;
	END_VAR
#ifdef _LSL_TARGETARCH_X86
         PUSHF
         CLI
         PUSH      DX
         PUSH      ECX
         PUSH      BX
         PUSH      EDI

         L.D       ReadError   , 00000
		 l.d	   value,16#FFFFFFFF	
		 
		 L.AX		Adress+0
		 SHL.AH		1
		 AND.AH		2#1110
		 OR.AH		16#A0 // Write
		 L.BL		AH
		 OR.BL		1 // Read

		 L.EDI		CDiasI2CPointer

		 S.AH		(EDI+3)
		 L.B		(EDI+4),2#10010000


Wait_RD_Ctrl_SetAdr
		 TEST.B		(EDI+4),2#10
		 JNE		Wait_RD_Ctrl_SetAdr
		 TEST.B		(EDI+4),16#80
		 JNE		I2C_Error
		
		 S.AL		(EDI+3)
		 L.B		(EDI+4),2#10000
(*
//Write
Wait_RD_Ctrl_Dev
		 TEST.B		(EDI+4),2#10
		 JNE		Wait_RD_Ctrl_Dev
		 TEST.B		(EDI+4),16#80
		 JNE		I2C_Error

		 L.B		(EDI+3),123 // value to write
		 L.B		(EDI+4),2#10000
		 
Wait_RD_Ctrl_Dev1
		 TEST.B		(EDI+4),2#10
		 JNE		Wait_RD_Ctrl_Dev1
		 TEST.B		(EDI+4),16#80
		 JNE		I2C_Error
		 L.B		(EDI+4),2#1000000
		 JMP		I2CReadEnd	
*)

// Read
Wait_RD_Ctrl_Dev
		 TEST.B		(EDI+4),2#10
		 JNE		Wait_RD_Ctrl_Dev
		 TEST.B		(EDI+4),16#80
		 JNE		I2C_Error
		
		 S.BL		(EDI+3)
		 L.B		(EDI+4),2#10010000

RD_Byte1
		 TEST.B		(EDI+4),2#10
		 JNE		RD_Byte1
		 TEST.B		(EDI+4),16#80
		 JNE		I2C_Error

		 L.B		(EDI+4),2#101000

RD_Stop
		 TEST.B		(EDI+4),2#10
		 JNE		RD_Stop
		
		 L			(EDI+3)
		 L.B		(EDI+4),2#1000000
		 L.D		Value,0
		 S			Value+0
		 JMP		I2CReadEnd	

I2C_Error
		 L.B		(EDI+4),2#1000000
		 INC.D		ReadError

I2CReadEnd		 				
        
		 POP       EDI
         POP       BX
         POP       ECX
         POP       DX
//		 STI
         POPF
#endif
END_FUNCTION // I2CCDIAS::I2CREADIPC

FUNCTION VIRTUAL GLOBAL I2CCDIAS::I2CWriteOneByte			//#SR000
VAR_INPUT
	AdressCDIAS		: UINT;
	pData		: ^USINT;
END_VAR
VAR_OUTPUT
	result		: DINT;
END_VAR

// CDIAS Adress => 1.Byte Offset in EEprom // 2.Byte Station

	IF firstscan = 0 THEN	//to be faster
		Init();
	END_IF;

    result :=-1;
	case noCDias of
		// nicht vorhanden
		0:
		1:   
		2:

		3:	if ( b_NoCIDASWrite = 0 ) then
				
				if ( IFLASH_EEWriteCDIAS( ( AdressCDIAS shr 8 )$USINT, AdressCDIAS$USINT, pData^ ) ) then;
					result := 0;
				end_if;
		  	end_if;

	end_case;

END_FUNCTION //VIRTUAL GLOBAL I2CCDIAS::I2CWriteOneByte

