//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)

//{{LSL_DEFINES
#define DEVICE_ID_SR022             1083        //DeviceID of SR022

#define SR022_ADDR_CYC_WRITE        16#00       //Address for TPDO
#define SR022_ADDR_CYC_READ         16#08       //Address for RPDO

#define SR022_ADDR_CFG_FIRMWARE     16#200      //Address-Offset to the Configuration of the Firmware
#define SR022_ADDR_STATE_FIRMWARE   16#280      //Address-Offset to the Status of the Firmware
#define SR022_ADDR_READ_SDO         16#0C       //Address-Offset read sdo data
#define SR022_ADDR_I2T_THRESHOLD    16#18       //Address-Offset to I²T Threshold
#define SR022_ADDR_DC_SEQUENCER     16#20       //Address-Offset to sequencer SR022

#define SR022_INVALID_VALUE         16#80000010$DINT

#define SR022_NOENCODER             0
#define SR022_TTL_MODE              1
#define SR022_RS422_MODE            2

//Define for the H-Bridge
//-----------------------------------------------------------
#define SR022_GATE_A_LOW		          2#0100000000000000    //Bit-Configuration for Enable GateA Low-Switch
#define SR022_GATE_A_HIGH		          2#0001000000000000    //Bit-Configuration for Enable GateA High-Switch
#define SR022_GATE_B_LOW		          2#1000000000000000    //Bit-Configuration for Enable GateB Low-Switch
#define SR022_GATE_B_HIGH		          2#0010000000000000    //Bit-Configuration for Enable GateB High-Switch  

#define SR022_MASK_CONTROL	          16#0FFF     //Mask for Output Sequence Bits
#define SR022_MASK_TIME		            16#F000     //Mask for TimeValue

#define SR022_T_SWITCH                41      //Delay Time for Switch
#define SR022_DEFAULT_SEQ_INIT        1       //Initilization for Sequencer => After 1 FPGA-Cycle switch to next Sequency

#define SR022_FPGA_FREQ_MHZ           50    //Frequency of FPGA

#define SR022_SDO_RESPONSE_TIMEOUT  SDIAS_SDO_TIMEOUT * 2     //SDO-Response Timeout

//#define SR022_I2T_THRESHOLD          16000000   //Maximal allowed I²T Value in mA²s ==> 16 A²s
//#pragma message ("TarPet: dieser Wert wurde vorest empirisch ermittelt und sollte noch genau bestimmt werden");
#define SR022_I2T_THRESHOLD          78000   //Maximal allowed I²T Value in mA²s ==> 16 A²s

#define SR022_SPEED_SCALING          10000      //Scaling of the Server Speed (0.00% to 100.00%)
#define SR022_MINPULSE_SCALING       1000       //Scaling of the Server MinPulse (0.0% to 100.0%)
//}}LSL_DEFINES

//{{LSL_DECLARATION

(*!
<Class
	Name               = "SR022"
	Revision           = "1.2"
	GUID               = "{4EAA1CDB-B690-4962-9ACC-D6F0F0CE81D4}"
	RealtimeTask       = "false"
	CyclicTask         = "false"
	BackgroundTask     = "false"
	Sigmatek           = "true"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	IconPath           = ".\Class\s-dias.ico"
	SharedCommandTable = "true"
	Objectsize         = "(550,120)"
	Comment            = "SDIAS DC-Motor Module which supports&#13;&#10;1 x DC motor drive 3.5 A&#13;&#10;1 x Incremental Encoder (TTL/RS422)">
	<Channels>
		<Server Name="Enable" GUID="{0C8F77FF-B9E5-411D-90B7-EF202C370A18}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false" Comment="Server to Enable the DC-Motor&#13;&#10;0 = Disabled&#13;&#10;1 = Enable"/>
		<Server Name="ErrorBits" GUID="{08C18B9F-3374-4EA4-A74A-640E87036645}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Error Bits:&#13;&#10;Bit0...Not used&#13;&#10;Bit1...No Sync&#13;&#10;Bit2...Flash data CRC error&#13;&#10;Bit3...Ram data CRC error&#13;&#10;Bit4...No valid EEPROM Version&#13;&#10;..&#13;&#10;Bit16..Motor supply voltage not ok&#13;&#10;Bit17..Wrong sequence&#13;&#10;Bit18..Absolute time error&#13;&#10;Bit19..Motor current high&#13;&#10;Bit20..Motor current too high&#13;&#10;Bit21..Periphery reset Motor&#13;&#10;Bit22..Induction voltage too high&#13;&#10;Bit23..Over temperature error&#13;&#10;Bit24..I²T Error"/>
		<Server Name="ErrorQuit" GUID="{A7D6E65F-D890-4513-9783-320A135F463F}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false" Comment="Write 1 to quit the error bits"/>
		<Server Name="FirmwareVersion" GUID="{CA03879A-3921-41CB-A655-79C032E98777}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Version of the used firmware"/>
		<Server Name="I2T" GUID="{0ED911F7-2186-4175-9866-BC43E2BE92DB}" Visualized="false" Remotely="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Actual I²T Value.&#13;&#10;It is only available if Extended Data is activated.&#13;&#10;The invalid value is 16#80000010."/>
		<Server Name="Input1" GUID="{E123B794-5149-4CFE-9842-2CF8863526D2}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Digital Input 5V&#13;&#10;0..off&#13;&#10;1..on"/>
		<Server Name="Input2" GUID="{BD2564E1-4D7A-45E4-B50C-D13B093FA096}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Digital Input 24V&#13;&#10;0..off&#13;&#10;1..on"/>
		<Server Name="Input3" GUID="{41B2DB01-DE33-4AC3-8BAA-694F5D61587E}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Digital Input 24V&#13;&#10;0..off&#13;&#10;1..on"/>
		<Server Name="MinPulse" GUID="{A4E49314-3485-4126-A04A-70ACDC7084FF}" Visualized="true" Initialize="true" DefValue="7" WriteProtected="false" Retentive="false" Comment="Minimal Pulsewidth of PWM [0,1%]&#13;&#10;A change of this value will takes action after writing a new value to server SetSpeed."/>
		<Server Name="MotorCurrent" GUID="{2FEB9877-7F58-46A5-A193-3BC4EFEB63AB}" Visualized="false" Remotely="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Actual Motor Current [mA].&#13;&#10;It is only available if Extended Data is activated.&#13;&#10;The invalid value is 16#80000010."/>
		<Server Name="Position" GUID="{EFF1C63F-AC27-49C3-9916-5BFF2F1A34F9}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false" Comment="incremental Encoder Position"/>
		<Server Name="PositionLatch" GUID="{B316B9B3-2ED9-4CEF-946D-59B8FD6733A1}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Actual Latch-Value of the Incremental Encoder.&#13;&#10;It is only available if Extended Data is activated.&#13;&#10;The invalid value is 16#80000010."/>
		<Server Name="SetSpeed" GUID="{B7455796-68F0-4C52-94E6-99772401AC0D}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false" Comment="Set-Velocity of the Motor. [0.01%]&#13;&#10;Min-Value (negative Direction): -10000 = -100,00%&#13;&#10;Max-Value (positive Direction): 10000  = 100,00%&#13;&#10;"/>
		<Server Name="Temperature" GUID="{3076E46D-624C-4455-9D17-9703116C0577}" Visualized="false" Remotely="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Actual Temperature of the Module (°C).&#13;&#10;It is only available if Extended Data is activated.&#13;&#10;The invalid value is 16#80000010."/>
		<Server Name="VoltageOkMotor" GUID="{09E07731-E2EA-4E12-9E49-CBD019178C7C}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Shows state of voltage supply for motor.&#13;&#10;0 .. not ok&#13;&#10;1 .. ok"/>
		<Server Name="ZPuls" GUID="{CDF8FAFB-CC01-4DF6-AF51-4E65FB03A65A}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Zero Position"/>
		<Server Name="ZPulsLatched" GUID="{71850C42-3015-4CD9-83DD-33A77AC83683}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Zero Position latched (is reset when read() method is called)"/>
		<Client Name="ABCountMode" Required="true" Internal="false" DefValue="0" Comment="Set A/B count mode if 1 edge sampling is activated, as init value.&#13;&#10;0 .. A pulses, B direction&#13;&#10;1 .. true A/B"/>
		<Client Name="EncDirection" Required="true" Internal="false" DefValue="0" Comment="Counting Direction of the Encoder as init value.&#13;&#10;0 .. Normal&#13;&#10;1 .. Invers"/>
		<Client Name="EncMode" Required="true" Internal="false" DefValue="1" Comment="Mode of the Incremental Encoder as init value.&#13;&#10;0 .. No Encoder (disable)&#13;&#10;1 .. TTL&#13;&#10;2 .. RS422&#13;&#10;"/>
		<Client Name="EncSampling" Required="true" Internal="false" DefValue="3" Comment="Sampling of the Incremental Encoder as init value.&#13;&#10;0 .. Encoder off&#13;&#10;1 .. 1-edge&#13;&#10;2 .. 2-edge&#13;&#10;3 .. 4-edge&#13;&#10;"/>
		<Client Name="ExtendedData" Required="true" Internal="false" DefValue="0" Comment="Enable extended data for Temperature, MotorCurrent, I2T and PositionLatch with this setting as init value.&#13;&#10;0 .. disable extended data&#13;&#10;1 .. enable extended data"/>
		<Client Name="I2TThreshold" Required="true" Internal="false" DefValue="100" Comment="This client is used to set the I2C threshold in percent of the maximum threshold (maximum allowed I2T value of the hardware). &#13;&#10;A violation of this threshold causes an I2T error which leads to a switching off of the motor output.&#13;&#10;As init value."/>
		<Client Name="InvertZeroPosition" Required="true" Internal="false" DefValue="0" Comment="Inverts Z Pulses as init value.&#13;&#10;0..normal &#13;&#10;1..inverted"/>
		<Client Name="PWMPeriod" Required="true" Internal="false" DefValue="32" Comment="Sequencer PWM period in µs as init value."/>
	</Channels>
	<RevDoku>
		<Owner Company="Sigmatek" Author="PieSte"/>
		<Dokumentation Revision="1.2" Date="08.06.2018" Author="RamAnd" Company="Sigmatek" Description="LASAL Hardware Description (.lhd) file has been updated."/>
		<Dokumentation Revision="1.1" Date="23.01.2018" Author="RamAnd" Company="Sigmatek" Description="Log messages have been standardized for easier maintenance, easier use in any class and to allow spam filtering. Code for the logging functions is now only located in HwControl."/>
		<Dokumentation Revision="1.0" Date="04.07.2017" Author="PieSte" Company="Sigmatek" Description="First library version."/>
	</RevDoku>
	<Network Name="SR022">
		<!-- List of Components in this network -->
		<Components>
			<Object
				Name       = "_base"
				GUID       = "{82C9CFC7-A95F-4E8F-8636-81EF8978F2E7}"
				Class      = "SdiasBase"
				Position   = "(218,120)"
				Visualized = "true">
				<Channels>
					<Server Name="ClassState"/>
					<Server Name="DeviceID"/>
					<Server Name="FPGAVersion"/>
					<Server Name="HwVersion"/>
					<Server Name="LEDControl" Value="0"/>
					<Server Name="RetryCounter"/>
					<Server Name="SDOState"/>
					<Server Name="SerialNo"/>
					<Client Name="Place" Value="0"/>
					<Client Name="Required" Value="1"/>
					<Client Name="SdiasIn"/>
					<Client Name="ToStdLib"/>
				</Channels>
			</Object>
		</Components>
		<Comments>
		</Comments>
		<!-- List of Connections in this network -->
		<Connections>
			<Connection Source="this.ClassState" Destination="_base.ClassState" Vertices="(804,210),(632,210),"/>
			<Connection Source="this.DeviceID" Destination="_base.DeviceID" Vertices="(804,270),(632,270),"/>
			<Connection Source="this.SerialNo" Destination="_base.SerialNo" Vertices="(804,450),(632,450),"/>
			<Connection Source="this.RetryCounter" Destination="_base.RetryCounter" Vertices="(804,510),(632,510),"/>
			<Connection Source="this.LEDControl" Destination="_base.LEDControl" Vertices="(804,570),(632,570),"/>
			<Connection Source="_base.SdiasIn" Destination="this.SdiasIn" Vertices="(218,210),(38,210),"/>
			<Connection Source="_base.Place" Destination="this.Place" Vertices="(218,270),(38,270),"/>
			<Connection Source="_base.Required" Destination="this.Required" Vertices="(218,330),(38,330),"/>
			<Connection Source="this.FPGAVersion" Destination="_base.FPGAVersion" Vertices="(804,330),(632,330),"/>
			<Connection Source="this.HwVersion" Destination="_base.HwVersion" Vertices="(804,390),(632,390),"/>
		</Connections>
		<!-- Headerfiles -->
		<Options>
		</Options>
	</Network>
</Class>
*)
#pragma using SdiasBase

SR022 : CLASS
: SdiasBase
	TYPE
	  t_SR_StateInfo : BINT
	  [
	    1 bExternDCOKLatched,  //! <Type Comment="voltage ok bit" Name="t_SR_StateInfo.bExternDCOKLatched"/>
	    2 bWrongSequence,  //! <Type Comment="Wrong Sequence occured (forbidden Setting of the Output Sequence Bits)." Name="t_SR_StateInfo.bWrongSequence"/>
	    3 bAbsoluteTimeError,  //! <Type Comment="Absolute Time Error occurred (the absolute Time Values must rise on each Sequence)." Name="t_SR_StateInfo.bAbsoluteTimeError"/>
	    4 bMotorCurrentHighLatched,  //! <Type Comment="High Motor Current." Name="t_SR_StateInfo.bMotorCurrentHighLatched"/>
	    5 bMotorCurrentTooHighLatched,  //! <Type Comment="Motor Current too high (additional Periphery reset occurs)." Name="t_SR_StateInfo.bMotorCurrentTooHighLatched"/>
	    6 bPeripheryResetMotorLatched,  //! <Type Comment="Extern Supply for LEDs, Current measurement(OpAmp) is not OK" Name="t_SR_StateInfo.bPeripheryResetMotorLatched"/>
	    7 bInductionVoltageTooHighLatched,  //! <Type Comment="Motor Supply Voltage is not OK" Name="t_SR_StateInfo.bInductionVoltageTooHighLatched"/>
	    8 bOverTemp95CLatched,  //! <Type Comment="Periphery Reset occured on LED Device." Name="t_SR_StateInfo.bOverTemp95CLatched"/>
	    9 bi2tErrorLatched,
	    10 bDigIn1,
	    11 bDigIn2,  //! <Type Comment="Over temperature &gt;95°C" Name="t_SR_StateInfo.bDigIn2"/>
	    12 bDigIn3,
	    13 bZeroPosition,  //! <Type Comment="I²T Error occured" Name="t_SR_StateInfo.bZeroPosition"/>
	    14 bZeroPositionLatch,
	  ];
#pragma pack(push, 1)
	  t_s_ReadData : STRUCT  //! <Type Comment="Cyclic read memory space." Name="t_s_ReadData"/>
	    biStatus : t_SR_StateInfo;  //! <Type Comment="Hardware Status Register" Name="t_s_ReadData.biStatus"/>
	    IncEncCount : INT;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_s_ReadDataExtended : STRUCT
	    IncEncCountLatch : INT;
	    uiTemperature : UINT;
	    iActCurrent : INT;
	    Status : t_b_SdiasFWState;
	    I2TValue : UDINT;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_s_ExtendedAccess : STRUCT
	    DefaultAccess : t_s_ReadData;
	    ExtendedAccess : t_s_ReadDataExtended;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_s_ControlAccess : STRUCT
	    AccessHandle : UDINT;
	    pControlByte : t_SDIAS_pControlByte;
	    pStateByte : t_SDIAS_pStateByte;
	  END_STRUCT;
#pragma pack(pop)
	  t_bi_SeqData : BINT  //! <Type Comment="Sequence Data." Name="t_bi_SeqData"/>
	  [
	    1 bTimeBit0,  //! <Type Comment="Sequence time value (11 Bits)." Name="t_bi_SeqData.bTimeBit0"/>
	    2 bTimeBit1,  //! <Type Comment="Sequence time value (11 Bits)." Name="t_bi_SeqData.bTimeBit1"/>
	    3 bTimeBit2,  //! <Type Comment="Sequence time value (11 Bits)." Name="t_bi_SeqData.bTimeBit2"/>
	    4 bTimeBit3,  //! <Type Comment="Sequence time value (11 Bits)." Name="t_bi_SeqData.bTimeBit3"/>
	    5 bTimeBit4,  //! <Type Comment="Sequence time value (11 Bits)." Name="t_bi_SeqData.bTimeBit4"/>
	    6 bTimeBit5,  //! <Type Comment="Sequence time value (11 Bits)." Name="t_bi_SeqData.bTimeBit5"/>
	    7 bTimeBit6,  //! <Type Comment="Sequence time value (11 Bits)." Name="t_bi_SeqData.bTimeBit6"/>
	    8 bTimeBit7,  //! <Type Comment="Sequence time value (11 Bits)." Name="t_bi_SeqData.bTimeBit7"/>
	    9 bTimeBit8,  //! <Type Comment="Sequence time value (11 Bits)." Name="t_bi_SeqData.bTimeBit8"/>
	    10 bTimeBit9,  //! <Type Comment="Sequence time value (11 Bits)." Name="t_bi_SeqData.bTimeBit9"/>
	    11 bTimeBit10,  //! <Type Comment="Sequence time value (11 Bits)." Name="t_bi_SeqData.bTimeBit10"/>
	    12 bTimeCount,  //! <Type Comment="0 = take relative Time Counter&#13;&#10;1 = take absolute Time Counter            &#13;&#10;" Name="t_bi_SeqData.bTimeCount"/>
	    13 bLeftHigh,  //! <Type Comment="H-bridge element." Name="t_bi_SeqData.bLeftHigh"/>
	    14 bRightHigh,  //! <Type Comment="H-bridge element." Name="t_bi_SeqData.bRightHigh"/>
	    15 bLeftLow,  //! <Type Comment="H-bridge element." Name="t_bi_SeqData.bLeftLow"/>
	    16 bRightLow,  //! <Type Comment="H-bridge element." Name="t_bi_SeqData.bRightLow"/>
	  ];
#pragma pack(push, 1)
	  t_s_WriteData : STRUCT  //! <Type Comment="Cyclic configuration information for hardware." Name="t_s_WriteData"/>
	    bsControl : BSINT  //! <Type Comment="Hardware Control Register." Name="t_s_WriteData.bsControl"/>
	    [
	      1 bSeqEnable,  //! <Type Comment="Sequencer enable" Name="t_s_WriteData.bsControl.bSeqEnable"/>
	      4 bQuitWrongSequence,  //! <Type Comment="Enable latched High Motor Current." Name="t_s_WriteData.bsControl.bQuitWrongSequence"/>
	      5 bOverTemperatureSwOffEn,  //! <Type Comment="Enable latched Motor Current too high." Name="t_s_WriteData.bsControl.bOverTemperatureSwOffEn"/>
	      6 bQuitOverTemperatureError,  //! <Type Comment="Enable latched DC (Extern Supply for LEDs, Current Measurement(OpAmp))." Name="t_s_WriteData.bsControl.bQuitOverTemperatureError"/>
	      7 bI2tSwOffEn,  //! <Type Comment="Enable latched DC Motor." Name="t_s_WriteData.bsControl.bI2tSwOffEn"/>
	      8 bQuitI2tError,  //! <Type Comment="Enable latched Periphery Reset LED." Name="t_s_WriteData.bsControl.bQuitI2tError"/>
	    ];
	    sSeqData2 : t_bi_SeqData;  //! <Type Comment="Sequencer 2 Data" Name="t_s_WriteData.sSeqData2"/>
	    sSeqData4 : t_bi_SeqData;  //! <Type Comment="Sequencer 4 Data" Name="t_s_WriteData.sSeqData4"/>
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_Accesses : STRUCT
	    pReadData : ^t_s_ReadData;
	    pReadDataExtended : ^t_s_ExtendedAccess;
	    sReadDataExtendedControl : t_s_ControlAccess;
	    pWriteData : ^t_s_WriteData;
	    sWriteData : t_s_WriteData;
	  END_STRUCT;
#pragma pack(pop)
	  t_e_CyclicSDORead :
	  (
	    _SDOIdle,
	    _SDOReadData,
	    _SDOWaitTime
	  )$UDINT;
	  t_e_InitSSW :  //! <Type Comment="State definition for Initialization." Name="t_e_InitSSW"/>
	  (
	    Init_Variables,  //! <Type Comment="Initialize default value." Name="t_e_InitSSW.Init_Variables"/>
	    Init_Firmware,  //! <Type Comment="SDO write access to firmware (writes config data)." Name="t_e_InitSSW.Init_Firmware"/>
	    Init_GetStateFW,  //! <Type Comment="SDO read access to firmware (read status data)." Name="t_e_InitSSW.Init_GetStateFW"/>
	    Init_ConfigModule,  //! <Type Comment="SDO write access to CPLD (writes config data)." Name="t_e_InitSSW.Init_ConfigModule"/>
	    Init_ConfigSequencer,
	    Init_ReadSDOData,
	    Init_ReadSDOSequ,
	    Init_QuitError,
	    Init_Finish,  //! <Type Comment="Finish initialization." Name="t_e_InitSSW.Init_Finish"/>
	    Init_Error  //! <Type Comment="Error in initialization." Name="t_e_InitSSW.Init_Error"/>
	  )$UDINT;
#pragma pack(push, 1)
	  t_s_DCSequencer1234 : STRUCT
	    Seq1 : t_bi_SeqData;
	    Seq2 : t_bi_SeqData;
	    Seq3 : t_bi_SeqData;
	    Seq4 : t_bi_SeqData;
	    uiPeriodeTime : UINT;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_s_FWConfiguration : STRUCT  //! <Type Comment="Configuration Data of from HW-Class to Firmware." Name="t_s_FWConfiguration"/>
	    hCRC : HINT;  //! <Type Comment="Checksum of Datablock" Name="t_s_FWConfiguration.hCRC"/>
	    uDataLength : UINT;  //! <Type Comment="Length of Datablock&#13;&#10;" Name="t_s_FWConfiguration.uDataLength"/>
	    Info : BSINT  //! <Type Comment="Info (Special-Purpose / Statusbits)" Name="t_s_FWConfiguration.Info"/>
	    [
	      1 PMBModus,  //! <Type Comment="Mode for Firmware&#13;&#10;&#13;&#10;0 = standard Mode&#13;&#10;1 = PMB Mode" Name="t_s_FWConfiguration.Info.PMBModus"/>
	      2 BootLoaderUpdateRequest,  //! <Type Comment="Update request for bootloader." Name="t_s_FWConfiguration.Info.BootLoaderUpdateRequest"/>
	    ];
	    Reserved : USINT;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_s_FWState : STRUCT  //! <Type Comment="Configuration Data of from Firmware to HW-Class." Name="t_s_FWState"/>
	    hCRC : HINT;  //! <Type Comment="Checksum of Datablock" Name="t_s_FWState.hCRC"/>
	    uDataLength : UINT;  //! <Type Comment="Length of Datablock" Name="t_s_FWState.uDataLength"/>
	    hFWVersion : HINT;  //! <Type Comment="Firmware Verion." Name="t_s_FWState.hFWVersion"/>
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_s_SDO_Control : STRUCT
	    udI2tTreshold : UDINT;
	    biControlReg : BINT
	    [
	      1 res1,
	      2 TTL_RS422_Mode,
	      3 InvertZeroPosition,
	      4 PhaseBInverted,
	      5 EdgeSamplingBit0,  //! <Type Comment="   00: not active&#13;&#10;   01: rising edge&#13;&#10;   10: falling edge&#13;&#10;   11: both edges&#13;&#10;" Name="t_s_SDO_Control.biControlReg.EdgeSamplingBit0"/>
	      6 EdgeSamplingBit1,  //! <Type Comment="   00: not active&#13;&#10;   01: rising edge&#13;&#10;   10: falling edge&#13;&#10;   11: both edges&#13;&#10;" Name="t_s_SDO_Control.biControlReg.EdgeSamplingBit1"/>
	      7 ABCountMode,
	      8 res2,
	      9 InputLatch5VBit0,  //! <Type Comment="   00: not active&#13;&#10;   01: rising edge&#13;&#10;   10: falling edge&#13;&#10;   11: both edges&#13;&#10;" Name="t_s_SDO_Control.biControlReg.InputLatch5VBit0"/>
	      10 InputLatch5VBit1,  //! <Type Comment="   00: not active&#13;&#10;   01: rising edge&#13;&#10;   10: falling edge&#13;&#10;   11: both edges&#13;&#10;" Name="t_s_SDO_Control.biControlReg.InputLatch5VBit1"/>
	      11 ZPulsLatchBit0,  //! <Type Comment="   00: not active&#13;&#10;   01: rising edge&#13;&#10;   10: falling edge&#13;&#10;   11: both edges&#13;&#10;" Name="t_s_SDO_Control.biControlReg.ZPulsLatchBit0"/>
	      12 ZPulsLatchBit1,  //! <Type Comment="   00: not active&#13;&#10;   01: rising edge&#13;&#10;   10: falling edge&#13;&#10;   11: both edges&#13;&#10;" Name="t_s_SDO_Control.biControlReg.ZPulsLatchBit1"/>
	      13 Bit13,
	      14 Bit14,
	      15 Bit15,
	      16 Bit16,
	    ];
	    aReserved : ARRAY [0..1] OF USINT;
	    DC_Sequencer : t_s_DCSequencer1234;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_s_SDO_Read_Cyclic : STRUCT
	    IncEncLatchedValue : UINT;
	    uiTemperature : UINT;
	    iActCurrent : INT;
	    Status : t_b_SdiasFWState;
	    I2TValue : DINT;
	    SDOControlRead : t_s_SDO_Control;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_s_SeqData24 : STRUCT
	    Seq2 : t_bi_SeqData;
	    Seq4 : t_bi_SeqData;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_SR_Fw_State : STRUCT  //! <Type Public="true" Name="t_SR_Fw_State"/>
	    biFWErrorBits : t_b_SdiasFWState;
	    biErrorState : BINT
	    [
	      1 bExternDCNotOKLatched,
	      2 bWrongSequence,
	      3 bAbsoluteTimeError,
	      4 bMotorCurrentHighLatched,
	      5 bMotorCurrentTooHighLatched,
	      6 bPeripheryResetMotorLatched,
	      7 bInductionVoltageTooHighLatched,
	      8 bOverTemp95CLatched,
	      9 bi2tErrorLatched,
	      10 Bit10,
	      11 Bit11,
	      12 Bit12,
	      13 Bit13,
	      14 Bit14,
	      15 Bit15,
	      16 Bit16,
	    ];
	  END_STRUCT;
#pragma pack(pop)
	END_TYPE
  //Servers:
	FirmwareVersion 	: SvrCh_HDINT;
	ErrorBits 	: SvrCh_t_SR_Fw_State_PTofCls_SR022;
	Enable 	: SvrCh_DINT;
	SetSpeed 	: SvrCh_DINT;
	MinPulse 	: SvrCh_DINT;
	MotorCurrent 	: SvrCh_DINT;
	Temperature 	: SvrCh_DINT;
	I2T 	: SvrCh_UDINT;
	ErrorQuit 	: SvrCh_DINT;
	Position 	: SvrCh_DINT;
	PositionLatch 	: SvrCh_DINT;
	ZPuls 	: SvrCh_DINT;
	ZPulsLatched 	: SvrCh_DINT;
	Input1 	: SvrCh_DINT;
	Input2 	: SvrCh_DINT;
	Input3 	: SvrCh_DINT;
	VoltageOkMotor 	: SvrCh_DINT;
  //Clients:
	PWMPeriod 	: CltCh_UDINT;
	I2TThreshold 	: CltCh_UDINT;
	EncMode 	: CltCh_DINT;
	EncSampling 	: CltCh_DINT;
	EncDirection 	: CltCh_DINT;
	InvertZeroPosition 	: CltCh_DINT;
	ABCountMode 	: CltCh_DINT;
	ExtendedData 	: CltCh_DINT;
  //Variables:
		sAccesses 	: t_Accesses;
		eInitSSW 	: t_e_InitSSW;			//! <Variable Comment="State of the initialization." Name="eInitSSW"/>
		eInitSSWErrorStep 	: t_e_InitSSW;			//! <Variable Comment="Stores the init state in case of an error." Name="eInitSSWErrorStep"/>
		eResponseState 	: t_ResponseInfo;			//! <Variable Comment="SDO response state" Name="eResponseState"/>
		sFWConfiguration 	: t_s_FWConfiguration;
		sConfiguration 	: t_s_SDO_Control;			//! <Variable Comment="Memory area for SDO communication." Name="sConfiguration"/>
		sFWState 	: t_s_FWState;			//! <Variable Comment="Memory area for data transfer from firmware to software." Name="sFWState"/>
		udSDOTimeout 	: UDINT;			//! <Variable Comment="Used to detect a SDO response timeout." Name="udSDOTimeout"/>
		udSDOCyclicTimeout 	: UDINT;
		uiPeriodCount 	: UINT;			//! <Variable Comment="Sequencer period length (FPGA clock * PWM Period of sequencer)." Name="uiPeriodCount"/>
		uiTimeMin 	: UINT;			//! <Variable Comment="Minimum sequence period" Name="uiTimeMin"/>
		bUpdateSeqData 	: BOOL;
		sSeqData 	: t_s_SeqData24;
		iEncoderValueBinary 	: INT;
		iLatchValueBinary 	: INT;
		bsLatchReaded : BSINT
		[
		  1 ZPos,
		];

		sReadSDOConfData 	: t_s_SDO_Read_Cyclic;
  //Functions:
				//! <Function Comment="Constructor of Class." Name="SR022"/>
	FUNCTION SR022
		VAR_OUTPUT
			ret_code 	: ConfStates;
		END_VAR;
				//! <Function Comment="Realtime Update Methode which runs in PreScan." Name="UpdateRt"/>
	FUNCTION VIRTUAL GLOBAL UpdateRt;
				//! <Function Comment="Realtime Update Methode which runs in PostScan." Name="UpdateRtPostScan"/>
	FUNCTION VIRTUAL GLOBAL UpdateRtPostScan;
	
	FUNCTION VIRTUAL GLOBAL AddAccesses
		VAR_OUTPUT
			eModuleInitState 	: iprStates;
		END_VAR;
				//! <Function Comment="Methode is called if this Module gets connected." Name="ConnectEvent"/>
	FUNCTION VIRTUAL GLOBAL ConnectEvent;
				//! <Function Comment="Methode is called if this Module gets disconnected." Name="DisconnectEvent"/>
	FUNCTION VIRTUAL GLOBAL DisconnectEvent;
				//! <Function Comment="Methode should be used to run a Statemachine to Initialize the Module." Name="InitModule"/>
	FUNCTION VIRTUAL GLOBAL InitModule
		VAR_OUTPUT
			eModuleInitState 	: iprStates;			//! <Variable Comment="Return BUSY until the Initialisation is finished." Name="InitModule.eModuleInitState"/>
		END_VAR;
				//! <Function Comment="This Methode should be used, to check the DeviceID of the Module." Name="CheckDeviceID"/>
	FUNCTION VIRTUAL GLOBAL CheckDeviceID
		VAR_INPUT
			udID2Check 	: UDINT;			//! <Variable Comment="Device ID of connected Module." Name="CheckDeviceID.udID2Check"/>
		END_VAR
		VAR_OUTPUT
			bIsOK 	: BOOL;			//! <Variable Comment="FALSE = Wrong DeviceID for Module&#13;&#10;TRUE  = DeviceID of Module is correct" Name="CheckDeviceID.bIsOK"/>
		END_VAR;
				//! <Function Comment="Methode to receive the Response in case of SDO-Communication." Name="ReceiveSDOResponse"/>
	FUNCTION VIRTUAL ReceiveSDOResponse
		VAR_INPUT
			eCommand 	: t_SDIAS_SDO_Cmd;			//! <Variable Comment="Type of SDO-Command" Name="ReceiveSDOResponse.eCommand"/>
			hOffset 	: HINT;			//! <Variable Comment="Address-Offset in Module." Name="ReceiveSDOResponse.hOffset"/>
			usLength 	: USINT;			//! <Variable Comment="Length of Data." Name="ReceiveSDOResponse.usLength"/>
			eResult 	: iprStates;			//! <Variable Comment="State of SDO-Communication." Name="ReceiveSDOResponse.eResult"/>
			pResponseBuffer 	: ^USINT;			//! <Variable Comment="Pointer of ResponseBuffer, where the SDO-Data is located." Name="ReceiveSDOResponse.pResponseBuffer"/>
			ResponseLength 	: USINT;			//! <Variable Comment="Size of the ResponseBuffer." Name="ReceiveSDOResponse.ResponseLength"/>
		END_VAR
		VAR_OUTPUT
			ret_code 	: iprStates;			//! <Variable Comment="Indicates if the Methode was successful." Name="ReceiveSDOResponse.ret_code"/>
		END_VAR;
	
	FUNCTION VIRTUAL GetTaskCfg
		VAR_OUTPUT
			TaskCfg 	: BDINT;			//! <Variable Comment="Select which tasks will be available for this module:&#13;&#10;Bit0..Realtime PreScan&#13;&#10;Bit1..Realtime PostScan&#13;&#10;Bit2..Cyclic&#13;&#10;&#13;&#10;e.g. if only realtime postscan is needed:&#13;&#10;2#010" Name="GetTaskCfg.TaskCfg"/>
		END_VAR;
	
	FUNCTION VIRTUAL GetDeviceID
		VAR_OUTPUT
			output 	: UDINT;
		END_VAR;
	
	FUNCTION VIRTUAL GetFWVersion
		VAR_INPUT
			pData 	: ^CHAR;
			Length 	: UDINT;
		END_VAR;
				//! <Function Comment="Methode to calculate PWM-Signal depending on Speed." Name="CalculatePWM"/>
	FUNCTION CalculatePWM;
	
	FUNCTION SDOReadInfoData
		VAR_INPUT
			ReadSector 	: DINT;
		END_VAR
		VAR_OUTPUT
			RetCode 	: iprStates;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL Enable::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL SetSpeed::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL MinPulse::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL ErrorQuit::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL ZPulsLatched::Read
		VAR_OUTPUT
			output (EAX) 	: DINT;
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

//}}LSL_DECLARATION


FUNCTION GLOBAL TAB SR022::@CT_
0$UINT,
2#0100000000000000$UINT, //TY_SR022
1$UINT, 2$UINT, (SIZEOF(::SR022))$UINT, 
17$UINT, 8$UINT, 0$UINT, 
TO_UDINT(3646514510), "SR022", //Class
TO_UDINT(3175101883), "SdiasBase", 1$UINT, 58$UINT, //Baseclass
//Servers:
(::SR022.FirmwareVersion.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(389440282), "FirmwareVersion", 
(::SR022.ErrorBits.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(259769398), "ErrorBits", 
(::SR022.Enable.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(56102836), "Enable", 
(::SR022.SetSpeed.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(33026088), "SetSpeed", 
(::SR022.MinPulse.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(421244052), "MinPulse", 
(::SR022.MotorCurrent.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1218745960), "MotorCurrent", 
(::SR022.Temperature.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(860731524), "Temperature", 
(::SR022.I2T.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(24948417), "I2T", 
(::SR022.ErrorQuit.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(971218924), "ErrorQuit", 
(::SR022.Position.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2149546169), "Position", 
(::SR022.PositionLatch.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(801812501), "PositionLatch", 
(::SR022.ZPuls.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3142960073), "ZPuls", 
(::SR022.ZPulsLatched.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3904789169), "ZPulsLatched", 
(::SR022.Input1.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1344628668), "Input1", 
(::SR022.Input2.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3375117830), "Input2", 
(::SR022.Input3.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3190490768), "Input3", 
(::SR022.VoltageOkMotor.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(4002343342), "VoltageOkMotor", 
//Clients:
(::SR022.PWMPeriod.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(1793508181), "PWMPeriod", 
(::SR022.I2TThreshold.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(1599586102), "I2TThreshold", 
(::SR022.EncMode.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(558217510), "EncMode", 
(::SR022.EncSampling.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(826259315), "EncSampling", 
(::SR022.EncDirection.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(3190248247), "EncDirection", 
(::SR022.InvertZeroPosition.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(2091988656), "InvertZeroPosition", 
(::SR022.ABCountMode.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(4170972889), "ABCountMode", 
(::SR022.ExtendedData.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(4043669436), "ExtendedData", 
END_FUNCTION


#define USER_CNT_SR022 20

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_SR022] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION SR022::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
		nCmdSize	: UINT;
	END_VAR

	ret_code	:= SdiasBase::@STD();
	IF ret_code <> C_OK THEN
		RETURN;
	END_IF;
	nCmdSize		:= SdiasBase::ClassState.pMeth^.nCmds$UINT*SIZEOF(pVoid) + CMDMETH.Init;

	_memcpy((#vmt.CmdTable)$^USINT, SdiasBase::ClassState.pMeth, nCmdSize);
	vmt.CmdTable.nCmds		:= nSTDCMD + USER_CNT_SR022;
#pragma warning (disable : 74)
	vmt.UserFcts[0]		:= #UpdateRt();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[1]		:= #UpdateRtPostScan();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[4]		:= #AddAccesses();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[5]		:= #ConnectEvent();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[6]		:= #DisconnectEvent();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[7]		:= #InitModule();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[8]		:= #CheckDeviceID();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[9]		:= #ReceiveSDOResponse();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[13]		:= #GetTaskCfg();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[14]		:= #GetDeviceID();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[15]		:= #GetFWVersion();

#pragma warning (default : 74)
	SdiasBase::ClassState.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF SdiasBase::ClassState.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	Enable.pMeth			:= StoreMethod( #M_RD_DIRECT(), #Enable::Write() );
	IF Enable.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	SetSpeed.pMeth			:= StoreMethod( #M_RD_DIRECT(), #SetSpeed::Write() );
	IF SetSpeed.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	MinPulse.pMeth			:= StoreMethod( #M_RD_DIRECT(), #MinPulse::Write() );
	IF MinPulse.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	ErrorQuit.pMeth			:= StoreMethod( #M_RD_DIRECT(), #ErrorQuit::Write() );
	IF ErrorQuit.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	Position.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF Position.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	ZPulsLatched.pMeth			:= StoreMethod( #ZPulsLatched::Read(), #M_NO_F() );
	IF ZPulsLatched.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	ret_code	:= SR022();

END_FUNCTION

//{{LSL_IMPLEMENTATION
FUNCTION VIRTUAL GLOBAL SR022::UpdateRt
VAR
	TempReadData : t_s_ExtendedAccess;
END_VAR
  
  //Read Information from DPRam
  if ExtendedData = 0 then
    TempReadData.DefaultAccess := sAccesses.pReadData^;
  else
    TempReadData  := sAccesses.pReadDataExtended^;
  end_if;

  // dc motor drive
  //*************************************************************************************
  VoltageOkMotor  := TempReadData.DefaultAccess.biStatus.bExternDCOKLatched;
  //Error Info
  ErrorBits.biErrorState := TempReadData.DefaultAccess.biStatus and 0x1FF;
  ErrorBits.biErrorState.bExternDCNotOKLatched := ErrorBits.biErrorState.bExternDCNotOKLatched XOR 1;
  
  if ExtendedData then
    //I²T 
    I2T         := TempReadData.ExtendedAccess.I2TValue AND 16#001FFFFF;    
    //Temperature Informations
    //value is as C° with SHR 4");
    Temperature := TempReadData.ExtendedAccess.uiTemperature SHR 4;
    //Motor Current
    //----------------------------------------------
    //Only in Enable Status and no PeripheryReset of Motor or LED
    if Enable & SetSpeed & (TempReadData.DefaultAccess.biStatus.bPeripheryResetMotorLatched = FALSE) then
      //Actual Motor Current
      MotorCurrent := TempReadData.ExtendedAccess.iActCurrent;      
    else
      //Don't show a MotorCurrent
      MotorCurrent := 0;
    end_if;    
  end_if;  
  
  //Disable
  if TempReadData.DefaultAccess.biStatus.bInductionVoltageTooHighLatched | 
     TempReadData.DefaultAccess.biStatus.bMotorCurrentTooHighLatched     |
     TempReadData.DefaultAccess.biStatus.bOverTemp95CLatched             |
     TempReadData.DefaultAccess.biStatus.bi2tErrorLatched                |
     (TempReadData.DefaultAccess.biStatus.bExternDCOKLatched = FALSE)     then
    Enable.Write(0);
  end_if;      
  
  // encoder mode
  //*************************************************************************************
  //Check for invers Mode
  if EncMode then
    if EncDirection then    
      if ExtendedData then        
        //LatchPosition 
        if (TempReadData.ExtendedAccess.IncEncCountLatch <> iLatchValueBinary) | (TempReadData.DefaultAccess.biStatus.bZeroPositionLatch) then
          
          //Check Moving Direction
          PositionLatch := Position + to_int(iEncoderValueBinary - TempReadData.ExtendedAccess.IncEncCountLatch);
          
          //Save binary Latch Value
          iLatchValueBinary := TempReadData.ExtendedAccess.IncEncCountLatch;          
        end_if;        
      end_if;
    
      //to_int() is done for Overflow Handling
      Position -= to_int(TempReadData.DefaultAccess.IncEncCount - iEncoderValueBinary);   
      
    else     
      if ExtendedData then        
        //LatchPosition 
        if (TempReadData.ExtendedAccess.IncEncCountLatch <> iLatchValueBinary) | (TempReadData.DefaultAccess.biStatus.bZeroPositionLatch) then
          
          //Check Moving Direction
          PositionLatch := Position - to_int(iEncoderValueBinary - TempReadData.ExtendedAccess.IncEncCountLatch);
          
          //Save binary Latch Value
          iLatchValueBinary := TempReadData.ExtendedAccess.IncEncCountLatch;          
        end_if;        
      end_if;
      
      //to_int() is done for Overflow Handling
      Position += to_int(TempReadData.DefaultAccess.IncEncCount - iEncoderValueBinary);
    end_if;
    
    //Remember actual Encoder Value
    iEncoderValueBinary := TempReadData.DefaultAccess.IncEncCount;  
        
    //ZPulse
    ZPuls := TempReadData.DefaultAccess.biStatus.bZeroPosition;
    
    //ZPulse latched
    if ( TempReadData.DefaultAccess.biStatus.bZeroPositionLatch ) | bsLatchReaded.ZPos then
      bsLatchReaded.ZPos := FALSE;
      ZPulsLatched       := TempReadData.DefaultAccess.biStatus.bZeroPositionLatch; //Reset of Bit is done with Read-Access
    end_if;   
  end_if;
  
  //read input value 1 - 3
  Input1 := TempReadData.DefaultAccess.biStatus.bDigIn1;
  Input2 := TempReadData.DefaultAccess.biStatus.bDigIn2;
  Input3 := TempReadData.DefaultAccess.biStatus.bDigIn3;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL SR022::UpdateRtPostScan
  
  if bUpdateSeqData then
    sAccesses.sWriteData.sSeqData2 := sSeqData.Seq2;
    sAccesses.sWriteData.sSeqData4 := sSeqData.Seq4;  
    bUpdateSeqData := FALSE;
  end_if;

  //Write to DPRam
  sAccesses.pWriteData^ := sAccesses.sWriteData;
    
  //Check for Change PostScan-Data
  if ErrorQuit then
    //Reset Quit Error Bits (we quit only once) => don't check the actual state of the bit to save time
    sAccesses.sWriteData.bsControl.bQuitOverTemperatureError := FALSE;
    sAccesses.sWriteData.bsControl.bQuitI2tError             := FALSE;    
    ErrorQuit := 0;
  end_if;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL SR022::ConnectEvent
  
  //Read Access
  if ExtendedData = 0 then  
    if DefaultAccesses.ReadAccess.pControlByte then
      sAccesses.pReadData := DefaultAccesses.ReadAccess.pData$^t_s_ReadData;

      //Start Read-Access to Module (Set ControlWord in DPRam)
      DefaultAccesses.ReadAccess.pControlByte^.EnableDO := true;
    else
      //No ControlWord available
      eInitState := _DOHandleInvalid;
      return;
    end_if;  
  else
    if sAccesses.sReadDataExtendedControl.pControlByte then
      //Start Read-Access to Module (Set ControlWord in DPRam)
      sAccesses.sReadDataExtendedControl.pControlByte^.EnableDO := true;
    else
      //No ControlWord available
      eInitState := _DOHandleInvalid;
      return;
    end_if;    
  end_if;
  
  //Write Access
  if DefaultAccesses.WriteAccess.pControlByte then
    sAccesses.pWriteData := DefaultAccesses.WriteAccess.pData$^t_s_WriteData;

    //Start Write-Access to Module (Set ControlWord in DPRam)
    DefaultAccesses.WriteAccess.pControlByte^.EnableDO := true;
  else  
    //No ControlWord available
    eInitState := _DOHandleInvalid;
    return;
  end_if;

  //Reset Statemachines
  eInitSSW       := Init_Variables;
  eResponseState := idle;
  eInitState    := _NotInitialized;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL SR022::DisconnectEvent
  
  //Reset DO-Data
  if sAccesses.pWriteData then
    _memset(dest := sAccesses.pWriteData, usByte := 0, cntr := sizeof(t_s_WriteData));
  end_if;

  //Call Disconnect of Base-Class
  SdiasBase::DisconnectEvent();

END_FUNCTION


FUNCTION VIRTUAL GLOBAL SR022::SetSpeed::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

  //Check for Change
  if SetSpeed <> input then
  
    //Limit Input
    //------------------------------------------
    if input < 0 then      
      //Negative Direction
      if input < -SR022_SPEED_SCALING then
        SetSpeed := -SR022_SPEED_SCALING;
      else
        SetSpeed := input;
      end_if;      
    //Positive Direction
    else    
      //Negative Direction
      if input > SR022_SPEED_SCALING then
        SetSpeed := SR022_SPEED_SCALING;
      else
        SetSpeed := input;
      end_if;      
    end_if;
    //Calculate PWM-Signal
    CalculatePWM();    
  end_if;
      
  result := SetSpeed;
  
END_FUNCTION


FUNCTION VIRTUAL GLOBAL SR022::Enable::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

  //Check for Change
  if Enable <> input then  
    //Save Input
    Enable := input;    
    //Enable
    if Enable then    
      //Check Error
      if (ErrorBits.biErrorState.bMotorCurrentTooHighLatched = FALSE) & 
         (ErrorBits.biErrorState.bInductionVoltageTooHighLatched = FALSE) then
        Enable := 1;
      else
        Enable := 0;
      end_if;    
    else
    //Disable    
      //Reset Speed
      SetSpeed.Write(0);
    end_if;
    
    //Update Enable bit in control word
    sAccesses.sWriteData.bsControl.bSeqEnable := to_bool(Enable);    
  end_if;

  result := Enable;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL SR022::MinPulse::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

  //Check for Change
  if input <> MinPulse then
    
    //Limitation of Value
    if ( input > SR022_MINPULSE_SCALING ) then
      input := SR022_MINPULSE_SCALING;
    elsif ( input < 0 ) then
      input := 0;
    end_if;
    
    //Save Input
    MinPulse := input;

    //Calculate minimum Timelength of Pulse
    uiTimeMin := to_uint( ( MinPulse * uiPeriodCount )$UDINT / SR022_MINPULSE_SCALING );
  
    //new Calculation of PWM
    if Enable then
      CalculatePWM();
    end_if;
  end_if;

 	result := MinPulse;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL SR022::ErrorQuit::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR
  
  if input then    
    // reset all error bits. if there's still an error, they will appear in next realtime.
    ErrorBits.biErrorState := 0;
  end_if;

  // I²T Error Quit
  sAccesses.sWriteData.bsControl.bQuitI2tError := input <> 0;
  
  // Overtemperature Error Quit
  sAccesses.sWriteData.bsControl.bQuitOverTemperatureError := input <> 0;

  //Save Quit last because we reset the server in UpdateRtPostScan
  ErrorQuit := input;
	result := ErrorQuit;

END_FUNCTION


FUNCTION SR022::SR022
	VAR_OUTPUT
		ret_code 	: ConfStates;
	END_VAR
  
	ret_code := C_OK;

END_FUNCTION


FUNCTION VIRTUAL SR022::ReceiveSDOResponse
	VAR_INPUT
		eCommand 	: t_SDIAS_SDO_Cmd;
		hOffset 	: HINT;
		usLength 	: USINT;
		eResult 	: iprStates;
		pResponseBuffer 	: ^USINT;
		ResponseLength 	: USINT;
	END_VAR
	VAR_OUTPUT
		ret_code 	: iprStates;
	END_VAR
  
  //Call Response of Base-Class
  ret_code := SdiasBase::ReceiveSDOResponse(eCommand        := eCommand, 
                                            hOffset         := hOffset, 
                                            usLength        := usLength, 
                                            eResult         := eResult, 
                                            pResponseBuffer := pResponseBuffer, 
                                            ResponseLength  := ResponseLength);
    
  // spi access from baseclass                                         
  if bSDOResponseHandle = TRUE then
    return;
  end_if;  

  //Evaluate Result of SDO
  //----------------------------------------------------------------------------
  if eResult = READY then
    
    //Check Type of SDO-Command
    case eCommand of    
      //Memory Write
      //*****************************************************************************
      SDIAS_SDO_CMD_MEM_WRITE:      
        case hOffset of
          //*****************************************************************************
          SR022_ADDR_CFG_FIRMWARE:
            if eResponseState = wait then
              eResponseState := valid;
            end_if; 
            
          //*****************************************************************************
          SR022_ADDR_I2T_THRESHOLD:
            if eResponseState = wait then
              eResponseState := valid;
            end_if;
            
          //*****************************************************************************
          SR022_ADDR_DC_SEQUENCER:
            if eResponseState = wait then
              eResponseState := valid;
            end_if; 
            
        else
          LogError("@ZZZZ (SR022::ReceiveSDOResponse) Invalid Offset in Write-Response of SDO");
        
        end_case;
       
      //Memory Read
      //*****************************************************************************
      SDIAS_SDO_CMD_MEM_READ:      
        case hOffset of
          //*****************************************************************************
          SR022_ADDR_STATE_FIRMWARE:
            if eResponseState = wait then
              eResponseState := valid;
            end_if;
            sFWState := pResponseBuffer^$t_s_FWState;
            
          //*****************************************************************************
          SR022_ADDR_READ_SDO:
            if eResponseState = wait then
              eResponseState := valid;
            end_if;
            _memcpy(ptr1:=#sReadSDOConfData, ptr2:=pResponseBuffer, cntr:=t_s_SDO_Read_Cyclic.SDOControlRead.aReserved);
            
          //*****************************************************************************
          SR022_ADDR_DC_SEQUENCER:
            if eResponseState = wait then
              eResponseState := valid;
            end_if;
            _memcpy(ptr1:=#sReadSDOConfData.SDOControlRead.DC_Sequencer, ptr2:=pResponseBuffer, cntr:=sizeof(t_s_SDO_Read_Cyclic.SDOControlRead.DC_Sequencer));
                 
        //*****************************************************************************
        else
          LogError("@ZZZZ (SR022::ReceiveSDOResponse) Invalid Offset in Write-Response of SDO");
        
        end_case;        
    end_case;
    
    //Check if Class was in Valid State for SDO Response
    if eResponseState <> valid then
      LogError("@ZZZZ (SR022::ReceiveSDOResponse) Class in wrong State during Response of SDO");
      eInitSSW := Init_Error;      
    end_if;
    
    
  //Problem with Response
  //*****************************************************************************
  else
    
    //Check Type of SDO-Command to set correct Log-Message
    case eCommand of
    
      SDIAS_SDO_CMD_MEM_WRITE:
        LogError("@ZZZZ (SR022::ReceiveSDOResponse) Error while executing a sdo write-command");
      SDIAS_SDO_CMD_MEM_READ:
        LogError("@ZZZZ (SR022::ReceiveSDOResponse) Error while executing a sdo read-command");
        
    end_case;
    
    eInitSSW := Init_Error;
    
  end_if;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL SR022::InitModule
	VAR_OUTPUT
		eModuleInitState 	: iprStates;
	END_VAR
  VAR
  	TmpRetcode      : iprStates;
  END_VAR  
  
  //Init Returncode
  eModuleInitState := BUSY;  
  
  //*****************************************************************************
  //** STATEMACHINE FOR INITIALIZATION OF THE MODULE                           **
  //*****************************************************************************
  
  case eInitSSW of
  
    //Setting up Variables
    //*****************************************************************************
    Init_Variables:    
      //Read Clients
      EncMode             := EncMode.Read();
      EncDirection        := EncDirection.Read();
      InvertZeroPosition  := InvertZeroPosition.Read();
      ABCountMode         := ABCountMode.Read() <> 0;
      PWMPeriod := PWMPeriod.Read();
      
      //motor driver settings
      //**************************************************************************************
      //Calculate PeriodTime of FPGA
      uiPeriodCount           := to_uint(SR022_FPGA_FREQ_MHZ * PWMPeriod);
      sConfiguration.DC_Sequencer.uiPeriodeTime := uiPeriodCount + 2 * SR022_T_SWITCH;       
      
      //Sequences 1 + 3: used to switch between two active Sequences 2 + 4 => avoid ShortCircuit of H-Bridge
      //-----------------------------------------------------------------------------------------------------------
      sConfiguration.DC_Sequencer.Seq1$UINT        := SR022_T_SWITCH;     //Disable Time for switching between two active Phases
      sConfiguration.DC_Sequencer.Seq1.bTimeCount  := 0;                  //Relative Time
      sConfiguration.DC_Sequencer.Seq3$UINT        := SR022_T_SWITCH;     //Disable Time for switching between two active Phases
      sConfiguration.DC_Sequencer.Seq3.bTimeCount  := 0;                  //Relative Time
      
      //Sequency 2 + 4: used for controlling the dc-motor
      //-----------------------------------------------------------------------------------------------------------
      sConfiguration.DC_Sequencer.Seq2$UINT := ( SR022_GATE_A_LOW + SR022_GATE_B_LOW ) OR ( SR022_DEFAULT_SEQ_INIT AND SR022_MASK_CONTROL ) OR SR022_DEFAULT_SEQ_INIT;    //Init Value für Sequencer
      sConfiguration.DC_Sequencer.Seq2.bTimeCount := 0;      //Relative Time
      sConfiguration.DC_Sequencer.Seq4$UINT := ( SR022_GATE_A_LOW + SR022_GATE_B_LOW ) OR ( SR022_DEFAULT_SEQ_INIT AND SR022_MASK_CONTROL ) OR SR022_DEFAULT_SEQ_INIT;    //Init Value für Sequencer
      sConfiguration.DC_Sequencer.Seq4.bTimeCount := 0;      //Relative Time
      
      //ControlWord
      //--------------------------------------------------------
      sAccesses.sWriteData.bsControl.bSeqEnable                 := false;
      sAccesses.sWriteData.bsControl.bOverTemperatureSwOffEn    := true;
      sAccesses.sWriteData.bsControl.bI2tSwOffEn                := true; 
            
      //First Error-Quit
      sAccesses.sWriteData.bsControl.bQuitOverTemperatureError  := true;
      sAccesses.sWriteData.bsControl.bQuitI2tError              := true;
      
      // Reset Error Bits. These are set with |, => may retain false state after VARAN Dis/Reconnect 
      ErrorBits$UDINT := 0;

      //Calculate minimum Timelength of Pulse
      uiTimeMin := to_uint( ( MinPulse * uiPeriodCount )$UDINT / SR022_MINPULSE_SCALING );
      
      // set I²T Treshold 
      I2TThreshold := I2TThreshold.Read();
      if I2TThreshold > 100 then
        I2TThreshold := 100;
      end_if;

      sConfiguration.udI2tTreshold := SR022_I2T_THRESHOLD * I2TThreshold / 100;        
      
      //Set Configuration-Block of FW
      sFWConfiguration.Info         := 0;
      sFWConfiguration.uDataLength  := sizeof(sFWConfiguration) - sizeof(sFWConfiguration.hCRC) - sizeof(sFWConfiguration.uDataLength);
      sFWConfiguration.hCRC         := CheckSum_16( pData         := (#sFWConfiguration.Info)$^UINT, 
                                                    uiDataLength  := sFWConfiguration.uDataLength, 
                                                    uiCRCStart    := 16#FFFF);      
      //encoder settings
      //**************************************************************************************
      //Limit Encoder Sampling
      if ( EncSampling < 0 ) then
        EncSampling := 0;
      elsif ( EncSampling > 3 ) then
        EncSampling := 3;
      end_if;
      
      //Set Mode of Encoder
      case EncMode of
        SR022_NOENCODER:
        SR022_TTL_MODE:
          sConfiguration.biControlReg.TTL_RS422_Mode := 0;
        SR022_RS422_MODE:
          sConfiguration.biControlReg.TTL_RS422_Mode := 1; 
      else
        EncMode := 0;
        LogError("@ZZZZ (SR022::InitModule) Invalid mode for incremental encoder");
      end_case;      

      //Inversion of ZeroPosition
      sConfiguration.biControlReg.InvertZeroPosition := to_bool(InvertZeroPosition);
      
      //sampling of encoder
      sConfiguration.biControlReg.EdgeSamplingBit0 := to_bool(EncSampling and 1);
      sConfiguration.biControlReg.EdgeSamplingBit1 := to_bool((EncSampling shr 1) and 1);
      //set A/B count mode 
      sConfiguration.biControlReg.ABCountMode := ABCountMode$BOOL;
      
      if ExtendedData = 0 then
        //set server to invalid
        Temperature   := SR022_INVALID_VALUE;
        MotorCurrent  := SR022_INVALID_VALUE;
        I2T           := SR022_INVALID_VALUE;
        PositionLatch := SR022_INVALID_VALUE;
      end_if;
      
      //Next Step is to Initialize Firmware
      eInitSSW  := Init_Firmware;    
    
    //Initialize Firmware
    //*****************************************************************************
    Init_Firmware:    
      //Statemachine for SDO-Communication
      case eResponseState of
        //*****************************************************************************
        idle:        
          //Start SDO-Command
          tmpRetcode := StartWriteSDO(hOffset       := SR022_ADDR_CFG_FIRMWARE, 
                                      usLength      := sizeof(sFWConfiguration), 
                                      pWriteBuffer  := (#sFWConfiguration)$^USINT, 
                                      eCommand      := SDIAS_SDO_CMD_MEM_WRITE);
          
          //Evaluate Returncode
          if tmpRetcode = READY then            
            //Timestamp for TimeoutCheck
            udSDOTimeout    := ops.tAbsolute;
            eResponseState  := wait; 
          
          //Error occured  
          elsif tmpRetcode = ERROR then          
            eModuleInitState := ERROR;
            LogError("(@ZZZZ (SR022::InitModule) Failed to add write SDO for firmware configuration");
            eInitState := _NoMem;            
          end_if;
        
        //Wait for Response
        //*****************************************************************************
        wait:        
          //Timeout-Check
          if ((ops.tAbsolute - udSDOTimeout) > SR022_SDO_RESPONSE_TIMEOUT) then
            LogError("@ZZZZ (SR022::InitModule) SDO Response timeout config module");
            eInitSSWErrorStep  := eInitSSW;
            eInitSSW          := Init_Error;            
          end_if;
          
        //Response received
        //*****************************************************************************
        valid:          
          eInitSSW        := Init_GetStateFW;
          eResponseState  := idle;          
      end_case;    
      
    //Get Firmware Informations
    //*****************************************************************************
    Init_GetStateFW:

      //Statemachine for SDO-Communication
      case eResponseState of
        //*****************************************************************************
        idle:        
          //Start SDO-Command
          tmpRetcode := StartReadSDO( hOffset   := SR022_ADDR_STATE_FIRMWARE, 
                                      usLength  := sizeof(sFWState), 
                                      eCommand  := SDIAS_SDO_CMD_MEM_READ);
          
          //Evaluate Returncode
          if tmpRetcode = READY then            
            //Timestamp for TimeoutCheck
            udSDOTimeout    := ops.tAbsolute;
            eResponseState  := wait; 
          
          //Error occured  
          elsif tmpRetcode = ERROR then          
            eModuleInitState := ERROR;
            LogError("@ZZZZ (SR022::InitModule) Failed to add read SDO for firmware info");
            eInitState := _NoMem;            
          end_if;
        
        //Wait for Response
        //*****************************************************************************
        wait:        
          //Timeout-Check
          if ((ops.tAbsolute - udSDOTimeout) > SR022_SDO_RESPONSE_TIMEOUT) then          
            LogError("@ZZZZ (SR022::InitModule) SDO Response timeout read state");
            eInitSSWErrorStep  := eInitSSW;
            eInitSSW          := Init_Error;            
          end_if;
          
        //Response received
        //*****************************************************************************
        valid:        
          //Check Length of FirmwarePackage
          if ( sFWState.uDataLength = sizeof( sFWState ) - sizeof( sFWState.hCRC ) - sizeof( sFWState.uDataLength ) ) then          
            //Check CRC
            if (sFWState.hCRC = CheckSum_16( pData         := #sFWState.hFWVersion, 
                                            uiDataLength  := sFWState.uDataLength, 
                                            uiCrcStart    := 16#FFFF)) then              
              //Write Version of FW to Server
              FirmwareVersion := (sFWState.hFWVersion and 16#0000FFFF)$HDINT;
              //Next Step
              eResponseState   := idle;
              eInitSSW         := Init_ConfigModule;
            
            //Wrong CRC
            else            
              eInitState       := _ClientNotready;
              eModuleInitState := ERROR;
              LogError("@ZZZZ (SR022::InitModule) Invalid checksum at firmware info");              
            end_if;
          
          //Wrong Data-Length
          else          
            eInitState       := _ClientNotready;
            eModuleInitState := ERROR;
            LogError("@ZZZZ (SR022::InitModule) Invalid length at firmware info");            
          end_if;
      end_case;    
    
    //Write Configuration to Module
    //*****************************************************************************
    Init_ConfigModule:    
      //Statemachine for SDO-Communication
      case eResponseState of
        //*****************************************************************************
        idle:        
          //Start SDO-Command
          tmpRetcode := StartWriteSDO(hOffset       := SR022_ADDR_I2T_THRESHOLD, 
                                      usLength      := sizeof(sConfiguration)-sizeof(sConfiguration.DC_Sequencer)-sizeof(sConfiguration.aReserved), 
                                      pWriteBuffer  := (#sConfiguration)$^USINT, 
                                      eCommand      := SDIAS_SDO_CMD_MEM_WRITE);
          
          //Evaluate Returncode
          if tmpRetcode = READY then            
            //Timestamp for TimeoutCheck
            udSDOTimeout    := ops.tAbsolute;
            eResponseState  := wait;           
          //Error occured  
          elsif tmpRetcode = ERROR then          
            eModuleInitState := ERROR;
            LogError("@ZZZZ (SR022::InitModule) Failed to add write SDO for Module configuration");
            eInitState := _NoMem;            
          end_if;
        
        //Wait for Response
        //*****************************************************************************
        wait:        
          //Timeout-Check
          if ((ops.tAbsolute - udSDOTimeout) > SR022_SDO_RESPONSE_TIMEOUT) then          
            LogError("@ZZZZ (SR022::InitModule) SDO Response timeout config module");
            eInitSSWErrorStep  := eInitSSW;
            eInitSSW          := Init_Error;            
          end_if;
          
        //Response received
        //*****************************************************************************
        valid:          
          eInitSSW        := Init_ConfigSequencer;
          eResponseState  := idle;          
      end_case;


    //set sequencer configuration
    //*****************************************************************************
    Init_ConfigSequencer:
      //Statemachine for SDO-Communication
      case eResponseState of
        //*****************************************************************************
        idle:        
          //Start SDO-Command
          tmpRetcode := StartWriteSDO(hOffset       := SR022_ADDR_DC_SEQUENCER, 
                                      usLength      := sizeof(sConfiguration.DC_Sequencer), 
                                      pWriteBuffer  := (#sConfiguration.DC_Sequencer)$^USINT, 
                                      eCommand      := SDIAS_SDO_CMD_MEM_WRITE);
          
          //Evaluate Returncode
          if tmpRetcode = READY then            
            //Timestamp for TimeoutCheck
            udSDOTimeout    := ops.tAbsolute;
            eResponseState  := wait;           
          //Error occured  
          elsif tmpRetcode = ERROR then          
            eModuleInitState := ERROR;
            LogError("@ZZZZ (SR022::InitModule) Failed to add write SDO for Module configuration");
            eInitState := _NoMem;            
          end_if;
        
        //Wait for Response
        //*****************************************************************************
        wait:        
          //Timeout-Check
          if ((ops.tAbsolute - udSDOTimeout) > SR022_SDO_RESPONSE_TIMEOUT) then          
            LogError("@ZZZZ (SR022::InitModule) SDO Response timeout config module");
            eInitSSWErrorStep  := eInitSSW;
            eInitSSW          := Init_Error;            
          end_if;
          
        //Response received
        //*****************************************************************************
        valid:          
          eInitSSW        := Init_ReadSDOData;
          eResponseState  := idle;          
      end_case;
      
    //read cyclic sdo data
    //*****************************************************************************
    Init_ReadSDOData:
      TmpRetcode := SDOReadInfoData(1);
      if TmpRetcode = READY then
        ErrorBits.biFWErrorBits := sReadSDOConfData.Status;
        //nosync is not valid at this moment
        ErrorBits.biFWErrorBits.NoSync := FALSE;
        eInitSSW        := Init_ReadSDOSequ;
        eResponseState  := idle; 
      elsif TmpRetcode = Error then
        eInitSSWErrorStep := eInitSSW;
        eResponseState    := idle; 
        eInitSSW          := Init_Error;            
      end_if;
      
    //set sequencer configuration
    //*****************************************************************************
    Init_ReadSDOSequ:
      TmpRetcode := SDOReadInfoData(2);
      if TmpRetcode = READY then
        eInitSSW        := Init_QuitError;
        eResponseState  := idle; 
      elsif TmpRetcode = Error then
        eInitSSWErrorStep := eInitSSW;
        eResponseState    := idle; 
        eInitSSW          := Init_Error;            
      end_if;
      
    //*****************************************************************************
    Init_QuitError :      
      //Write to DPRam
      sAccesses.pWriteData^ := sAccesses.sWriteData;
      // Reset Quit Flags, We don't need to quit again in 1st UpdateRtPostScan
      sAccesses.sWriteData.bsControl.bQuitOverTemperatureError  := false;
      sAccesses.sWriteData.bsControl.bQuitI2tError              := false;      
      eInitSSW        := Init_Finish;
    
    //Initialization of Module finished
    //*****************************************************************************
    Init_Finish:    
      eInitSSW          := Init_Variables;
      eInitState        := _ClassOk;
      eModuleInitState  := READY;     
   
   //Error during Initialization
   //*****************************************************************************
   Init_Error:      
      eInitState        := _ClientNotready;
      eModuleInitState  := ERROR; 
  
  end_case;
  
END_FUNCTION


FUNCTION VIRTUAL GLOBAL SR022::CheckDeviceID
	VAR_INPUT
		udID2Check 	: UDINT;
	END_VAR
	VAR_OUTPUT
		bIsOK 	: BOOL;
	END_VAR
  
	//Check DeviceID of Module
	if ( udID2Check <> DEVICE_ID_SR022 ) then
		bIsOK := false;
	else
    bIsOK := true;
	end_if;

END_FUNCTION


FUNCTION SR022::CalculatePWM
  VAR
    tmpPWM	            : UINT;
    tmpBridgeOnSwitch   : UINT;
    tmpBridgeOffSwitch  : UINT;
    tmpTime             : UINT;
  END_VAR
            
  //Input 0 => Brake (Short Circuit)
  //*****************************************************************************
  if SetSpeed = 0 then
  
    tmpBridgeOnSwitch   := ( SR022_GATE_A_LOW + SR022_GATE_B_LOW ) OR ( SR022_DEFAULT_SEQ_INIT AND SR022_MASK_CONTROL );
    tmpBridgeOffSwitch  := ( SR022_GATE_A_LOW + SR022_GATE_B_LOW ) OR ( SR022_DEFAULT_SEQ_INIT AND SR022_MASK_CONTROL );
    
    //No PWM
    tmpPWM := uiPeriodCount / 2;
    
  //Input < 0 => Negative Direction (Gate A - High, Gate B - Low)
  //*****************************************************************************
  elsif SetSpeed < 0 then
  
    tmpBridgeOnSwitch   := ( SR022_GATE_A_HIGH + SR022_GATE_B_LOW ) OR ( SR022_DEFAULT_SEQ_INIT AND SR022_MASK_CONTROL );
    tmpBridgeOffSwitch  := ( SR022_GATE_A_LOW + SR022_GATE_B_LOW )  OR ( SR022_DEFAULT_SEQ_INIT AND SR022_MASK_CONTROL );
    
    //Calculate PWM
    tmpPWM := to_uint(-SetSpeed);
    
  //Input > 0 => Positive Direction ()
  //*****************************************************************************
  else
  
    tmpBridgeOnSwitch   := ( SR022_GATE_A_LOW + SR022_GATE_B_HIGH ) OR ( SR022_DEFAULT_SEQ_INIT AND SR022_MASK_CONTROL );
    tmpBridgeOffSwitch  := ( SR022_GATE_A_LOW + SR022_GATE_B_LOW )  OR ( SR022_DEFAULT_SEQ_INIT AND SR022_MASK_CONTROL );
    
    //Calculate PWM
    tmpPWM := to_uint(SetSpeed);
  
  end_if;

  
  //Time Calculation
  tmpTime := tmpPWM * (uiPeriodCount)  / SR022_SPEED_SCALING;
  
  if tmpTime < uiTimeMin then
    tmpTime := uiTimeMin;
  end_if;

  
  //Set Write-Data
  //lanste 24.10.2014 If Seq1 or Seq3 are changed as well updateRTPostscan must be updatet as well.
  sSeqData.Seq2 := ( tmpBridgeOnSwitch  AND SR022_MASK_TIME ) OR tmpTime;
  sSeqData.Seq4 := ( tmpBridgeOffSwitch AND SR022_MASK_TIME ) OR ( uiPeriodCount - ( tmpTime AND SR022_MASK_CONTROL ) );
  
  // Lock seqdata update behind a flag and because calculation can be interrupted.
  bUpdateSeqData := TRUE;
   
END_FUNCTION


FUNCTION VIRTUAL SR022::GetTaskCfg
	VAR_OUTPUT
		TaskCfg 	: BDINT;
	END_VAR

  TaskCfg := SDIAS_TASK_MASK_RT_PRE OR SDIAS_TASK_MASK_RT_POST;

END_FUNCTION


FUNCTION VIRTUAL SR022::GetDeviceID
	VAR_OUTPUT
		output 	: UDINT;
	END_VAR
  
  output := DEVICE_ID_SR022;

END_FUNCTION


FUNCTION VIRTUAL SR022::GetFWVersion
	VAR_INPUT
		pData 	: ^CHAR;
		Length 	: UDINT;
	END_VAR
  
  //Check pointer
  if pData then
    //Length of Firmwareversion (HDINT) -> 8Byte +1 byte zero termination
    if Length >= 9 then
      _itoa(udNumber:=FirmwareVersion, pString:=pData);  
    else
      pData^ := 0;
    end_if; 
  end_if;
  
END_FUNCTION


FUNCTION VIRTUAL GLOBAL SR022::ZPulsLatched::Read
	VAR_OUTPUT
		output (EAX) 	: DINT;
	END_VAR

  //Return Latch
	output := ZPulsLatched;
  
  //Reset Latch in next rt-run
  bsLatchReaded.ZPos := TRUE;

END_FUNCTION

FUNCTION SR022::SDOReadInfoData
	VAR_INPUT
		ReadSector 	: DINT;
	END_VAR
	VAR_OUTPUT
		RetCode 	: iprStates;
	END_VAR
  VAR
  	TmpRetcode      : iprStates;
  END_VAR    
  
  RetCode := BUSY;
  case ReadSector of
    1:    
      //Statemachine for SDO-Communication
      case eResponseState of
        //*****************************************************************************
        idle:        
          //Start SDO-Command
          tmpRetcode := StartReadSDO(hOffset:=SR022_ADDR_READ_SDO, usLength:=t_s_SDO_Read_Cyclic.SDOControlRead.aReserved, eCommand:=SDIAS_SDO_CMD_MEM_READ);          
          //Evaluate Returncode
          if tmpRetcode = READY then            
            //Timestamp for TimeoutCheck
            udSDOCyclicTimeout := ops.tAbsolute;
            eResponseState     := wait;           
          //Error occured  
          elsif tmpRetcode = ERROR then          
            RetCode := ERROR;
            LogError("@ZZZZ (SR022::SDOReadInfoData) Failed to add read SDO for Module configuration");
          end_if;
        
        //Wait for Response
        //*****************************************************************************
        wait:        
          //Timeout-Check
          if ((ops.tAbsolute - udSDOCyclicTimeout) > SR022_SDO_RESPONSE_TIMEOUT) then          
            LogError("@ZZZZ (SR022::SDOReadInfoData) SDO Response timeout config module");   
            RetCode := ERROR;
          end_if;
          
        //Response received
        //*****************************************************************************
        valid:
          eResponseState  := idle; 
          RetCode         := READY;         
      end_case;    
  
    2:    
      //Statemachine for SDO-Communication
      case eResponseState of
        //*****************************************************************************
        idle:        
          //Start SDO-Command
          tmpRetcode := StartReadSDO(hOffset:=SR022_ADDR_DC_SEQUENCER, usLength:=sizeof(sReadSDOConfData.SDOControlRead.DC_Sequencer), eCommand:=SDIAS_SDO_CMD_MEM_READ);          
          //Evaluate Returncode
          if tmpRetcode = READY then            
            //Timestamp for TimeoutCheck
            udSDOCyclicTimeout := ops.tAbsolute;
            eResponseState     := wait;           
          //Error occured  
          elsif tmpRetcode = ERROR then          
            RetCode := ERROR;
            LogError("@ZZZZ (SR022::SDOReadInfoData) Failed to add read SDO for Module configuration");
          end_if;
        
        //Wait for Response
        //*****************************************************************************
        wait:        
          //Timeout-Check
          if ((ops.tAbsolute - udSDOCyclicTimeout) > SR022_SDO_RESPONSE_TIMEOUT) then          
            LogError("@ZZZZ (SR022::SDOReadInfoData) SDO Response timeout config module");   
            RetCode := ERROR;
          end_if;
          
        //Response received
        //*****************************************************************************
        valid:  
          eResponseState  := idle; 
          RetCode         := READY;         
      end_case;      
  end_case;

END_FUNCTION

FUNCTION VIRTUAL GLOBAL SR022::AddAccesses
	VAR_OUTPUT
		eModuleInitState 	: iprStates;
	END_VAR
  
  ExtendedData := ExtendedData.Read() <> 0;
  
  if ExtendedData then      
    //extended read access is needed
    if AddRdAccess(hOffset              :=SR022_ADDR_CYC_READ
                 , uLength              :=sizeof(t_s_ExtendedAccess)
                 , bCtrlAcc0            :=FALSE
                 , ppData               :=#sAccesses.pReadDataExtended
                 , ppStateByte          :=#sAccesses.sReadDataExtendedControl.pStateByte
                 , ppControlByte        :=#sAccesses.sReadDataExtendedControl.pControlByte
                 , pAccessHandle        :=#sAccesses.sReadDataExtendedControl.AccessHandle
                 , WaitForAccessHandle  :=FALSE) then
    
      LogError(pMsg:="@ZZZZ (SR022::AddAccesses) Adding extended read access failed");
    end_if;
  end_if;
  
  eModuleInitState := READY;
  
END_FUNCTION
