//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)

//{{LSL_DEFINES

#define BUSIF_SDIASDRIVEMNG_OFFSET_TYPELABEL        0x0000
#define BUSIF_SDIASDRIVEMNG_PARALIST_INDEX_SET      0x2210
#define BUSIF_SDIASDRIVEMNG_PARALIST_INDEX_INFO     0x2211
#define BUSIF_SDIASDRIVEMNG_PARALIST_INDEX_SETNR    174


#define BUSIF_SDIASDRIVEMNG_MAX_SERVICEBOX          4
#define BUSIF_SDIASDRIVEMNG_SDO_RESPONSE_TIMEOUT    SDIAS_SDO_TIMEOUT * 2
#define BUSIF_SDIASDRIVEMNG_SDO_TYPELABEL_TIMEOUT   10000  //10 sec timeout to read typelabel

#define BUSIF_SDIASDRIVEMNG_SDO_SERVICE_APP_MDD100        0x4150
#define BUSIF_SDIASDRIVEMNG_SDO_SERVICE_APP_LASAL         0x4C41
#define BUSIF_SDIASDRIVEMNG_SDO_SERVICE_APP_CANOPEN       0x4453
#define BUSIF_SDIASDRIVEMNG_SDO_SERVICE_APP_CANOPEN_LASAL 0x444C



#define BUSIF_SDIASDRIVEMNG_FULL_PARADATA_SIZE   12
#define BUSIF_SDIASDRIVEMNG_CANOPEN_FOOTER_SIZE   4
#define BUSIF_SDIASDRIVEMNG_LASAL_PARADATA_SIZE   4

//}}LSL_DEFINES

//{{LSL_DECLARATION
#include "..\..\class\_drivemngbase\drivemngbase.h"

(*!
<Class
	Name               = "_BusInterfaceSdiasDriveMng"
	Revision           = "1.10"
	GUID               = "{4DA8668C-F5F2-4097-A2BC-9EA8C85E9BE7}"
	RealtimeTask       = "false"
	CyclicTask         = "false"
	BackgroundTask     = "false"
	Sigmatek           = "true"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	IconPath           = ".\Class\_DriveMngBase\Drive.ico"
	SharedCommandTable = "true"
	Objectsize         = "(546,120)">
	<Channels>
		<Server Name="CallCommand" GUID="{5ACAF34F-F911-4473-AE68-B51925B6E4E2}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Server Name="ClassState">
		</Server>
		<Server Name="Online" GUID="{BFAB0BEC-F43D-4113-80A7-7006F2AAA1DC}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Client Name="SdiasID" Required="true" Internal="false"/>
		<Client Name="TimeMultiplier" Required="true" Internal="false"/>
	</Channels>
	<Dependencies>
		<Files>
			<File Path=".\class\_drivemngbase\drivemngbase.h" Include="true"/>
		</Files>
	</Dependencies>
	<RevDoku>
		<Owner Company="Sigmatek" Author="PieSte"/>
		<Dokumentation Revision="1.10" Date="20.03.2018" Author="FurDom" Company="Sigmatek" Description="When reinitializing the drive with the server SDDCmdIntfc of the _DriveAxis class, the CmdState of the class _BusInterfaceSdiasDriveMng is no longer set to &quot;_NotInitialized&quot;, so that no error occurs with the DC06x modules. The status is internally passed on to keep the process the same as with the SDD300 and MDD100 drives."/>
		<Dokumentation Revision="1.9" Date="23.01.2018" Author="RamAnd" Company="Sigmatek" Description="Log messages have been standardized for easier maintenance, easier use in any class and to allow spam filtering. Code for the logging functions is now only located in HwControl."/>
		<Dokumentation Revision="1.8" Date="16.05.2017" Author="RamAnd" Company="Sigmatek" Description="When adding an SDO (i.e. via ReadSPIData) from background priority it was possible that the adding process got interrupted by receiving the answer to this SDO which is handled in cyclic priority. In the error case the answer was unexpected and therefore ignored. Then the class signals a timeout while waiting for the answer, which already arrived before waiting for it. Added mutex and changed instruction order to prevent this error."/>
		<Dokumentation Revision="1.7" Date="22.06.2015" Author="EisMic" Company="Sigmatek" Description="The servers FPGAVersion, SerialNo, Device ID and status and input servers are now not reset anymore when the module is disconnected."/>
		<Dokumentation Revision="1.6" Date="17.03.2015" Author="RamAnd" Company="Sigmatek" Description="Added HW Version for sdias clients."/>
		<Dokumentation Revision="1.5" Date="26.02.2015" Author="PieSte" Company="Sigmatek" Description="Changed commands for businterface to be compatible with new drive hardware."/>
		<Dokumentation Revision="1.4" Date="11.02.2015" Author="PieSte" Company="Sigmatek" Description="Corrected read spi data for hardwaretree in methode GetSPIDataFromID from baseclass."/>
		<Dokumentation Revision="1.3" Date="30.01.2015" Author="RamAnd" Company="Sigmatek" Description="The parameters for creating DOs were not correctly initialized if SdiasManager class v1.63 or higher has been used."/>
		<Dokumentation Revision="1.2" Date="05.11.2014" Author="PieSte" Company="Sigmatek" Description="Corrected error handling in methode AddAccesses."/>
		<Dokumentation Revision="1.1" Date="29.07.2014" Author="PieSte" Company="Sigmatek" Description="Added NewInst commando to get series info.&#13;&#10;Changed names of handover variables.&#13;&#10;Replace define for DeviceID with client."/>
		<Dokumentation Revision="1.0" Date="10.07.2014" Author="PieSte" Company="Sigmatek" Description="Initial library version."/>
	</RevDoku>
	<Network Name="_BusInterfaceSdiasDriveMng">
		<!-- List of Components in this network -->
		<Components>
			<Object
				Name       = "_base"
				GUID       = "{ADE6801B-F56B-454D-AE60-FBA585CE6287}"
				Class      = "SdiasBase"
				Position   = "(218,120)"
				Visualized = "true">
				<Channels>
					<Server Name="ClassState"/>
					<Server Name="DeviceID"/>
					<Server Name="FPGAVersion"/>
					<Server Name="HwVersion"/>
					<Server Name="LEDControl" Value="0"/>
					<Server Name="RetryCounter"/>
					<Server Name="SDOState"/>
					<Server Name="SerialNo"/>
					<Client Name="Place" Value="0"/>
					<Client Name="Required" Value="1"/>
					<Client Name="SdiasIn"/>
					<Client Name="ToStdLib"/>
				</Channels>
			</Object>
		</Components>
		<Comments>
		</Comments>
		<!-- List of Connections in this network -->
		<Connections>
			<Connection Source="this.ClassState" Destination="_base.ClassState" Vertices="(804,210),(632,210),"/>
			<Connection Source="this.DeviceID" Destination="_base.DeviceID" Vertices="(804,270),(632,270),"/>
			<Connection Source="this.FPGAVersion" Destination="_base.FPGAVersion" Vertices="(804,330),(632,330),"/>
			<Connection Source="this.SerialNo" Destination="_base.SerialNo" Vertices="(804,450),(632,450),"/>
			<Connection Source="this.RetryCounter" Destination="_base.RetryCounter" Vertices="(804,510),(632,510),"/>
			<Connection Source="this.LEDControl" Destination="_base.LEDControl" Vertices="(804,570),(632,570),"/>
			<Connection Source="this.SDOState" Destination="_base.SDOState" Vertices="(804,630),(632,630),"/>
			<Connection Source="_base.SdiasIn" Destination="this.SdiasIn" Vertices="(218,210),(38,210),"/>
			<Connection Source="_base.Place" Destination="this.Place" Vertices="(218,270),(38,270),"/>
			<Connection Source="_base.Required" Destination="this.Required" Vertices="(218,330),(38,330),"/>
			<Connection Source="this.HwVersion" Destination="_base.HwVersion" Vertices="(804,390),(632,390),"/>
		</Connections>
		<!-- Headerfiles -->
		<Options>
		</Options>
	</Network>
</Class>
*)
#pragma using SdiasBase

_BusInterfaceSdiasDriveMng : CLASS
: SdiasBase
	TYPE
	  aBuffer : ARRAY [0..15] OF USINT;
#pragma pack(push, 1)
	  t_DataReadOneAxis : STRUCT
	    Value6 : DINT;
	    Value7 : DINT;
	    Value8 : DINT;
	    Value9 : DINT;
	    Value10 : DINT;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_DataWriteOneAxis : STRUCT
	    Value1 : DINT;
	    Value2 : DINT;
	    Value3 : DINT;
	    Value4 : DINT;
	    Value5 : DINT;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_AccessInfo : STRUCT
	    AccessHandle : UDINT;
	    pControlByte : ^t_SDIAS_ControlByte;
	    pStateByte : ^t_SDIAS_StateByte;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_AccessInfoDyn : STRUCT
	    AccessHandle : UDINT;
	    pControlByte : ^t_SDIAS_ControlByte;
	    pStateByte : ^t_SDIAS_StateByte;
	    ActDoLength : USINT;
	    LastDoLength : DINT;
	    ActDoOffset : USINT;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_Accesses : STRUCT
	    pReadIso : ^t_DataReadOneAxis;
	    pWriteIso : ^t_DataWriteOneAxis;
	    pReadAsy : ^aBuffer;
	    pWriteAsy : ^aBuffer;
	    ReadAccessIso : t_AccessInfo;
	    WriteAccessIso : t_AccessInfo;
	    ReadAccessAsy : t_AccessInfoDyn;
	    WriteAccessAsy : t_AccessInfoDyn;
	    b_TempAsyData : BOOL;
	    ServiceIDNr : USINT;
	    pMutex : ^void;
	  END_STRUCT;
#pragma pack(pop)
	  t_AxisState :
	  (
	    _NotUsed,
	    _NoInit,
	    _InitOk,
	    _NoParaList,
	    _NotSynchron,
	    _AxisOk
	  )$USINT;
	  t_ParaState :
	  (
	    _SendExecution,
	    _EnableRead,
	    _Wait4Response,
	    _IdleState,
	    _GotValueForExecution
	  )$UDINT;
#pragma pack(push, 1)
	  t_ParaList : STRUCT
	    us_number : USINT;
	    sd_value : DINT;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_ReadValuePtr : STRUCT  //! <Type Public="true" Name="t_ReadValuePtr"/>
	    a_SyncValues : ARRAY [0..4] OF DINT;
	    bs_InputStates : BSINT
	    [
	      1 OptionBoardInputState,
	    ];
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_WriteValuePtr : STRUCT  //! <Type Public="true" Name="t_WriteValuePtr"/>
	    a_SyncValues : ARRAY [0..4] OF DINT;
	  END_STRUCT;
#pragma pack(pop)
	  t_AxisData : STRUCT
	    e_AxisState : t_AxisState;
	    us_ParaReady : t_ParaState;
	    sd_Asyncdata : aBuffer;
	    sd_ObjectError : DINT;
	    b_ListActive : BOOL;
	    p_ParaList : ^t_ParaList;
	    ui_ParaListCnt : UINT;
	    ud_CRCError : UDINT;
	    ud_DOLength : UDINT;
	    b_ExtendedAxis : DINT;
	    b_FastAxis : DINT;
	    b_OldToggleState : DINT;
	    s_ReadValues : t_ReadValuePtr;
	    s_WriteValues : t_WriteValuePtr;
	  END_STRUCT;
	  t_InitAccesses :
	  (
	    _CreateMutex,
	    _ReadoutTypeLabel,
	    _AddAccesses,
	    _FinishInitAccesses,
	    _ErrorInitAccesses
	  )$UDINT;
	  t_InitSSW :
	  (
	    _SetDataObjectOn,
	    _Wait4Read:=1,
	    _SetInitAxis:=2,
	    _SetEnableRead:=3,
	    _WaitInit:=4,
	    _SetFinishInit:=5,
	    _SetDisableWrite:=6,
	    _SetExecuteBack:=7,
	    _GetFinishInit:=8,
	    _CyIdle:=9,
	    _Finish:=10,
	    _InitError:=11
	  )$UDINT;
#pragma pack(push, 1)
	  t_MapEntry : STRUCT
	    Address : HINT;
	    Length : UINT;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_MailBox : STRUCT
	    ID : HINT;
	    Request : t_MapEntry;
	    Response : t_MapEntry;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_ParaSkipOneAxis : STRUCT
	    us_No : USINT;
	    p_Values : ^USINT;
	  END_STRUCT;
#pragma pack(pop)
	  t_ResponseState :
	  (
	    _idle,
	    _wait,
	    _valid
	  )$UDINT;
	  t_RtSSW :
	  (
	    _InitAxis,
	    _GetSendParaList,
	    _WaitForSynchrony,
	    _Operational
	  )$UDINT;
#pragma pack(push, 1)
	  t_SDORequest : STRUCT
	    sd_ObjectValue : ARRAY [0..11] OF USINT;
	    ParaIndex : HINT;
	    ParaSubIndex : USINT;
	    RequestControl : BSINT
	    [
	      1 ToggleBit,
	      2 ReadWriteObject,
	      3 InitCommunication,
	      4 res1,
	      5 res2,
	      6 res3,
	      7 DataLength1,
	      8 DataLength2,
	    ];
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_SDOResponse : STRUCT
	    sd_ObjectValue : ARRAY [0..11] OF USINT;
	    ParaIndex : HINT;
	    ParaSubIndex : USINT;
	    ResponseControl : BSINT
	    [
	      1 ToggleBit,
	      2 ErrorInObjectHandling,
	      3 Warning,
	      4 res1,
	      5 res2,
	      6 res3,
	      7 DataLength1,
	      8 DataLength2,
	    ];
	  END_STRUCT;
#pragma pack(pop)
	  t_TypeLabelSSW :
	  (
	    _ReadFirst2Bytes,
	    _ReadTypeLabel,
	    _CheckServiceID,
	    _ReadAxisAmount,
	    _TypeLabelFinish,
	    _TypeLabelError,
	    _NoErrorReadTypeLabel
	  )$UDINT;
#pragma pack(push, 1)
	  t_VANDALMapping : STRUCT
	    VersionMinor : HSINT;
	    VersionMajor : HSINT;
	    DeviceName : ARRAY [0..23] OF CHAR;
	    DeviceInfoPointer : HINT;
	    DeviceID : DINT;
	    PDOs : STRUCT
	      MOCI : t_MapEntry;
	      MICO : t_MapEntry;
	    END_STRUCT;
	    WriteBeforeSync : USINT;
	    ReadAfterSync : USINT;
	    MailboxNumber : USINT;
	    aReserved : ARRAY [0..4] OF USINT;
	    aMailBoxes : ARRAY [0..BUSIF_SDIASDRIVEMNG_MAX_SERVICEBOX-1] OF t_MailBox;
	    AxisAvailable : BSINT
	    [
	      1 Axis1,
	      2 Axis2,
	    ];
	  END_STRUCT;
#pragma pack(pop)
	END_TYPE
  //Servers:
	Online 	: SvrCh_DINT;
	CallCommand 	: SvrChCmd_DINT;
  //Clients:
	TimeMultiplier 	: CltCh_UDINT;
	SdiasID 	: CltCh_UDINT;
  //Variables:
		eInitSSW 	: t_InitSSW;
		eInitAccesses 	: t_InitAccesses;
		eErrorInitAccesses 	: t_InitAccesses;
		eRtSSW 	: t_RtSSW;
		eReadTypeLabelSSW 	: t_TypeLabelSSW;
		eErrorStepTypeLabelSSW 	: t_TypeLabelSSW;
		eResponseState 	: t_ResponseState;
		Accesses 	: t_Accesses;
		sAxisData 	: t_AxisData;
		sTypeLabel 	: t_VANDALMapping;
		ActAsyWriteData 	: t_SDORequest;
		ActAsyReadData 	: t_SDOResponse;
		ExtendedAxisSettings : BDINT
		[
		];

		pCallBackServer 	: ^UDINT;
		AxisAvailableNo 	: USINT;
		AxisAvailableHW : BSINT
		[
		  1 Axis1,
		  2 Axis2,
		];

		s_SkipParameter 	: t_ParaSkipOneAxis;
		usReadLengthTypeLabel 	: USINT;
		usReadTypeLabelOffset 	: USINT;
		ud_TimemarkInit 	: UDINT;
		ud_TimeCounter 	: UDINT;
		ud_TimeOutTypeLabel 	: UDINT;
		udSDOTimeout 	: UDINT;
		b_InitOk 	: BOOL;
		b_UpdateThisTime 	: BOOL;
		b_AlreadyConnected 	: BOOL;
		Synchron 	: BOOL;
		mt_api 	: ^LSL_MT_TYPE;
		p_DriveMngBase 	: ^void;
		eInternalState 	: t_e_VaranErrors;
  //Functions:
				//! <Function Comment="Realtime Update Methode which runs in PreScan." Name="UpdateRt"/>
	FUNCTION VIRTUAL GLOBAL UpdateRt;
				//! <Function Comment="Realtime Update Methode which runs in PostScan." Name="UpdateRtPostScan"/>
	FUNCTION VIRTUAL GLOBAL UpdateRtPostScan;
	
	FUNCTION VIRTUAL GLOBAL AddAccesses
		VAR_OUTPUT
			eModuleInitState 	: iprStates;
		END_VAR;
				//! <Function Comment="Methode is called if this Module gets connected." Name="ConnectEvent"/>
	FUNCTION VIRTUAL GLOBAL ConnectEvent;
				//! <Function Comment="Methode is called if this Module gets disconnected." Name="DisconnectEvent"/>
	FUNCTION VIRTUAL GLOBAL DisconnectEvent;
				//! <Function Comment="This Methode should be used, to check the DeviceID of the Module." Name="CheckDeviceID"/>
	FUNCTION VIRTUAL GLOBAL CheckDeviceID
		VAR_INPUT
			udID2Check 	: UDINT;			//! <Variable Comment="Device ID of connected Module." Name="CheckDeviceID.udID2Check"/>
		END_VAR
		VAR_OUTPUT
			bIsOK 	: BOOL;			//! <Variable Comment="FALSE = Wrong DeviceID for Module&#13;&#10;TRUE  = DeviceID of Module is correct" Name="CheckDeviceID.bIsOK"/>
		END_VAR;
				//! <Function Comment="Methode to receive the Response in case of SDO-Communication." Name="ReceiveSDOResponse"/>
	FUNCTION VIRTUAL ReceiveSDOResponse
		VAR_INPUT
			eCommand 	: t_SDIAS_SDO_Cmd;			//! <Variable Comment="Type of SDO-Command" Name="ReceiveSDOResponse.eCommand"/>
			hOffset 	: HINT;			//! <Variable Comment="Address-Offset in Module." Name="ReceiveSDOResponse.hOffset"/>
			usLength 	: USINT;			//! <Variable Comment="Length of Data." Name="ReceiveSDOResponse.usLength"/>
			eResult 	: iprStates;			//! <Variable Comment="State of SDO-Communication." Name="ReceiveSDOResponse.eResult"/>
			pResponseBuffer 	: ^USINT;			//! <Variable Comment="Pointer of ResponseBuffer, where the SDO-Data is located." Name="ReceiveSDOResponse.pResponseBuffer"/>
			ResponseLength 	: USINT;			//! <Variable Comment="Size of the ResponseBuffer." Name="ReceiveSDOResponse.ResponseLength"/>
		END_VAR
		VAR_OUTPUT
			ret_code 	: iprStates;			//! <Variable Comment="Indicates if the Methode was successful." Name="ReceiveSDOResponse.ret_code"/>
		END_VAR;
	
	FUNCTION VIRTUAL GetTaskCfg
		VAR_OUTPUT
			TaskCfg 	: BDINT;			//! <Variable Comment="Select which tasks will be available for this module:&#13;&#10;Bit0..Realtime PreScan&#13;&#10;Bit1..Realtime PostScan&#13;&#10;Bit2..Cyclic&#13;&#10;&#13;&#10;e.g. if only realtime postscan is needed:&#13;&#10;2#010" Name="GetTaskCfg.TaskCfg"/>
		END_VAR;
	
	FUNCTION GLOBAL StartCommunication
		VAR_INPUT
			AxisExtend 	: BDINT;
			pServer4CallBack 	: ^BDINT;
		END_VAR;
	
	FUNCTION GLOBAL SetParaList
		VAR_INPUT
			p_list 	: ^void;
			ui_counter 	: UINT;
		END_VAR
		VAR_OUTPUT
			sd_retval 	: DINT;
		END_VAR;
	
	FUNCTION GLOBAL SetParameter
		VAR_INPUT
			uiParaID 	: UINT;
			usParaSubID 	: USINT;
			usRdWr 	: USINT;
			pvalue 	: ^DINT;
			bsDataInfo 	: BSINT;
		END_VAR
		VAR_OUTPUT
			sd_retval 	: DINT;
		END_VAR;
	
	FUNCTION SkipEntries
		VAR_INPUT
			p_Axis 	: ^t_AxisData;
		END_VAR;
	
	FUNCTION GLOBAL GetParameter
		VAR_OUTPUT
			sd_para_data 	: ^aBuffer;
		END_VAR;
	
	FUNCTION GLOBAL GetParameterState
		VAR_OUTPUT
			sd_para_state 	: DINT;
		END_VAR;
	
	FUNCTION GLOBAL GetDriveIntState
		VAR_OUTPUT
			retcode 	: DINT;
		END_VAR;
	
	FUNCTION InitAxis
		VAR_OUTPUT
			sd_retval 	: DINT;
		END_VAR;
	
	FUNCTION GLOBAL GetAxisWrPtr
		VAR_OUTPUT
			pWritePara 	: ^t_WriteValuePtr;
		END_VAR;
	
	FUNCTION GLOBAL GetAxisRdPtr
		VAR_OUTPUT
			pReadPara 	: ^t_ReadValuePtr;
		END_VAR;
	
	FUNCTION GLOBAL ExternInitFinished;
	
	FUNCTION GLOBAL InitDrive;
	
	FUNCTION GLOBAL SetSyncParameter
		VAR_INPUT
			us_value 	: USINT;
			sd_data 	: DINT;
		END_VAR
		VAR_OUTPUT
			sd_retval 	: DINT;
		END_VAR;
	
	FUNCTION GLOBAL GetSyncParameter
		VAR_INPUT
			us_value 	: USINT;
			p_data 	: ^DINT;
		END_VAR
		VAR_OUTPUT
			sd_retval 	: DINT;
		END_VAR;
	
	FUNCTION ReadTypeLabel
		VAR_OUTPUT
			eModuleInitState 	: iprStates;
		END_VAR;
	
	FUNCTION GetObjectValue;
	
	FUNCTION ChangeDO
		VAR_INPUT
			AccessHandle 	: UDINT;
			NewOffset 	: HDINT;
			NewLength 	: UDINT;
		END_VAR;
	
	FUNCTION EnableDO
		VAR_INPUT
			pControlByte 	: ^t_SDIAS_ControlByte;
		END_VAR;
	
	FUNCTION DisableDO
		VAR_INPUT
			pControlByte 	: ^t_SDIAS_ControlByte;
		END_VAR;
	
	FUNCTION SetWriteData;
	
	FUNCTION GetReadData;
	
	FUNCTION VIRTUAL GLOBAL ClassState::NewInst
		VAR_INPUT
			pPara 	: ^CmdStruct;
			pResult 	: ^results;
		END_VAR
		VAR_OUTPUT
			ret_code 	: iprStates;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL CallCommand::NewInst
		VAR_INPUT
			pPara 	: ^CmdStruct;
			pResult 	: ^results;
		END_VAR
		VAR_OUTPUT
			ret_code 	: iprStates;
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

//}}LSL_DECLARATION


FUNCTION GLOBAL TAB _BusInterfaceSdiasDriveMng::@CT_
0$UINT,
2#0100000000000000$UINT, //TY__BUSINTERFACESDIASDRIVEMNG
1$UINT, 10$UINT, (SIZEOF(::_BusInterfaceSdiasDriveMng))$UINT, 
2$UINT, 2$UINT, 0$UINT, 
TO_UDINT(1048633017), "_BusInterfaceSdiasDriveMng", //Class
TO_UDINT(3175101883), "SdiasBase", 1$UINT, 58$UINT, //Baseclass
//Servers:
(::_BusInterfaceSdiasDriveMng.Online.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1858763116), "Online", 
(::_BusInterfaceSdiasDriveMng.CallCommand.pMeth)$UINT, _CH_CMD$UINT, 2#0000000000000000$UINT, TO_UDINT(1059212957), "CallCommand", 
//Clients:
(::_BusInterfaceSdiasDriveMng.TimeMultiplier.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(2421717411), "TimeMultiplier", 
(::_BusInterfaceSdiasDriveMng.SdiasID.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(1394835554), "SdiasID", 
END_FUNCTION


#define USER_CNT__BusInterfaceSdiasDriveMng 20

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT__BusInterfaceSdiasDriveMng] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION _BusInterfaceSdiasDriveMng::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
		nCmdSize	: UINT;
	END_VAR

	ret_code	:= SdiasBase::@STD();
	IF ret_code <> C_OK THEN
		RETURN;
	END_IF;
	nCmdSize		:= SdiasBase::ClassState.pMeth^.nCmds$UINT*SIZEOF(pVoid) + CMDMETH.Init;

	_memcpy((#vmt.CmdTable)$^USINT, SdiasBase::ClassState.pMeth, nCmdSize);
	vmt.CmdTable.nCmds		:= nSTDCMD + USER_CNT__BusInterfaceSdiasDriveMng;
	vmt.CmdTable.NewInstr		:= #ClassState::NewInst();
#pragma warning (disable : 74)
	vmt.UserFcts[0]		:= #UpdateRt();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[1]		:= #UpdateRtPostScan();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[4]		:= #AddAccesses();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[5]		:= #ConnectEvent();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[6]		:= #DisconnectEvent();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[8]		:= #CheckDeviceID();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[9]		:= #ReceiveSDOResponse();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[13]		:= #GetTaskCfg();

#pragma warning (default : 74)
	SdiasBase::ClassState.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF SdiasBase::ClassState.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	_memcpy((#vmt.CmdTable)$^USINT, CallCommand.pMeth, SIZEOF(CMDMETH));
	vmt.CmdTable.nCmds		:= nSTDCMD;
	vmt.CmdTable.NewInstr		:= #CallCommand::NewInst();
	CallCommand.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF CallCommand.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;

END_FUNCTION

//{{LSL_IMPLEMENTATION
FUNCTION VIRTUAL GLOBAL _BusInterfaceSdiasDriveMng::CallCommand::NewInst
	VAR_INPUT
		pPara 	: ^CmdStruct;
		pResult : ^Results;
	END_VAR
	VAR_OUTPUT
		ret_code : iprStates;
	END_VAR

  ret_code := READY;
  
  CASE pPara^.uiCmd OF
  
   //**********************************************************************************************************************************************************
    BUSIF_DRIVEMNGBASE_STARTCOMMUNICATION:    
      StartCommunication(AxisExtend       :=(pPara^.aPara[0])$BDINT
                        , pServer4CallBack:=(pPara^.aPara[2]$^BDINT)
                        );
                        

  //**********************************************************************************************************************************************************
    BUSIF_DRIVEMNGBASE_SER_NO_LEN:    
      pResult^.aData[0]$UDINT  := SerialNoStr.GetLength();
  
  
   //**********************************************************************************************************************************************************
    BUSIF_DRIVEMNGBASE_SER_NO_DATA:    
     SerialNoStr.GetDataAt(pData  :=(pPara^.aPara[0]$^USINT)
                        , udSize  :=(pPara^.aPara[1])$UDINT
                        , udAt    :=(pPara^.aPara[2])$UDINT
                        );
                        
  
   //**********************************************************************************************************************************************************
    BUSIF_DRIVEMNGBASE_SET_PARALIST:    
      SetParaList(p_list      := (pPara^.aPara[1])$^void
                , ui_counter  := (pPara^.aPara[2])$UINT
                );      
  
  
    //**********************************************************************************************************************************************************
    BUSIF_DRIVEMNGBASE_CREATE_DEF_PARALIST:   
      if (sAxisData.e_AxisState <> _NotUsed) then
        s_SkipParameter.us_No    := (pPara^.aPara[1])$USINT; // number of values in memory
        s_SkipParameter.p_Values := (pPara^.aPara[0])$^USINT; // pointer on memory
      end_if;
      
  
   //**********************************************************************************************************************************************************
    BUSIF_DRIVEMNGBASE_GET_PARA_State:    
      pResult^.aData[0]$DINT  := GetParameterState();  
    
  
   //**********************************************************************************************************************************************************  
    BUSIF_DRIVEMNGBASE_SET_PARAMETER:      
      pResult^.aData[0]$DINT := SetParameter(uiParaID     := (pPara^.aPara[1])$UINT
                                          , usParaSubID   := (pPara^.aPara[2])$USINT
                                          , usRdWr        := (pPara^.aPara[3])$USINT
                                          , pvalue        := (pPara^.aPara[4])$^DINT
                                          , bsDataInfo    := (pPara^.aPara[5])$BSINT                                         
                                          );
  
  
   //**********************************************************************************************************************************************************  
    BUSIF_DRIVEMNGBASE_GET_PARAMETER:      
      pResult^.aData[0]$DINT := (GetParameter())$DINT;   
  
  
   //**********************************************************************************************************************************************************  
    BUSIF_DRIVEMNGBASE_GET_CMD_STATE:  
      
      if ClassState = _ClassOk then
        pResult^.aData[0]$DINT := eInternalState$DINT;
      else
        pResult^.aData[0]$DINT := ClassState$DINT;
      end_if;  
  
   //**********************************************************************************************************************************************************  
    BUSIF_DRIVEMNGBASE_EXTERN_INIT_FINISH:  
      ExternInitFinished();      
 
  
   //**********************************************************************************************************************************************************  
    BUSIF_DRIVEMNGBASE_GET_AXIS_WR_PTR:      
      pResult^.aData[0]$DINT := (GetAxisWrPtr())$DINT;   
  
  
   //**********************************************************************************************************************************************************  
    BUSIF_DRIVEMNGBASE_GET_AXIS_RD_PTR:  
      pResult^.aData[0]$DINT := (GetAxisRdPtr())$DINT;   
  
  
   //**********************************************************************************************************************************************************  
    BUSIF_DRIVEMNGBASE_INIT_DRIVE:      
      InitDrive();    
  
  
   //**********************************************************************************************************************************************************  
    BUSIF_DRIVEMNGBASE_GET_SYNC_PARA:       
      pResult^.aData[0]$DINT := GetSyncParameter(us_value := (pPara^.aPara[1])$USINT
                                                , p_data  := (pPara^.aPara[2])$^DINT
                                                );                                                
      
  
   //**********************************************************************************************************************************************************  
    BUSIF_DRIVEMNGBASE_SET_SYNC_PARA:  
      pResult^.aData[0]$DINT := SetSyncParameter(us_value:= (pPara^.aPara[1])$USINT
                                                , sd_data:= (pPara^.aPara[2])
                                                );           
           
  
   //**********************************************************************************************************************************************************  
    BUSIF_DRIVEMNGBASE_GET_DRIVE_INT_State:    
      pResult^.aData[0]$DINT  := GetDriveIntState();  
      
    
   //**********************************************************************************************************************************************************  
    BUSIF_DRIVEMNGBASE_SDD_GETSERIES:    
      pResult^.aData[0] := 2;
      
  
   //**********************************************************************************************************************************************************  
    BUSIF_DRIVEMNGBASE_READ_FPGA_VERSION:      
      pResult^.aData[0]$HDINT := FPGAVersion.Read();   
  
  
   //**********************************************************************************************************************************************************  
    BUSIF_DRIVEMNGBASE_READ_RETRY_COUNTER:     
      pResult^.aData[0]$UDINT := RetryCounter.Read();  
  
  
   //**********************************************************************************************************************************************************  
    BUSIF_DRIVEMNGBASE_READ_DEVICEID:   
      pResult^.aData[0]$UDINT := DeviceID.Read();     
      
  
   //**********************************************************************************************************************************************************  
    BUSIF_DRIVEMNGBASE_SET_OBJECT_CALLBACK:      
      p_DriveMngBase := pPara^.aPara[0]$pVoid;
  
  
   //**********************************************************************************************************************************************************  
    BUSIF_DRIVEMNGBASE_GET_BUSTYPE:
      // first paramater is datalength of followed data
      if pPara^.aPara[0] = 0 then      
        pResult^.uiLng    := 1;
        pResult^.aData[0] := HWT_ESCAPE_SDIAS;
      else
        ret_code := ERROR;
      end_if;
  
  else
    //unknown command
    ret_code := ERROR;
    
  end_case;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL _BusInterfaceSdiasDriveMng::UpdateRt

  IF ClassState = _ClassOk then

    CASE eRtSSW OF   
//******************************************************************************************************************************************
      _GetSendParaList, _Operational:
        // update asynchron parameters
        GetObjectValue();           
    end_case;  

    //update in right intervall
    ud_TimeCounter -= 1;
    if ( ud_TimeCounter <> 0 ) then
      b_UpdateThisTime := FALSE;
      return;
    else
      b_UpdateThisTime := TRUE;
    end_if;

    ud_TimeCounter := TimeMultiplier;

    case eRtSSW of     

//******************************************************************************************************************************************
      _InitAxis:
      
        if b_AlreadyConnected = FALSE (*& AxisAvailableNo*) then         
          //set right para state	
          sAxisData.us_ParaReady  := _IdleState;
          sAxisData.e_AxisState   := _NoInit;        
          b_AlreadyConnected := TRUE;  
        end_if;

        if InitAxis() = _CyIdle$DINT then
          b_InitOk := TRUE;
          eRtSSW  := _GetSendParaList;
        end_if;

        
//******************************************************************************************************************************************
      _WaitForSynchrony:
      
        Synchron := 1;
        if Synchron then
          if ( sAxisData.e_AxisState <> _NotUsed ) then
            sAxisData.e_AxisState := _AxisOk;

            if sAxisData.b_ExtendedAxis then
              _memcpy(#sAxisData.s_ReadValues.a_SyncValues[ 0 ], #Accesses.pReadIso^.Value6, sizeof(t_DataReadOneAxis));
            else
              sAxisData.s_ReadValues.a_SyncValues[ 0 ] := Accesses.pReadIso^.Value6;
              sAxisData.s_ReadValues.a_SyncValues[ 1 ] := Accesses.pReadIso^.Value7;
            end_if;
          end_if;
        else
          if ( sAxisData.e_AxisState <> _NotUsed ) then
            sAxisData.e_AxisState := _NotSynchron;

            if sAxisData.b_ExtendedAxis then
              _memcpy(#sAxisData.s_ReadValues.a_SyncValues[ 0 ], #Accesses.pReadIso^.Value6, sizeof(t_DataReadOneAxis));
            else
              sAxisData.s_ReadValues.a_SyncValues[ 0 ] := Accesses.pReadIso^.Value6;
              sAxisData.s_ReadValues.a_SyncValues[ 1 ] := Accesses.pReadIso^.Value7;
            end_if;            
          end_if;
        end_if;
      
        eRtSSW    := _Operational;
        ClassState := _ClassOk;
        eInternalState := _ClassOk;
        

//******************************************************************************************************************************************
      _Operational:
      
        Synchron := 1;
        if Synchron then
            if ( sAxisData.e_AxisState <> _NotUsed ) then
              sAxisData.e_AxisState := _AxisOk;

              if sAxisData.b_ExtendedAxis then
                _memcpy(#sAxisData.s_ReadValues.a_SyncValues[ 0 ], #Accesses.pReadIso^.Value6, sizeof(t_DataReadOneAxis));
              else
                sAxisData.s_ReadValues.a_SyncValues[ 0 ] := Accesses.pReadIso^.Value6;
                sAxisData.s_ReadValues.a_SyncValues[ 1 ] := Accesses.pReadIso^.Value7;
              end_if;
            end_if;
        else
          if ( sAxisData.e_AxisState <> _NotUsed ) then
            sAxisData.e_AxisState := _NotSynchron;

            if sAxisData.b_ExtendedAxis then
              _memcpy(#sAxisData.s_ReadValues.a_SyncValues[ 0 ], #Accesses.pReadIso^.Value6, sizeof(t_DataReadOneAxis));
            else
              sAxisData.s_ReadValues.a_SyncValues[ 0 ] := Accesses.pReadIso^.Value6;
              sAxisData.s_ReadValues.a_SyncValues[ 1 ] := Accesses.pReadIso^.Value7;
            end_if;            
          end_if;
        end_if;
    end_case;
    
  end_if;


END_FUNCTION


FUNCTION VIRTUAL GLOBAL _BusInterfaceSdiasDriveMng::UpdateRtPostScan


  CASE eRtSSW OF
// ******************************************************************************************************************************************
    _InitAxis, _GetSendParaList, _Operational, _WaitForSynchrony: 
    
      IF Accesses.b_TempAsyData & Accesses.pWriteAsy then
        sAxisData.us_ParaReady  := _SendExecution; 
        Accesses.b_TempAsyData  := FALSE;               
      end_if;         
  end_case;            
      
  if b_UpdateThisTime then
    
    if ClassState = _ClassOk  then
    
      case eRtSSW of      
// ******************************************************************************************************************************************
        _Operational:

          if ( sAxisData.e_AxisState <> _NotUsed ) then
            if sAxisData.b_ExtendedAxis then
              _memcpy(#Accesses.pWriteIso^.Value1, #sAxisData.s_WriteValues.a_SyncValues[ 0 ], sizeof(t_DataWriteOneAxis));
            else
              Accesses.pWriteIso^.Value1 := sAxisData.s_WriteValues.a_SyncValues[ 0 ];
              Accesses.pWriteIso^.Value2 := sAxisData.s_WriteValues.a_SyncValues[ 1 ];
            end_if;
          end_if;
      end_case;
    end_if;    
  end_if;
  
END_FUNCTION


FUNCTION GLOBAL _BusInterfaceSdiasDriveMng::StartCommunication
	VAR_INPUT
		AxisExtend 	: BDINT;
		pServer4CallBack 	: ^BDINT;
	END_VAR

  ExtendedAxisSettings := AxisExtend;  
  pCallBackServer      := pServer4CallBack - sizeof(SvrCh.pMeth);

END_FUNCTION


FUNCTION GLOBAL _BusInterfaceSdiasDriveMng::SetParaList
	VAR_INPUT
		p_list 	: ^void;
		ui_counter 	: UINT;
	END_VAR
	VAR_OUTPUT
		sd_retval 	: DINT;
	END_VAR
  VAR
    p_Axis			: ^t_AxisData;
  END_VAR

  sd_retval := -1;

  //look if class is ok

  if ( ClassState = _ClassOk ) | ( GetDriveIntState()$t_RtSSW = _GetSendParaList ) then    
   
    p_Axis  := #sAxisData;

  //-----------------------------------------------------------------------------------------------
  //look if Axis is in use
  if ( p_Axis^.e_AxisState = _NotUsed ) then
    sd_retval := -3;
    return;
  end_if;

  //mark function as ok
  sd_retval := 0;

  //look if parameter handling is ready and list processing is active
  if	( p_Axis^.us_ParaReady = _IdleState
    & p_Axis^.b_ListActive = FALSE
    )
  then
    p_Axis^.p_ParaList$^void	:= p_list;
    p_Axis^.ui_ParaListCnt		:= ui_counter;
    
    // skip all defined parameter entries
    SkipEntries(p_Axis);

      //take over first parameter
      if ( p_Axis^.ui_ParaListCnt ) then
        IF SetParameter(uiParaID    := 0xFFFF
                      , usParaSubID := p_Axis^.p_ParaList^.us_number
                      , usRdWr      := TRUE
                      , pvalue      := #p_Axis^.p_ParaList^.sd_value
                      , bsDataInfo  := 0
                      ) = 0 then
          p_Axis^.b_ListActive		:= TRUE;
        p_Axis^.ui_ParaListCnt 	-= 1;
        p_Axis^.p_ParaList 		+= sizeof( t_ParaList );
        end_if;
      end_if;
    else
      //not ready
      sd_retval := -1;
    end_if;   
  else
    //not ready
    sd_retval := -1;
  end_if;

END_FUNCTION


FUNCTION GLOBAL _BusInterfaceSdiasDriveMng::SetParameter
	VAR_INPUT
		uiParaID 	: UINT;
		usParaSubID 	: USINT;
		usRdWr 	: USINT;
		pvalue 	: ^DINT;
		bsDataInfo 	: BSINT;
	END_VAR
	VAR_OUTPUT
		sd_retval 	: DINT;
	END_VAR
  VAR
    p_Axis		: ^t_AxisData;
  END_VAR

  sd_retval := -1;

  //look if class is ok
  if (ClassState <> _ClassOk ) & ( GetDriveIntState()$t_RtSSW <> _GetSendParaList ) then
    return;
  end_if;

  //look if init was ok
  if ( b_InitOk ) then
     //set pointer to axis 
    if (sAxisData.e_AxisState <> _NotUsed) then
      p_Axis	   := #sAxisData;  
    else
      sd_retval := -2;
      return;
    end_if;

    //----------------------------------------------------------------------------------------------
    //look if Axis is in use
    if ( p_Axis^.e_AxisState = _NotUsed ) then
      sd_retval := -3;
      return;
    end_if;

    //look if parameter handling is ready
    if	( p_Axis^.us_ParaReady = _IdleState
      & p_Axis^.b_ListActive = FALSE
      )
    then      
      if uiParaID = 0xFFFF then
        if usParaSubID >= BUSIF_SDIASDRIVEMNG_PARALIST_INDEX_SETNR  then
          ActAsyWriteData.ParaIndex    := BUSIF_SDIASDRIVEMNG_PARALIST_INDEX_INFO$UINT;
          usParaSubID := usParaSubID - (BUSIF_SDIASDRIVEMNG_PARALIST_INDEX_SETNR - 1);          
        else
          ActAsyWriteData.ParaIndex    := BUSIF_SDIASDRIVEMNG_PARALIST_INDEX_SET$UINT;
        end_if; 
        ActAsyWriteData.sd_ObjectValue[8]$DINT := pvalue^; // lasal parameter have only 4Byte length
      else
        ActAsyWriteData.ParaIndex := uiParaID;
      end_if;  
            
      ActAsyWriteData.RequestControl.DataLength1 := bsDataInfo.1;   
      ActAsyWriteData.RequestControl.DataLength2 := bsDataInfo.2;  
      ActAsyWriteData.ParaSubIndex := usParaSubID;      
      
      if ( usRdWr ) then
        ActAsyWriteData.RequestControl.ReadWriteObject := usRdWr$BOOL;
        
        Accesses.WriteAccessAsy.ActDoLength := BUSIF_SDIASDRIVEMNG_CANOPEN_FOOTER_SIZE + ((ActAsyWriteData.RequestControl shr 6) + 1) * BUSIF_SDIASDRIVEMNG_LASAL_PARADATA_SIZE;
        Accesses.WriteAccessAsy.ActDoOffset := (sizeof(t_SDOResponse) - Accesses.WriteAccessAsy.ActDoLength);
        
        Accesses.ReadAccessAsy.ActDoLength := BUSIF_SDIASDRIVEMNG_CANOPEN_FOOTER_SIZE;
        
        _memcpy(ptr1:=#ActAsyWriteData.sd_ObjectValue[0] + Accesses.WriteAccessAsy.ActDoOffset, ptr2:=pvalue, cntr:=Accesses.WriteAccessAsy.ActDoLength - BUSIF_SDIASDRIVEMNG_CANOPEN_FOOTER_SIZE);
      else
        ActAsyWriteData.RequestControl.ReadWriteObject := usRdWr$BOOL; 
        Accesses.WriteAccessAsy.ActDoLength := BUSIF_SDIASDRIVEMNG_CANOPEN_FOOTER_SIZE;
        Accesses.WriteAccessAsy.ActDoOffset := (sizeof(t_SDOResponse) - Accesses.WriteAccessAsy.ActDoLength);
        
        //set read length
        Accesses.ReadAccessAsy.ActDoLength := BUSIF_SDIASDRIVEMNG_CANOPEN_FOOTER_SIZE + ((ActAsyWriteData.RequestControl shr 6) + 1) * BUSIF_SDIASDRIVEMNG_LASAL_PARADATA_SIZE;
      end_if;      
          
      //set data for object handling
      p_Axis^.us_ParaReady   := _GotValueForExecution;
      
      Accesses.b_TempAsyData := TRUE;
      sd_retval := 0;
    end_if;    
  end_if;

END_FUNCTION


FUNCTION GLOBAL _BusInterfaceSdiasDriveMng::SetSyncParameter
	VAR_INPUT
		us_value 	: USINT;
		sd_data 	: DINT;
	END_VAR
	VAR_OUTPUT
		sd_retval 	: DINT;
	END_VAR
  VAR
    p_Axis_data		: ^t_AxisData;
    sd_extend		: DINT;
  END_VAR	

  //only if class is ok
  if ( ClassState = _ClassOk ) then
    sd_retval := 0;

    //look for right value
    if ( us_value > 4 ) then
      sd_retval := -2;
      return;
    end_if;

    //look which Axis we have and set pointers
//    if (us_Axis >= 0) & (us_Axis <= (usAxisAvailableNo-1)) then
    if (sAxisData.e_AxisState <> _NotUsed) then
      p_Axis_data			:= #sAxisData;
    else
      sd_retval := -3;
      return;
    end_if;

    sd_extend	:= sAxisData.b_ExtendedAxis;

    //only if Axis is ok
    if ( p_Axis_data^.e_AxisState = _AxisOk ) then

      //look if we have a extended value and extend mode is active else return
      if ( sd_extend	= 0 
        & us_value 	> 1
        ) 
      then

        sd_data := -4;
        return;
      end_if;
      
      p_Axis_data^.s_WriteValues.a_SyncValues[ us_value ] := sd_data;
    end_if;				
  else
    sd_retval := -1;
  end_if;

END_FUNCTION


FUNCTION GLOBAL _BusInterfaceSdiasDriveMng::GetSyncParameter
	VAR_INPUT
		us_value 	: USINT;
		p_data 	: ^DINT;
	END_VAR
	VAR_OUTPUT
		sd_retval 	: DINT;
	END_VAR
  VAR
    p_Axis_data		: ^t_AxisData;
    sd_extend		: DINT;
  END_VAR	

  //only if class is ok
  if ( ClassState = _ClassOk ) then
    sd_retval := 0;

    //look for right value
    if ( us_value > 4 ) then
      sd_retval := -2;
      return;
    end_if;

    //look which Axis we have and set pointers
//    if (us_Axis >= 0) & (us_Axis <= (usAxisAvailableNo-1)) then
    if  (sAxisData.e_AxisState <> _NotUsed) then
      p_Axis_data			:= #sAxisData;
    else
      sd_retval := -3;
      return;
    end_if;

    sd_extend	:= sAxisData.b_ExtendedAxis;
    
    //only if Axis is ok
    if ( p_Axis_data^.e_AxisState = _AxisOk ) then

      //look if we have a extended value and extend mode is active else return
      if	( sd_extend	= 0 ) &
          ( us_value  > 1 ) then

        sd_retval := -4;
        return;
      end_if;

      p_data^ := p_Axis_data^.s_ReadValues.a_SyncValues[ us_value ];	
    end_if;				
  else
    sd_retval := -1;
  end_if;

END_FUNCTION 


FUNCTION _BusInterfaceSdiasDriveMng::SkipEntries
	VAR_INPUT
		p_Axis 	: ^t_AxisData;
	END_VAR
  VAR
  	i         : UDINT;
    p_ActPara : ^USINT;
    b_ParaOK  : BOOL;
  END_VAR

  // if there are parameters to skip
  if s_SkipParameter.us_No > 0 then
    b_ParaOK := FALSE;
    
    // as long as the parameter is skipped and we have have still parameters in the list
    while (b_ParaOK = FALSE) & (p_Axis^.ui_ParaListCnt) do
      // set pointer on first value to skip
      p_ActPara := s_SkipParameter.p_Values;
      
      b_ParaOK := TRUE;
      
      // for all skip parameters
      for i := 0 to (s_SkipParameter.us_No - 1) do
        // if the actual parameter number is found in the skip parameter list
        if p_ActPara^ = p_Axis^.p_ParaList^.us_number then
          p_Axis^.ui_ParaListCnt 	-= 1;
          p_Axis^.p_ParaList 		  += sizeof( t_ParaList );
          
          b_ParaOK := FALSE;
          exit;
        end_if;
      
        p_ActPara += sizeof(USINT);
      end_for;
    end_while;
  end_if;

END_FUNCTION


FUNCTION GLOBAL _BusInterfaceSdiasDriveMng::GetParameterState
	VAR_OUTPUT
		sd_para_state 	: DINT;
	END_VAR
  VAR
    p_Axis			: ^t_AxisData;
  END_VAR
  
  sd_para_State := -1;

  //look if class is ok
  if (ClassState <> _ClassOk ) & ( GetDriveIntState()$t_RtSSW <> _GetSendParaList ) then
    return;
  end_if;

  //look if init was ok
  if ( b_InitOk ) then

    //------------------------------------------------------------------------------------------------
    //look which Axis we have and set pointers
//    if (us_Axis >= 0) & (us_Axis <= (usAxisAvailableNo-1)) then
  if (sAxisData.e_AxisState <> _NotUsed) then
      p_Axis			:= #sAxisData;
    else
      sd_para_State := -2;
      return;
    end_if;

    //----------------------------------------------------------------------------------------------
    //look if Axis is in use
    if ( p_Axis^.e_AxisState = _NotUsed ) then
      sd_para_State := -3;
      return;
    end_if;
    
    //look if parameter handling is ready
    if	( p_Axis^.us_ParaReady	= _IdleState 
      & p_Axis^.b_ListActive	= FALSE
      ) 
    then
      //look for an object handling error
      if (p_Axis^.sd_ObjectError = 0) then
        sd_para_State := 0;
      else
        sd_para_State := p_Axis^.sd_ObjectError;
      end_if;
    end_if;
  end_if;
      
END_FUNCTION


FUNCTION GLOBAL _BusInterfaceSdiasDriveMng::GetParameter
	VAR_OUTPUT
		sd_para_data 	: ^aBuffer;
	END_VAR
  
  //get last object value of right Axis
  if (sAxisData.e_AxisState <> _NotUsed) then
    OS_MT_WAIT(Accesses.pMutex);
    sd_para_data := (#sAxisData.sd_Asyncdata[0])$^aBuffer;
    OS_MT_SIGNAL(Accesses.pMutex);
  else
    sd_para_data^[0] := -1$USINT;
  end_if;

END_FUNCTION


FUNCTION GLOBAL _BusInterfaceSdiasDriveMng::GetDriveIntState
	VAR_OUTPUT
		retcode 	: DINT;
	END_VAR
  
  // to get the actual State of the rtwork State machine
  // retcode = 3 means Operational (MOD 4 is for model SDD100/5000 to have the same returncodes)
  retcode := eRtSSW$DINT MOD 4;
 
END_FUNCTION


FUNCTION _BusInterfaceSdiasDriveMng::InitAxis
	VAR_OUTPUT
		sd_retval 	: DINT;
	END_VAR
  VAR
    p_Axis			: ^t_AxisData;
    p_WriteIso  : ^t_DataWriteOneAxis;  
  END_VAR



  if ( b_InitOk = TRUE ) then
    return;
  end_if;

  //------------------------------------------------------------------------------------------------
  if (sAxisData.e_AxisState <> _NotUsed) then
    p_Axis			:= #sAxisData;
    p_WriteIso	:= Accesses.pWriteIso;
  else
    sd_retval := -2;
    return;
  end_if;

  //look which case we have
  case ( eInitSSW ) of 

  //****************************************************************************************************************** 
    _SetDataObjectOn:
        //is Axis in use
        if ( p_Axis^.e_AxisState <> _NotUsed ) then
          _memset(p_WriteIso, 16#00, p_Axis^.ud_DOLength); // reinit the memory before sending
          
          //clear asynchrone write memory 
          _memset(#ActAsyWriteData, 16#00, sizeof(ActAsyWriteData));
          
          //next step
          eInitSSW := _Wait4Read;
          
          Accesses.ReadAccessAsy.ActDoLength := BUSIF_SDIASDRIVEMNG_LASAL_PARADATA_SIZE + BUSIF_SDIASDRIVEMNG_CANOPEN_FOOTER_SIZE;
        
          if Accesses.ReadAccessAsy.ActDoLength <> Accesses.ReadAccessAsy.LastDoLength then
            Accesses.ReadAccessAsy.ActDoOffset := (sizeof(t_SDOResponse) - Accesses.ReadAccessAsy.ActDoLength);
            ChangeDO(AccessHandle := Accesses.ReadAccessAsy.AccessHandle
                    , NewOffset   := sTypeLabel.aMailBoxes[Accesses.ServiceIDNr].Response.Address + Accesses.ReadAccessAsy.ActDoOffset
                    , NewLength   := Accesses.ReadAccessAsy.ActDoLength
                    );
            Accesses.ReadAccessAsy.LastDoLength := Accesses.ReadAccessAsy.ActDoLength;         
          end_if;           
          
          EnableDO(pControlByte:=Accesses.ReadAccessAsy.pControlByte);
          
        else
          //go to idle state
          eInitSSW := _CyIdle;
        end_if;
          

  //****************************************************************************************************************** 
    _Wait4Read: // we have to wait another cycle, because at VARAN we need 1 more cycle to get the data
         //next step         
        eInitSSW := _SetInitAxis;
        
  
  //****************************************************************************************************************** 
    _SetInitAxis:

        GetReadData();
        
        if ( p_Axis^.e_AxisState = _NoInit ) then

          ActAsyWriteData.RequestControl.InitCommunication 	:= TRUE;
          
        end_if;
        
        p_Axis^.b_OldToggleState := ActAsyReadData.ResponseControl.ToggleBit;

        // toggle toggle bit
        ActAsyWriteData.RequestControl.ToggleBit := NOT ActAsyReadData.ResponseControl.ToggleBit;

         
        //next step and timestamp
        eInitSSW 		:= _SetEnableRead;
        ud_TimemarkInit := ops.tAbsolute;
        
        DisableDO(pControlByte:=Accesses.ReadAccessAsy.pControlByte);          
      
        Accesses.WriteAccessAsy.ActDoLength := BUSIF_SDIASDRIVEMNG_CANOPEN_FOOTER_SIZE;
        
        if Accesses.WriteAccessAsy.ActDoLength <> Accesses.WriteAccessAsy.LastDoLength then   
          Accesses.WriteAccessAsy.ActDoOffset := (sizeof(t_SDOResponse) - Accesses.WriteAccessAsy.ActDoLength);
          ChangeDO(AccessHandle := Accesses.WriteAccessAsy.AccessHandle
                  , NewOffset   := sTypeLabel.aMailBoxes[Accesses.ServiceIDNr].Request.Address + Accesses.WriteAccessAsy.ActDoOffset
                  , NewLength   := Accesses.WriteAccessAsy.ActDoLength
                  );
          Accesses.WriteAccessAsy.LastDoLength := Accesses.WriteAccessAsy.ActDoLength         ;
        end_if;
      
        SetWriteData();
        
        EnableDO(pControlByte:=Accesses.WriteAccessAsy.pControlByte);  
         
              
  //******************************************************************************************************************   
    _SetEnableRead:    
         
        EnableDO(pControlByte:=Accesses.ReadAccessAsy.pControlByte);
        
        DisableDO(pControlByte:=Accesses.WriteAccessAsy.pControlByte);
        //next step and timestamp
        eInitSSW 		:= _WaitInit; 
        
                  
  //****************************************************************************************************************** 
    _WaitInit:	//reset startobjecttransfer bit
    
        GetReadData();
        
        //look if Axis 1 must be init
        if ( p_Axis^.e_AxisState = _NoInit ) then
          //object must be executed, error in object handling must be set and error code must be 9
          if (( ActAsyReadData.ResponseControl.ToggleBit <> p_Axis^.b_OldToggleState)
              & ActAsyReadData.ResponseControl.ErrorInObjectHandling	= TRUE
              & ActAsyReadData.sd_ObjectValue[8]$DINT 			= 9
              )
          then
            //set Axis to next state	
            p_Axis^.e_AxisState := _NoParaList;
            //disable read access
            DisableDO(pControlByte:=Accesses.ReadAccessAsy.pControlByte);  
            eInitSSW := _SetFinishInit;
          end_if;
        end_if;  
        
        //after timeout check again
        if ( ops.tAbsolute - ud_TimemarkInit > 1sec ) then
          eInitSSW := _Wait4Read;
        end_if;	       
        

  //****************************************************************************************************************** 
    _SetFinishInit:
            
        //If Axis is in right state
        if ( p_Axis^.e_AxisState = _NoParaList ) then

          ActAsyWriteData.RequestControl.InitCommunication  := FALSE;
        end_if;

        p_Axis^.b_OldToggleState := ActAsyReadData.ResponseControl.ToggleBit;

        // toggle toggle bit
        ActAsyWriteData.RequestControl.ToggleBit := NOT ActAsyReadData.ResponseControl.ToggleBit;

        //next step and timestamp
        eInitSSW 		:= _SetDisableWrite;

        SetWriteData();

        EnableDO(pControlByte:=Accesses.WriteAccessAsy.pControlByte); 
                
        ud_TimemarkInit := ops.tAbsolute;        
        
           
  //******************************************************************************************************************   
    _SetDisableWrite:
  
        EnableDO(pControlByte:=Accesses.ReadAccessAsy.pControlByte);
        
        DisableDO(pControlByte:=Accesses.WriteAccessAsy.pControlByte);          
         
        //next step and timestamp
        eInitSSW 		:= _GetFinishInit;  
       
  //****************************************************************************************************************** 
    _GetFinishInit:
    
        GetReadData();
                
        //look if Axis is in use and error bit is reset
        if	( ActAsyReadData.ResponseControl.ErrorInObjectHandling = TRUE) &
            ( ActAsyReadData.ResponseControl.ToggleBit <> p_Axis^.b_OldToggleState)
        then                    
          //final step, init ok and class ok
          eInitSSW := _CyIdle;
          DisableDO(pControlByte:=Accesses.ReadAccessAsy.pControlByte); 
        else                      
          //try again if return value is 10 or 8 (see DiasDrive Doku)
          if	( ( ActAsyReadData.sd_ObjectValue[0]$DINT = 10| ActAsyReadData.sd_ObjectValue[0]$DINT = 8 )
            & ActAsyReadData.ResponseControl.ErrorInObjectHandling = TRUE
            ) 
          then
            eInitSSW 			    := _SetInitAxis;
            p_Axis^.e_AxisState := _NoInit;
            DisableDO(pControlByte:=Accesses.ReadAccessAsy.pControlByte); 
          end_if;

          //if timeout check again
          if ( ops.tAbsolute - ud_TimemarkInit > 2sec ) then
            eInitSSW := _SetFinishInit;
            DisableDO(pControlByte:=Accesses.ReadAccessAsy.pControlByte); 
          end_if;	
        end_if;
     
    
  //****************************************************************************************************************** 
    _CyIdle:	

  end_case;
  
  //return ssw
  sd_retval := eInitSSW$DINT;

END_FUNCTION

FUNCTION GLOBAL _BusInterfaceSdiasDriveMng::GetAxisRdPtr
	VAR_OUTPUT
		pReadPara 	: ^t_ReadValuePtr;
	END_VAR

  pReadPara := NIL;

  if (sAxisData.e_AxisState <> _NotUsed) then
    pReadPara := #sAxisData.s_ReadValues;
  end_if;

END_FUNCTION


FUNCTION GLOBAL _BusInterfaceSdiasDriveMng::GetAxisWrPtr
	VAR_OUTPUT
		pWritePara 	: ^t_WriteValuePtr;
	END_VAR

  pWritePara := NIL;

//  if (AxisNr >= 0) & (AxisNr <= (usAxisAvailableNo-1)) then
  if (sAxisData.e_AxisState <> _NotUsed) then
    pWritePara := #sAxisData.s_WriteValues;
  end_if;

END_FUNCTION


FUNCTION GLOBAL _BusInterfaceSdiasDriveMng::ExternInitFinished

  // if all axis parameters have been sent
 
  eRtSSW := _WaitForSynchrony;
    
END_FUNCTION


FUNCTION GLOBAL _BusInterfaceSdiasDriveMng::InitDrive
 
  if ( b_InitOk ) then

    eInternalState := _NotInitialized;
    
    if ( sAxisData.e_AxisState <> _NotUsed ) then
      sAxisData.e_AxisState := _NoInit;
    end_if;
    
    sAxisData.us_ParaReady := _IdleState;    

    b_InitOk  := FALSE;
    eInitSSW := _SetDataObjectOn;  
    eRtSSW   := _InitAxis;
   
  end_if;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL _BusInterfaceSdiasDriveMng::AddAccesses
	VAR_OUTPUT
		eModuleInitState 	: iprStates;
	END_VAR
  VAR
  	TempModuleState : iprStates;    
  	MyPara   : CmdStruct;
    MyResult : results;
  END_VAR

  eModuleInitState := BUSY; 
   
  case eInitAccesses of 
//*****************************************************************************************************  
    _CreateMutex:
  
      // create mutex for memory copy actions
      MyPara.uiCmd := SDIAS_CMD_CREATE_MUTEX;
      MyPara.aPara[0]$^CHAR := "SdiasDrive";
      MyPara.aPara[1]       := this$DINT;

      // initialize result (api pointer will not be returned in older bus interface versions)
      _memset(dest:=#MyResult.aData[0], usByte:=0, cntr:=12);

      TempModuleState := SdiasIn.NewInst(#MyPara, #MyResult);

      if (TempModuleState = READY) & MyResult.aData[8]$^LSL_MT_TYPE then
        Accesses.pMutex := MyResult.aData[4]$^void;
        mt_api := MyResult.aData[8]$^LSL_MT_TYPE;
      else
        LogError(pMsg:="@ZZZZ (_BusInterfaceSdiasDriveMng::AddAccesses) Failed to install mutex");
        eErrorInitAccesses := eInitAccesses;
        eInitAccesses := _ErrorInitAccesses;
        return;
      end_if;   
      ud_TimeOutTypeLabel := ops.tAbsolute;
      eInitAccesses := _ReadoutTypeLabel;
      
   
//*****************************************************************************************************  
   _ReadoutTypeLabel:
      
      //ssw to readout type label
      TempModuleState := ReadTypeLabel();
      
      if TempModuleState = READY then
        eInitAccesses := _AddAccesses;
      elsif TempModuleState = BUSY then
        eInitAccesses := _ReadoutTypeLabel;
      else    
        LogError(pMsg:="@ZZZZ (_BusInterfaceSdiasDriveMng::AddAccesses) Failed to read typelabel of modul");
        eErrorInitAccesses := eInitAccesses;
        eInitAccesses := _ErrorInitAccesses;
        return;
      end_if;   
      
   
//*****************************************************************************************************  
   _AddAccesses: 
   
    if sTypeLabel.PDOs.MICO.Length >= sizeof(t_DataReadOneAxis)  then
      TempModuleState := AddRdAccess(hOffset := sTypeLabel.PDOs.MICO.Address
                                    , uLength := (BUSIF_SDIASDRIVEMNG_LASAL_PARADATA_SIZE * 2) + (BUSIF_SDIASDRIVEMNG_LASAL_PARADATA_SIZE*3*ExtendedAxisSettings.1) 
                                    , ppData  := #Accesses.pReadIso
                                    , ppStateByte   := #Accesses.ReadAccessIso.pStateByte
                                    , ppControlByte := #Accesses.ReadAccessIso.pControlByte
                                    , pAccessHandle := #Accesses.ReadAccessIso.AccessHandle);
                
                
      if TempModuleState <> READY then
        LogError(pMsg:="@ZZZZ (_BusInterfaceSdiasDriveMng::AddAccesses) Failed to add iso read access for SDIAS module");
        eErrorInitAccesses := eInitAccesses;
        eInitAccesses := _ErrorInitAccesses;
        return;
      end_if;  
    else     
      LogError(pMsg:="@ZZZZ (_BusInterfaceSdiasDriveMng::AddAccesses) Failed to add iso read access for SDIAS module because there are not enough memory.");
    end_if;

    if sTypeLabel.PDOs.MOCI.Length >= sizeof(t_DataWriteOneAxis)  then  
      TempModuleState := AddWrAccess(hOffset := sTypeLabel.PDOs.MOCI.Address
                                    , uLength := (BUSIF_SDIASDRIVEMNG_LASAL_PARADATA_SIZE * 2) + (BUSIF_SDIASDRIVEMNG_LASAL_PARADATA_SIZE*3*ExtendedAxisSettings.1) 
                                    , ppData  := #Accesses.pWriteIso
                                    , ppStateByte   := #Accesses.WriteAccessIso.pStateByte
                                    , ppControlByte := #Accesses.WriteAccessIso.pControlByte
                                    , pAccessHandle := #Accesses.WriteAccessIso.AccessHandle);
                
               
      if TempModuleState <> READY then
        LogError(pMsg:="@ZZZZ (_BusInterfaceSdiasDriveMng::AddAccesses) Failed to add iso write access for SDIAS module");
        eErrorInitAccesses := eInitAccesses;
        eInitAccesses := _ErrorInitAccesses;
        return;
      end_if;
      sAxisData.ud_DOLength := (BUSIF_SDIASDRIVEMNG_LASAL_PARADATA_SIZE * 2) + (BUSIF_SDIASDRIVEMNG_LASAL_PARADATA_SIZE*3*ExtendedAxisSettings.1);
    else     
      LogError(pMsg:="@ZZZZ (_BusInterfaceSdiasDriveMng::AddAccesses) Failed to add iso write access for SDIAS module because there are not enough memory.");
    end_if;

    if sTypeLabel.aMailBoxes[Accesses.ServiceIDNr].Response.Length >= sizeof(t_SDOResponse) then     
      MyPara.uiCmd := SDIAS_CMD_ADD_DYN_RD_ACCESS;
       
      MyPara.aPara[0] := this$DINT;
      MyPara.aPara[1] := Place$DINT;
      MyPara.aPara[2] := Required;
      MyPara.aPara[3] := sTypeLabel.aMailBoxes[Accesses.ServiceIDNr].Response.Address;
      MyPara.aPara[4] := sizeof(t_SDOResponse);
      MyPara.aPara[5] := (#Accesses.pReadAsy)$DINT;
      MyPara.aPara[6] := (#Accesses.ReadAccessAsy.pStateByte)$DINT;
      MyPara.aPara[7] := (#Accesses.ReadAccessAsy.pControlByte)$DINT;
      MyPara.aPara[8] := (#Accesses.ReadAccessAsy.AccessHandle)$DINT;
      MyPara.aPara[9] := 0; // wait for access handle;
      MyPara.aPara[10]:= 0; // it's a memory access;

      TempModuleState := SdiasIn.NewInst(#MyPara, #MyResult);
      
      if TempModuleState <> READY then
        LogError(pMsg:="@ZZZZ (_BusInterfaceSdiasDriveMng::AddAccesses) Failed to add asy read access for SDIAS module");
        eErrorInitAccesses := eInitAccesses;
        eInitAccesses := _ErrorInitAccesses;
        return;
      end_if;
    else     
      LogError(pMsg:="@ZZZZ (_BusInterfaceSdiasDriveMng::AddAccesses)  Failed to add asy read access for SDIAS module because there are not enough memory.");
    end_if;
      
    if sTypeLabel.aMailBoxes[Accesses.ServiceIDNr].Request.Length >= sizeof(t_SDORequest) then  
    
      MyPara.uiCmd := SDIAS_CMD_ADD_DYN_WR_ACCESS;
       
      MyPara.aPara[0] := this$DINT;
      MyPara.aPara[1] := Place$DINT;
      MyPara.aPara[2] := Required;
      MyPara.aPara[3] := sTypeLabel.aMailBoxes[Accesses.ServiceIDNr].Request.Address;
      MyPara.aPara[4] := sizeof(t_SDORequest);
      MyPara.aPara[5] := (#Accesses.pWriteAsy)$DINT;
      MyPara.aPara[6] := (#Accesses.WriteAccessAsy.pStateByte)$DINT;
      MyPara.aPara[7] := (#Accesses.WriteAccessAsy.pControlByte)$DINT;
      MyPara.aPara[8] := (#Accesses.WriteAccessAsy.AccessHandle)$DINT;
      MyPara.aPara[9] := 0; // wait for access handle;
      MyPara.aPara[10]:= 0; // it's a memory access;

      TempModuleState := SdiasIn.NewInst(#MyPara, #MyResult);
      
      if TempModuleState <> READY then
        LogError(pMsg:="@ZZZZ (_BusInterfaceSdiasDriveMng::AddAccesses) Failed to add asy write access for SDIAS module");
        eErrorInitAccesses := eInitAccesses;
        eInitAccesses := _ErrorInitAccesses;
        return;
      end_if;   
    end_if;    
    eInitAccesses := _FinishInitAccesses;
    
    
//*****************************************************************************************************  
   _FinishInitAccesses: 
    eModuleInitState := READY;
    eInitState       := _ClassOk;
       
//*****************************************************************************************************  
   _ErrorInitAccesses: 
    eModuleInitState := ERROR;
    if (eInitState <> _InvalidConfguration) then
      eInitState     := _ClientNotready;
    end_if;  
    
  end_case;

END_FUNCTION

FUNCTION _BusInterfaceSdiasDriveMng::ChangeDO
	VAR_INPUT
		AccessHandle 	: UDINT;
		NewOffset 	: HDINT;
		NewLength 	: UDINT;
	END_VAR
  VAR
  	MyPara   : CmdStruct;
    MyResult : results;
  END_VAR

  MyPara.uiCmd := SDIAS_CMD_CHANGE_DYN_ACCESS;
  MyPara.aPara[0] := AccessHandle$DINT;
  MyPara.aPara[1] := NewOffset$DINT;
  MyPara.aPara[2] := NewLength$DINT;
  SdiasIn.NewInst(#MyPara, #MyResult);

END_FUNCTION

FUNCTION _BusInterfaceSdiasDriveMng::ReadTypeLabel
	VAR_OUTPUT
		eModuleInitState 	: iprStates;
	END_VAR
  VAR
  	TmpRetcode  : iprStates;
    tempi       : USINT;
  END_VAR
  
  eModuleInitState       := BUSY;
  eErrorStepTypeLabelSSW := _NoErrorReadTypeLabel;
  
  CASE eReadTypeLabelSSW OF   
//**********************************************************************************************************************************************************
    _ReadFirst2Bytes:
      case eResponseState of
        _idle:

          //first read 2 byte to check if typelabel is valid
          usReadLengthTypeLabel := 2;    
          TmpRetcode            := StartReadSDO(hOffset:=BUSIF_SDIASDRIVEMNG_OFFSET_TYPELABEL + usReadTypeLabelOffset, usLength:=usReadLengthTypeLabel, eCommand:=SDIAS_SDO_CMD_MEM_READ);  
                    
          if TmpRetcode = READY then
            udSDOTimeout      := ops.tAbsolute;
            eResponseState    := _wait; 
          elsif TmpRetcode = ERROR then
            eModuleInitState := ERROR;
            LogError("@ZZZZ (_BusInterfaceSdiasDriveMng::ReadTypeLabel) Failed to add read SDO for type label");
            eInitState := _NoMem;
          end_if; 
          //*****************************************************
        _wait:
          // wait for response
          if ((ops.tAbsolute - udSDOTimeout) > BUSIF_SDIASDRIVEMNG_SDO_RESPONSE_TIMEOUT) then
            LogError("@ZZZZ (_BusInterfaceSdiasDriveMng::ReadTypeLabel) SDO Response timeout read state");
            eErrorStepTypeLabelSSW  := eReadTypeLabelSSW;
            eReadTypeLabelSSW       := _TypeLabelError;
          end_if;
        //*****************************************************
        _valid:
          if (sTypeLabel.VersionMinor)$UINT <> 0 then
            usReadTypeLabelOffset += usReadLengthTypeLabel;
            eResponseState  := _idle;
            eReadTypeLabelSSW  := _ReadTypeLabel;
          else
            eReadTypeLabelSSW  := _ReadFirst2Bytes;
            if (ops.tAbsolute - ud_TimeOutTypeLabel) > BUSIF_SDIASDRIVEMNG_SDO_TYPELABEL_TIMEOUT then            
              LogError("@ZZZZ (_BusInterfaceSdiasDriveMng::ReadTypeLabel) SDO Response timeout read type label");
              eErrorStepTypeLabelSSW  := eReadTypeLabelSSW;
              eReadTypeLabelSSW       := _TypeLabelError;
            end_if;
          end_if;   
      end_case;  
//**********************************************************************************************************************************************************
    _ReadTypeLabel:
      case eResponseState of
        _idle:
          // last byte of VANDALMapping is for axisavailable and must be read seperatly
          if usReadTypeLabelOffset < sizeof(t_VANDALMapping) - 1 then          
            usReadLengthTypeLabel := sizeof(t_VANDALMapping) - usReadTypeLabelOffset;
            if usReadLengthTypeLabel > SDIAS_MAX_SDO_READ_LENGTH then              
              usReadLengthTypeLabel := SDIAS_MAX_SDO_READ_LENGTH;
            else
              usReadLengthTypeLabel -= 1;   // last byte is for axisavailable and must be read seperatly
            end_if;           
            TmpRetcode  := StartReadSDO(hOffset:=BUSIF_SDIASDRIVEMNG_OFFSET_TYPELABEL + usReadTypeLabelOffset, usLength:=usReadLengthTypeLabel, eCommand:=SDIAS_SDO_CMD_MEM_READ);  
              
            if TmpRetcode = READY then
              udSDOTimeout      := ops.tAbsolute;
              eResponseState    := _wait; 
            elsif TmpRetcode = ERROR then
              eModuleInitState := ERROR;
              LogError("@ZZZZ (_BusInterfaceSdiasDriveMng::ReadTypeLabel) Failed to add read SDO for type label");
              eInitState := _NoMem;
            end_if; 
          else
            eReadTypeLabelSSW := _CheckServiceID;               
          end_if;
          //*****************************************************
        _wait:
          // wait for response
          if ((ops.tAbsolute - udSDOTimeout) > BUSIF_SDIASDRIVEMNG_SDO_RESPONSE_TIMEOUT) then
            LogError("@ZZZZ (_BusInterfaceSdiasDriveMng::ReadTypeLabel) SDO Response timeout read state");
            eErrorStepTypeLabelSSW := eReadTypeLabelSSW;
            eReadTypeLabelSSW      := _TypeLabelError;
          end_if;
        //*****************************************************
        _valid:
          usReadTypeLabelOffset += usReadLengthTypeLabel;
          eResponseState    := _idle;
          eReadTypeLabelSSW := _ReadTypeLabel;
      end_case;
      
      
//**********************************************************************************************************************************************************
    _CheckServiceID:

      if (sTypeLabel.DeviceID shr 31) then // if this bit is set, the module is in bootloader mode. retry readout of typelabel.
        usReadTypeLabelOffset := 0;
        eReadTypeLabelSSW     := _ReadFirst2Bytes; 
          if (ops.tAbsolute - ud_TimeOutTypeLabel) > BUSIF_SDIASDRIVEMNG_SDO_TYPELABEL_TIMEOUT then            
            LogError("@ZZZZ (_BusInterfaceSdiasDriveMng::ReadTypeLabel) SDO Response timeout read type label");
            eErrorStepTypeLabelSSW := eReadTypeLabelSSW;
            eReadTypeLabelSSW      := _TypeLabelError;
          end_if;
      else
        for tempi := 0 to BUSIF_SDIASDRIVEMNG_MAX_SERVICEBOX - 1 do
          if sTypeLabel.aMailBoxes[tempi].ID = BUSIF_SDIASDRIVEMNG_SDO_SERVICE_APP_CANOPEN then
            Accesses.ServiceIDNr := tempi;
          end_if;
        end_for;    
        eReadTypeLabelSSW := _ReadAxisAmount; 
      end_if;     
      
     
//**********************************************************************************************************************************************************
    _ReadAxisAmount:
      case eResponseState of
        _idle:
        
          //read DeviceInfoPointer to get amount of axis available
          usReadLengthTypeLabel := 1;    
          TmpRetcode            := StartReadSDO(hOffset:=sTypeLabel.DeviceInfoPointer, usLength:=usReadLengthTypeLabel, eCommand:=SDIAS_SDO_CMD_MEM_READ);  
            
          if TmpRetcode = READY then
            udSDOTimeout      := ops.tAbsolute;
            eResponseState    := _wait; 
          elsif TmpRetcode = ERROR then
            eModuleInitState := ERROR;
            LogError("@ZZZZ (_BusInterfaceSdiasDriveMng::ReadTypeLabel) Failed to read SDO DeviceInfoPointer");
            eInitState := _NoMem;
          end_if; 
          //*****************************************************
        _wait:
          // wait for response
          if ((ops.tAbsolute - udSDOTimeout) > BUSIF_SDIASDRIVEMNG_SDO_RESPONSE_TIMEOUT) then
            LogError("@ZZZZ (_BusInterfaceSdiasDriveMng::ReadTypeLabel) SDO Response timeout read state");
            eErrorStepTypeLabelSSW  := eReadTypeLabelSSW;
            eReadTypeLabelSSW       := _TypeLabelError;
          end_if;       
        //*****************************************************
        _valid:
          usReadTypeLabelOffset += usReadLengthTypeLabel;
          eResponseState    := _idle;
          eReadTypeLabelSSW := _TypeLabelFinish;          
      end_case;      
      
//**********************************************************************************************************************************************************
    _TypeLabelFinish:
      eReadTypeLabelSSW := _ReadFirst2Bytes;
      eModuleInitState  := READY;
      
          
//**********************************************************************************************************************************************************
    _TypeLabelError:
      eModuleInitState := ERROR; 
      
//**********************************************************************************************************************************************************
  end_case;   

END_FUNCTION


FUNCTION VIRTUAL _BusInterfaceSdiasDriveMng::ReceiveSDOResponse
	VAR_INPUT
		eCommand 	: t_SDIAS_SDO_Cmd;
		hOffset 	: HINT;
		usLength 	: USINT;
		eResult 	: iprStates;
		pResponseBuffer 	: ^USINT;
		ResponseLength 	: USINT;
	END_VAR
	VAR_OUTPUT
		ret_code 	: iprStates;
	END_VAR  

  ret_code := SdiasBase::ReceiveSDOResponse(eCommand, hOffset, usLength, eResult, pResponseBuffer, ResponseLength);
  
  if eResult = READY then    
    case eCommand of      
      SDIAS_SDO_CMD_MEM_READ:
        if eResponseState = _wait then
          eResponseState := _valid;
        end_if;
        _memcpy(ptr1:= (#sTypeLabel + usReadTypeLabelOffset), ptr2:=pResponseBuffer, cntr:=usReadLengthTypeLabel);
    end_case;
    
    if eResponseState <> _valid then
      LogError("@ZZZZ (_BusInterfaceSdiasDriveMng::ReceiveSDOResponse) Error in response data of SDO");
      eReadTypeLabelSSW := _TypeLabelError;      
    end_if;
  else
    case eCommand of
      SDIAS_SDO_CMD_MEM_READ:
        LogError("@ZZZZ (_BusInterfaceSdiasDriveMng::ReceiveSDOResponse) Error while waiting for type label");
    end_case;
    eReadTypeLabelSSW := _TypeLabelError;
  end_if;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL _BusInterfaceSdiasDriveMng::ConnectEvent
   
  if Accesses.ReadAccessIso.pControlByte then
    Accesses.ReadAccessIso.pControlByte^.EnableDO := TRUE;
  else
    ClassState := _DOHandleInvalid;
    return;
  end_if; 

  if Accesses.WriteAccessIso.pControlByte then
    Accesses.WriteAccessIso.pControlByte^.EnableDO := TRUE;
  else
    ClassState := _DOHandleInvalid;
    return;
  end_if;  
  
  TimeMultiplier := TimeMultiplier.Read();
  if ( TimeMultiplier = 0 ) then
    TimeMultiplier := 1;
  end_if;
  
	ud_TimeCounter  := TimeMultiplier;
  ud_TimemarkInit := ops.tAbsolute;
  AxisAvailableHW := sTypeLabel.AxisAvailable$BSINT; 
  
  sAxisData.b_ExtendedAxis := ExtendedAxisSettings.1;

  if pCallBackServer then
    WR(pt:=pCallBackServer, dData:=AxisAvailableHW$DINT);  
  end_if;
  
  //---------------------------------------------------------------------------------------------------------
	//class is not initialized
  b_AlreadyConnected := FALSE;
  ClassState  := _NotInitialized;
	eInitSSW    := _SetDataObjectOn; 
  eRtSSW      := _InitAxis;
  eInitState  := _ClassOk;
  Online      := 1; 

END_FUNCTION


FUNCTION VIRTUAL _BusInterfaceSdiasDriveMng::GetTaskCfg
	VAR_OUTPUT
		TaskCfg 	: BDINT;
	END_VAR

  TaskCfg := SDIAS_TASK_MASK_RT_PRE OR SDIAS_TASK_MASK_RT_POST;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL _BusInterfaceSdiasDriveMng::DisconnectEvent
  
  b_InitOk			:= FALSE;
  
	//look if Axis are in use  
  sAxisData.e_AxisState := _NotUsed;
  sAxisData.b_ListActive := FALSE;
  sAxisData.us_ParaReady := _IdleState;
  //reset do length to get a changedo if modul is reconnected
  Accesses.ReadAccessAsy.LastDoLength   := 0;
  Accesses.WriteAccessAsy.LastDoLength  := 0;
  
  SdiasBase::DisconnectEvent();
  
  Online := 0;
  
END_FUNCTION


FUNCTION _BusInterfaceSdiasDriveMng::GetObjectValue
  VAR
    p_Axis			  : ^t_AxisData;
  END_VAR

  //------------------------------------------------------------------------------------------------
  //look which Axis we have and set pointers
  if (sAxisData.e_AxisState <> _NotUsed) then
    p_Axis	 := #sAxisData;  
  else
    //else do nothing (should not come her)
    return;
  end_if;  
  
    //------------------------------------------------------------------------------------------------
    //get to right step
    case ( p_Axis^.us_ParaReady ) of
      
    //******************************************************************************************************************   
      _SendExecution:// now toggle the togglebit to start tell the drive, that the data are complete (no chance for byte errors in this way)      
      
          // toggle toggle bit
          ActAsyWriteData.RequestControl.ToggleBit := NOT ActAsyReadData.ResponseControl.ToggleBit;

          if Accesses.WriteAccessAsy.ActDoLength <> Accesses.WriteAccessAsy.LastDoLength then   
            Accesses.WriteAccessAsy.ActDoOffset := (sizeof(t_SDOResponse) - Accesses.WriteAccessAsy.ActDoLength);
            ChangeDO(AccessHandle := Accesses.WriteAccessAsy.AccessHandle
                    , NewOffset   := sTypeLabel.aMailBoxes[Accesses.ServiceIDNr].Request.Address + Accesses.WriteAccessAsy.ActDoOffset
                    , NewLength   := Accesses.WriteAccessAsy.ActDoLength
                    );
            Accesses.WriteAccessAsy.LastDoLength := Accesses.WriteAccessAsy.ActDoLength         ;
          end_if;            
          
          //send transmit execution request for object handling
          p_Axis^.b_OldToggleState := ActAsyReadData.ResponseControl.ToggleBit;
          
          //reset error and go to next step
          p_Axis^.sd_ObjectError := 0;
          p_Axis^.us_ParaReady := _EnableRead;  
          
          SetWriteData();
          
          EnableDO(pControlByte := Accesses.WriteAccessAsy.pControlByte);   
   
    //******************************************************************************************************************   
      _EnableRead:
            
          Accesses.ReadAccessAsy.ActDoLength := BUSIF_SDIASDRIVEMNG_LASAL_PARADATA_SIZE + BUSIF_SDIASDRIVEMNG_CANOPEN_FOOTER_SIZE;
          
          if Accesses.ReadAccessAsy.ActDoLength <> Accesses.ReadAccessAsy.LastDoLength then 
            Accesses.ReadAccessAsy.ActDoOffset := (sizeof(t_SDOResponse) - Accesses.ReadAccessAsy.ActDoLength);
            ChangeDO(AccessHandle := Accesses.ReadAccessAsy.AccessHandle
                    , NewOffset   := sTypeLabel.aMailBoxes[Accesses.ServiceIDNr].Response.Address + Accesses.ReadAccessAsy.ActDoOffset
                    , NewLength   := Accesses.ReadAccessAsy.ActDoLength
                    );
            Accesses.ReadAccessAsy.LastDoLength := Accesses.ReadAccessAsy.ActDoLength         ;
          end_if;           
           
          DisableDO(pControlByte:=Accesses.WriteAccessAsy.pControlByte);
           
          EnableDO(pControlByte:=Accesses.ReadAccessAsy.pControlByte);           
          
          //next step
          p_Axis^.us_ParaReady := _Wait4Response;  
             
      
    //******************************************************************************************************************   
      _Wait4Response:		//wait until receive state is 
      
          OS_MT_WAIT(Accesses.pMutex);
          GetReadData();
          OS_MT_SIGNAL(Accesses.pMutex);
          
          if ActAsyWriteData.ParaIndex = ActAsyReadData.ParaIndex
           & ActAsyWriteData.ParaSubIndex = ActAsyReadData.ParaSubIndex  then                
            
            if ( ActAsyReadData.ResponseControl.ToggleBit <> p_Axis^.b_OldToggleState) then

              //look if we have a parameter list
              if ( p_Axis^.b_ListActive = TRUE ) then
                
                // skip all defined parameter entries
                SkipEntries(p_Axis:=p_Axis); 
                
                //have we set all parameter
                if ( p_Axis^.ui_ParaListCnt ) then
                
                  //send transmit execution request for object handling
                  p_Axis^.b_OldToggleState := ActAsyReadData.ResponseControl.ToggleBit;

                  // toggle toggle bit
                  ActAsyWriteData.RequestControl.ToggleBit := NOT ActAsyReadData.ResponseControl.ToggleBit;

                  //reset error and go to next step
                  p_Axis^.sd_ObjectError := 0;
                  p_Axis^.us_ParaReady := _EnableRead;
                  
                  if p_Axis^.p_ParaList^.us_number >= BUSIF_SDIASDRIVEMNG_PARALIST_INDEX_SETNR  then
                    ActAsyWriteData.ParaIndex     := BUSIF_SDIASDRIVEMNG_PARALIST_INDEX_INFO$UINT;
                    p_Axis^.p_ParaList^.us_number := p_Axis^.p_ParaList^.us_number - (BUSIF_SDIASDRIVEMNG_PARALIST_INDEX_SETNR - 1);
                  else
                    ActAsyWriteData.ParaIndex    := BUSIF_SDIASDRIVEMNG_PARALIST_INDEX_SET$UINT;
                  end_if;
                  
                  ActAsyWriteData.ParaSubIndex		        := p_Axis^.p_ParaList^.us_number;
                  ActAsyWriteData.sd_ObjectValue[8]$DINT	:= p_Axis^.p_ParaList^.sd_value;
                  //4 Byte datalength for Lasal Parameter
                  ActAsyWriteData.RequestControl.ReadWriteObject := TRUE;           
                  
                  ActAsyWriteData.RequestControl.DataLength1 := 0;   
                  ActAsyWriteData.RequestControl.DataLength2 := 0;                    
                  
                  ActAsyWriteData.RequestControl.ReadWriteObject := 1;

                  Accesses.WriteAccessAsy.ActDoLength := BUSIF_SDIASDRIVEMNG_CANOPEN_FOOTER_SIZE + BUSIF_SDIASDRIVEMNG_LASAL_PARADATA_SIZE;
                  
                  Accesses.ReadAccessAsy.ActDoLength := BUSIF_SDIASDRIVEMNG_CANOPEN_FOOTER_SIZE;                        
                  
                  if Accesses.WriteAccessAsy.ActDoLength <> Accesses.WriteAccessAsy.LastDoLength then   
                    Accesses.WriteAccessAsy.ActDoOffset := (sizeof(t_SDOResponse) - Accesses.WriteAccessAsy.ActDoLength);
                    ChangeDO(AccessHandle := Accesses.WriteAccessAsy.AccessHandle
                            , NewOffset   := sTypeLabel.aMailBoxes[Accesses.ServiceIDNr].Request.Address + Accesses.WriteAccessAsy.ActDoOffset
                            , NewLength   := Accesses.WriteAccessAsy.ActDoLength
                            );
                    Accesses.WriteAccessAsy.LastDoLength := Accesses.WriteAccessAsy.ActDoLength         ;
                  end_if;                    
                  
                  SetWriteData();
                  
                  EnableDO(pControlByte := Accesses.WriteAccessAsy.pControlByte);            

                  //set next parameter step and set pointer to next parameter data
                  p_Axis^.us_ParaReady 	:= _EnableRead;  // _SendExecution;
                  
                  //disable read access
                  DisableDO(pControlByte:=Accesses.ReadAccessAsy.pControlByte);                
                  p_Axis^.ui_ParaListCnt 	-= 1;
                  p_Axis^.p_ParaList 		+= sizeof( t_ParaList );
                
                else
                  //set ssw to idle and deactivate parameter list
                  p_Axis^.b_ListActive 	:= FALSE;
                  
                  //look if we get a parameter list
                  if ( p_Axis^.e_AxisState = _NoParaList ) then 
                    p_Axis^.e_AxisState		:= _NotSynchron;
                  end_if;

                  p_Axis^.us_ParaReady 	:= _IdleState;    
                  //disable read access
                  DisableDO(pControlByte:=Accesses.ReadAccessAsy.pControlByte);  
                end_if;

              else
                //disable read access
                DisableDO(pControlByte:=Accesses.ReadAccessAsy.pControlByte);  
                //look for an object error
                if ( ActAsyReadData.ResponseControl.ErrorInObjectHandling = TRUE ) then
                  p_Axis^.sd_ObjectError := ActAsyReadData.sd_ObjectValue[8]$DINT;              
                end_if;
                
                OS_MT_WAIT(Accesses.pMutex);
                  //readout actual value from module
                  _memcpy(ptr1:=#p_Axis^.sd_Asyncdata, ptr2:=#ActAsyReadData.sd_ObjectValue[0] + Accesses.ReadAccessAsy.ActDoOffset, cntr:=Accesses.ReadAccessAsy.ActDoLength);              
                OS_MT_SIGNAL(Accesses.pMutex); 
//                       
                //get to idle step
                p_Axis^.us_ParaReady := _IdleState; 
                  
              end_if;
            end_if;
          end_if;
    //******************************************************************************************************************   
      _IdleState:				//do nothing in this step

    end_case;


END_FUNCTION



FUNCTION VIRTUAL GLOBAL _BusInterfaceSdiasDriveMng::CheckDeviceID
	VAR_INPUT
		udID2Check 	: UDINT;
	END_VAR
	VAR_OUTPUT
		bIsOK 	: BOOL;
	END_VAR
  
  //look if it is right hardware
  if ( udID2Check <>  SdiasID) then
    bIsOK := FALSE;
  else
    bIsOK := TRUE;
  end_if;

END_FUNCTION


FUNCTION _BusInterfaceSdiasDriveMng::EnableDO
	VAR_INPUT
		pControlByte 	: ^t_SDIAS_ControlByte;
	END_VAR
  
  if pControlByte then    
    pControlByte^.EnableDO := TRUE;
  else
    ClassState := _DOHandleInvalid;   
  end_if;           
  
END_FUNCTION


FUNCTION _BusInterfaceSdiasDriveMng::DisableDO
	VAR_INPUT
		pControlByte 	: ^t_SDIAS_ControlByte;
	END_VAR  
   
  if pControlByte then
    pControlByte^.EnableDO := FALSE;
  else
    ClassState := _DOHandleInvalid;   
  end_if;     
  
END_FUNCTION


FUNCTION _BusInterfaceSdiasDriveMng::SetWriteData

  // copy the actual write data to the DPRAM
  
  _memcpy(ptr1:=Accesses.pWriteAsy, ptr2:=(#ActAsyWriteData + Accesses.WriteAccessAsy.ActDoOffset), cntr:=Accesses.WriteAccessAsy.ActDoLength);
  

END_FUNCTION


FUNCTION _BusInterfaceSdiasDriveMng::GetReadData

  // copy the actual read data from the DPRAM
  
  _memcpy(ptr1:=(#ActAsyReadData + Accesses.ReadAccessAsy.ActDoOffset), ptr2:=Accesses.pReadAsy, cntr:=Accesses.ReadAccessAsy.ActDoLength);
  

END_FUNCTION





FUNCTION VIRTUAL GLOBAL _BusInterfaceSdiasDriveMng::ClassState::NewInst
	VAR_INPUT
		pPara 	: ^CmdStruct;
		pResult 	: ^Results;
	END_VAR
	VAR_OUTPUT
		ret_code 	: IprStates;
	END_VAR 
  VAR  	  
    pStr_HWTRequested : ^CHAR;
    us_HWTRequestedCurrIndex : USINT;
  END_VAR
  
  pStr_HWTRequested := NIL;
  us_HWTRequestedCurrIndex := 0;

  ret_code:= READY;

  case ( pPara^.uiCmd ) of
  
    CMD_GET_HARDWARE_DIAGNOSIS :     
        
        ret_code := ERROR;
        pStr_HWTRequested := pPara^.aPara[0]$t_HWCGetHardwareTreeEntryIn.pStr_LastHardewareTreeEntry;
        
        if pStr_HWTRequested & pObjectPath then
          // Needed as default for 
          ret_code := READY;

          if (pStr_HWTRequested$^USINT^ = pObjectPath^) then // Check if the call was to the Mng
            // Call base 1st as it as info from SPI accesses
            ret_code := SdiasBase::ClassState.NewInst(pPara, pResult);  // Pass on command to base         
          end_if;        
            
          if (p_DriveMngBase) then
             
            // Call Mng, may overwrite some data, has got at least additional info on the FW version                    
            ret_code := p_DriveMngBase$^VirtualBase^.NewInst(pPara,pResult);          
            
          end_if; 
        end_if;

    CMD_GET_HARDWARE_TREE_ENTRY :          
        
        ret_code := ERROR;
        
        pStr_HWTRequested := pPara^.aPara[0]$t_HWCGetHardwareTreeEntryIn.pStr_LastHardewareTreeEntry;      
        
        // Check HWT String
        if pStr_HWTRequested & pObjectPath then      
          
          // Check if the passed string is smaller than the own string
          if pStr_HWTRequested$^USINT^ < pObjectPath^ then        
        
            // Call base
            ret_code := SdiasBase::ClassState.NewInst(pPara, pResult);  // Pass on command to base 
          
          // Check if last call was to Base itself
          // Compare string content
          elsif _memcmp( ptr1 := pStr_HWTRequested + 2, 
                         ptr2 := pObjectPath + 1, 
                         cntr := pObjectPath^) = 0 then
                              
            // Compare string length
            if (pStr_HWTRequested$^USINT^ = pObjectPath^) then
          
              // Last module called was the Drivemng itself, next module is the 1st axis behind the manager        
              if p_DriveMngBase then
                ret_code := p_DriveMngBase$^VirtualBase^.NewInst(pPara, pResult); // Pass on command to drive manager 
              end_if;
            
            elsif (pStr_HWTRequested$^USINT^ > pObjectPath^ + 1) then // Must be at least 2 Bytey larger, ESCAPE Sequence + Place
              
              // Check escape sequence
              if ( (pStr_HWTRequested + (pObjectPath^) + 2 )^ = HWT_ESCAPE_DRIVE) then // First place after manager Itself is escape sequence + 1 for addional length byte
                // Last Module must have been a Axis Module behind the manager
                // Update index
                pPara^.aPara[0]$t_HWCGetHardwareTreeEntryIn.us_current_index  := pObjectPath^ + 3; // Second place after manager Itself is place + 1 for addional length byte
                pPara^.aPara[0]$t_HWCGetHardwareTreeEntryIn.us_current_length := pStr_HWTRequested^ - pObjectPath^ - 1;
                
                ret_code := p_DriveMngBase$^VirtualBase^.NewInst(pPara, pResult); // Pass on command to manager
              end_if;

            else // Length not equal and no Escape sequence            
              ret_code := SdiasBase::ClassState.NewInst(pPara, pResult);  // Pass on command to base               
            end_if;
          
          else // Requested string length > this string length, _memcmp failed => Last string was from a differet Varan Port          
            ret_code := SdiasBase::ClassState.NewInst(pPara, pResult);  // Pass on command to base             
          end_if;
        
        else
          // pStr_HWTRequested is probably nil, pass on command to base
          ret_code := SdiasBase::ClassState.NewInst(pPara, pResult);  // Pass on command to base          
        end_if;
        
    else
      ret_code := SdiasBase::ClassState.NewInst(pPara, pResult);
  end_case;

  
		
END_FUNCTION




