//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)
//{{LSL_DECLARATION
#include "..\..\Source\interfaces\lsl_st_hardwaretree.h"

(*!
<Class
	Name               = "DiasMaster"
	Revision           = "2.33"
	GUID               = "{18364A21-3DBE-11D6-AB3C-00106092052D}"
	RealtimeTask       = "true"
	CyclicTask         = "false"
	BackgroundTask     = "false"
	Sigmatek           = "true"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	IconPath           = ".\Class\Tool.ico"
	SharedCommandTable = "true"
	Objectsize         = "(284,120)">
	<Channels>
		<Server Name="Control" GUID="{45BF69E1-5380-11D6-B05D-0010609208CF}" Visualized="false" Initialize="false" WriteProtected="false" Retentive="false"/>
	</Channels>
	<Dependencies>
		<Files>
			<File Path=".\Class\DiasMaster\DIASMaster.h" Include="false"/>
			<File Path=".\Source\interfaces\lsl_st_hardwaretree.h" Include="true"/>
		</Files>
	</Dependencies>
	<RevDoku>
		<Owner Company="Sigmatek" Author="SilBer"/>
		<Dokumentation Revision="2.33" Date="06.03.2018" Author="EisMic" Company="Sigmatek" Description="Attached header files no longer point to the installation directory of LASAL but instead now point to the the source/interfaces folder."/>
		<Dokumentation Revision="2.32" Date="02.10.2014" Author="LanSte" Company="Sigmatek" Description="Fixed compiler error when importing DiasMasterC without a HWControl in Project. The compiler error was caused by a missing type."/>
		<Dokumentation Revision="2.31" Date="29.07.2014" Author="EisMic" Company="Sigmatek" Description="Added Support for reading hardware diagnose and hardwaretree entry."/>
		<Dokumentation Revision="2.30" Date="06.12.2013" Author="FucHer" Company="Sigmatek" Description="Changed AWL code to Structured Text."/>
		<Dokumentation Revision="2.20" Date="18.07.2013" Author="ZoePat&#13;&#10;ZoePat" Company="Sigmatek" Description="Added function GetModuleInfo() to get the pointer of a hwclass by place.&#13;&#10;Added possibility to move data on CDIAS behind DataMover."/>
		<Dokumentation Revision="2.12" Date="27.06.2011" Author="RamAnd" Company="Sigmatek" Description="Support of sorting VARAN commands by priority added (needed for communication between safety-modules)."/>
		<Dokumentation Revision="2.11" Date="15.10.2010" Author="RamAnd" Company="Sigmatek" Description="Added method AddMovDO for the move command in the VM."/>
		<Dokumentation Revision="2.10" Date="25.06.2010" Author="WocPet" Company="Sigmatek" Description="New functionality for DIAS retry counter added"/>
		<Dokumentation Revision="2.9" Date="21.04.2010" Author="BleErn" Company="Sigmatek" Description="Added parameter callOptions for RtPostScan"/>
		<Dokumentation Revision="2.8" Date="15.07.2009" Author="RamAnd" Company="Sigmatek" Description="Added functions for safety and hardwaretree."/>
	</RevDoku>
</Class>
*)
DiasMaster : CLASS
  //Servers:
	Control 	: SvrChCmd_DINT;
  //Clients:
  //Variables:
		RequiredErrors 	: UINT;
		RequiredObjectCounter 	: UINT;
		p_RequiredObjects 	: ^void;
		b_NotfirstCall 	: BOOL;
		Initcounter 	: DINT;
		pVaranErrors 	: ^t_e_VaranErrors;			//! <Variable Comment="Do not delete this pointer! It is needed to make sure that the type t_e_Varanerros is imported when there is no HWControl in Project.&#13;&#10;" Name="pVaranErrors"/>
  //Functions:
	
	FUNCTION DiasMaster
		VAR_OUTPUT
			ret_code 	: ConfStates;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL Init;
				//! <Function Comment=" ***************************************************************&#13;&#10;   This Function is Called by PostScan from DiasMasterPostScan&#13;&#10; ***************************************************************&#13;&#10;" Name="CyWork"/>
	FUNCTION VIRTUAL GLOBAL CyWork
		VAR_INPUT
			EAX 	: UDINT := EAX;
		END_VAR
		VAR_OUTPUT
			state (EAX) 	: UDINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL RtWork
		VAR_INPUT
			EAX 	: UDINT := EAX;
		END_VAR
		VAR_OUTPUT
			state (EAX) 	: UDINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL UpdateRtPostScan;
	
	FUNCTION VIRTUAL GLOBAL GetPllTime
		VAR_OUTPUT
			PllTime 	: DINT;
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;" Name="AddWait"/>
	FUNCTION VIRTUAL GLOBAL AddWait
		VAR_INPUT
			RTCY 	: DINT;
			Time_uSec 	: DINT;			//! <Variable Comment="Time in uSec (valid from 0-255)" Name="AddWait.Time_uSec"/>
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL WrCntr
		VAR_INPUT
			adress 	: DINT;
			Data 	: USINT;
		END_VAR
		VAR_OUTPUT
			state 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL AddWr8Bit
		VAR_INPUT
			adress 	: HINT;
			RTCY 	: DINT;
			thisp 	: ^void;
			data 	: USINT;
			callOptions 	: USINT := CALL_OPTION_RT_PRESCAN;
		END_VAR
		VAR_OUTPUT
			Handle 	: DINT;
		END_VAR;
				//! <Function Comment=" ***************************************&#13;&#10;   put programm into the buffer      &#13;&#10; ***************************************&#13;&#10;  this is a 16 bit read &#13;&#10;  the thispointer we need to call the update method&#13;&#10;&#13;&#10;" Name="AddWr16Bit"/>
	FUNCTION VIRTUAL GLOBAL AddWr16Bit
		VAR_INPUT
			Adress 	: HINT;
			RTCY 	: DINT;
			thisp 	: ^void;
			data 	: UINT;
			callOptions 	: USINT := CALL_OPTION_RT_PRESCAN;
		END_VAR
		VAR_OUTPUT
			Handle 	: DINT;
		END_VAR;
				//! <Function Comment=" *************************************************&#13;&#10;   RTB is fixed reserved for one MODUL&#13;&#10; *************************************************&#13;&#10;&#13;&#10;  if FirstRTB &lt;&gt; 0 then this modul is the first with RTB&#13;&#10;  and has to do perhaps something special&#13;&#10;  if FirstRTB = 0 then it already exists a modul with RTBSYNC&#13;&#10;  &#13;&#10;" Name="AddRTBSync"/>
	FUNCTION VIRTUAL GLOBAL AddRTBSync
		VAR_INPUT
			Adress 	: HINT;
		END_VAR
		VAR_OUTPUT
			FirstRTB 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL AddRet
		VAR_INPUT
			RTCY 	: DINT;
		END_VAR;
				//! <Function Comment=" ***************************************&#13;&#10;   put programm into the buffer      &#13;&#10; ***************************************&#13;&#10;  this is a 16 bit read &#13;&#10;  the thispointer we need to call the update method&#13;&#10;&#13;&#10;" Name="AddRd32Bit"/>
	FUNCTION VIRTUAL GLOBAL AddRd32Bit
		VAR_INPUT
			Adress 	: HINT;
			RTCY 	: DINT;
			thisp 	: ^void;
			callOptions 	: USINT := CALL_OPTION_RT_PRESCAN;
		END_VAR
		VAR_OUTPUT
			Handle 	: DINT;
		END_VAR;
				//! <Function Comment=" ***************************************&#13;&#10;   put programm into the buffer      &#13;&#10; ***************************************&#13;&#10;  this is a 16 bit read &#13;&#10;  the thispointer we need to call the update method&#13;&#10;&#13;&#10;" Name="AddRd16Bit"/>
	FUNCTION VIRTUAL GLOBAL AddRd16Bit
		VAR_INPUT
			Adress 	: HINT;
			RTCY 	: DINT;
			thisp 	: ^void;
			callOptions 	: USINT := CALL_OPTION_RT_PRESCAN;
		END_VAR
		VAR_OUTPUT
			Handle 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL GetKennung
		VAR_INPUT
			Place 	: UDINT;			//! <Variable Comment="modul number" Name="GetKennung.Place"/>
		END_VAR
		VAR_OUTPUT
			Kennung 	: UDINT;
		END_VAR;
				//! <Function Comment=" ***************************************&#13;&#10;     add a call to the main Programm&#13;&#10; ***************************************&#13;&#10;&#13;&#10; RTCY = 0 cyclic programm&#13;&#10; RTCY = constant realtime  --&gt; realtime programm&#13;&#10; &#13;&#10; MODE Bit 0 = continue&#13;&#10;   Bit 1 = single&#13;&#10;  Bit 4 = block execution   !!!  (important for Analogcards 3 opcodes must be together)&#13;&#10;&#13;&#10;&#13;&#10;" Name="AddCall2Main"/>
	FUNCTION VIRTUAL GLOBAL AddCall2Main
		VAR_INPUT
			Mode 	: UINT;
			RTCY 	: DINT;
			thisp 	: ^void;
			callOptions 	: USINT := CALL_OPTION_RT_PRESCAN;
		END_VAR
		VAR_OUTPUT
			Handle 	: DINT;
		END_VAR;
				//! <Function Comment="[#DEUTSCH]&#13;&#10;Data : 0-255   Bit 31 = 1 .. Error&#13;&#10;" Name="Rd16Bit"/>
	FUNCTION VIRTUAL GLOBAL Rd16Bit
		VAR_INPUT
			Adress 	: UDINT;
		END_VAR
		VAR_OUTPUT
			Data 	: DINT;
		END_VAR;
				//! <Function Comment="[#DEUTSCH]&#13;&#10;Data : 0-255   Bit 31 = 1 .. Error&#13;&#10;" Name="Rd8Bit"/>
	FUNCTION VIRTUAL GLOBAL Rd8Bit
		VAR_INPUT
			Adress 	: UDINT;
		END_VAR
		VAR_OUTPUT
			Data 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL Wr8Bit
		VAR_INPUT
			Adress 	: UDINT;
			Data 	: USINT;
		END_VAR
		VAR_OUTPUT
			State 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL Wr16Bit
		VAR_INPUT
			Adress 	: UDINT;
			Data 	: UINT;
		END_VAR
		VAR_OUTPUT
			State 	: DINT;
		END_VAR;
				//! <Function Comment=" ***************************************&#13;&#10;   put programm into the buffer      &#13;&#10; ***************************************&#13;&#10;  this is a 8 bit read &#13;&#10;  the thispointer we need to call the update method&#13;&#10;&#13;&#10;" Name="AddRd8Bit"/>
	FUNCTION VIRTUAL GLOBAL AddRd8Bit
		VAR_INPUT
			Adress 	: HINT;
			RTCY 	: DINT;
			thisp 	: ^void;
			callOptions 	: USINT := CALL_OPTION_RT_PRESCAN;
		END_VAR
		VAR_OUTPUT
			Handle 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL GetEEState
		VAR_OUTPUT
			State 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL ReadEEData
		VAR_INPUT
			Adress 	: UDINT;
			pData 	: ^USINT;
		END_VAR
		VAR_OUTPUT
			retval 	: DINT;
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;0= connected direct to master&#13;&#10;1= connected via CIC&#13;&#10;&#13;&#10;&#13;&#10;-1 = fault&#13;&#10;" Name="GetConnection"/>
	FUNCTION VIRTUAL GLOBAL GetConnection
		VAR_OUTPUT
			CType 	: DINT;
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;read one Byte from C-DIAS bus on Board&#13;&#10;" Name="I2CReadOneByte"/>
	FUNCTION VIRTUAL GLOBAL I2CReadOneByte
		VAR_INPUT
			AdressCDIAS 	: UINT;
			pData 	: ^USINT;
		END_VAR
		VAR_OUTPUT
			result 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL AddCall2List
		VAR_INPUT
			Mode 	: UINT;
			RTCY 	: DINT;
			thisp 	: ^void;
			callOptions 	: USINT := CALL_OPTION_RT_PRESCAN;
		END_VAR
		VAR_OUTPUT
			Handle 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL GetMasterType
		VAR_OUTPUT
			MasterType 	: UDINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL GetCDiasIosegment
		VAR_OUTPUT
			CIOSegment 	: ^USINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL GetDiasIosegment
		VAR_OUTPUT
			IOSegment 	: ^USINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL AddDiasIRQ
		VAR_INPUT
			Place 	: USINT;
			ActionPtr 	: pVoid;
			thisptr 	: pVoid;
		END_VAR
		VAR_OUTPUT
			ok 	: USINT;
		END_VAR;
				//! <Function Comment="[#DEUTSCH]&#13;&#10;" Name="AddCDiasIRQ"/>
	FUNCTION VIRTUAL GLOBAL AddCDiasIRQ
		VAR_INPUT
			irqnr 	: USINT;			//! <Variable Comment="0..IRQ I/O (IRQ PIN C3) | 1..IRQ Comunication (GP2 PIN A10)" Name="AddCDiasIRQ.irqnr"/>
			ActionPtr 	: pVoid;
			thisp 	: pVoid;
		END_VAR
		VAR_OUTPUT
			ok 	: USINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL AddNOP
		VAR_INPUT
			RTCY 	: DINT;
			nCount 	: DINT;
		END_VAR;
				//! <Function Comment=" to read the identifier of a modul&#13;&#10;" Name="AddRdKenn"/>
	FUNCTION VIRTUAL GLOBAL AddRdKenn
		VAR_INPUT
			Adress 	: HSINT;
			RTCY 	: DINT;
			thisp 	: ^void;
			callOptions 	: USINT := CALL_OPTION_RT_PRESCAN;
		END_VAR
		VAR_OUTPUT
			Handle 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL AddMove
		VAR_INPUT
			RTCY 	: DINT;
			thisp 	: ^void;
			callOptions 	: USINT := CALL_OPTION_RT_PRESCAN;
			SourceAddr 	: HDINT := 0;			//! <Variable Comment="only used for move with datamover" Name="AddMove.SourceAddr"/>
			DestAddr 	: HDINT := 0;			//! <Variable Comment="only used for move with datamover" Name="AddMove.DestAddr"/>
			MoveLen 	: UDINT := 0;			//! <Variable Comment="only used for move with datamover" Name="AddMove.MoveLen"/>
			pEnable 	: ^USINT := NIL;			//! <Variable Comment="only used for move with datamover" Name="AddMove.pEnable"/>
			Settings 	: HDINT := 0;			//! <Variable Comment="only used for move with datamover&#13;&#10;&#13;&#10;settings:&#13;&#10; priority         -&gt; VM_PRIORITY_FILTER (VM_PRIORITY_1; VM_PRIORITY_2; VM_PRIORITY_3;)&#13;&#10; add CDIAS-addr   -&gt; 0x01: add to source; 0x02: add to dest; 0x03: add to both;" Name="AddMove.Settings"/>
		END_VAR
		VAR_OUTPUT
			HandleMove 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL GetCDiasPlaceIoSegment
		VAR_INPUT
			place 	: UDINT;
		END_VAR
		VAR_OUTPUT
			IOSegment 	: ^USINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL AddWaitSync
		VAR_INPUT
			thisp 	: pVoid;
			MaxWaitTime 	: UDINT;
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;" Name="AddIRQScan"/>
	FUNCTION VIRTUAL GLOBAL AddIRQScan
		VAR_INPUT
			Place 	: USINT;
			RTCY 	: DINT;
			thisp 	: ^void;
			callOptions 	: USINT := CALL_OPTION_RT_PRESCAN;
		END_VAR
		VAR_OUTPUT
			Handle 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL IRQScan
		VAR_INPUT
			Place 	: UDINT;
		END_VAR
		VAR_OUTPUT
			Data 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL GetRtPasses
		VAR_OUTPUT
			us_rt_passes 	: USINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL GetUpdateState
		VAR_OUTPUT
			us_update 	: USINT;
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;=================================================================================================&#13;&#10;Function call function of VaranMaster to add a read data object to varan master and install a varan task&#13;&#10;=================================================================================================&#13;&#10;" Name="AddRdDO"/>
	FUNCTION VIRTUAL GLOBAL AddRdDO
		VAR_INPUT
			ud_dol_type 	: UDINT;			//! <Variable Comment=" type of DOL list( Realtime = 3, cyclic = 4 )" Name="AddRdDO.ud_dol_type"/>
			p_ud_handle 	: ^UDINT;			//! <Variable Comment=" pointer to variable to set right handle" Name="AddRdDO.p_ud_handle"/>
			ud_address 	: UDINT;			//! <Variable Comment="address of do" Name="AddRdDO.ud_address"/>
			ud_length 	: UDINT;			//! <Variable Comment="length of data should read" Name="AddRdDO.ud_length"/>
			p_ud_data 	: ^UDINT;			//! <Variable Comment="variable to get pointer to readed data" Name="AddRdDO.p_ud_data"/>
			ud_type 	: UDINT;			//! <Variable Comment="0=control area, 1=memory area" Name="AddRdDO.ud_type"/>
			p_ud_DataAddr 	: ^HDINT := NIL;			//! <Variable Comment="here the used DPRam address of the data is given back" Name="AddRdDO.p_ud_DataAddr"/>
		END_VAR
		VAR_OUTPUT
			sd_retval 	: DINT;			//! <Variable Comment=" 0=OK, negative=error (look lsl_st_varan.h)" Name="AddRdDO.sd_retval"/>
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;=================================================================================================&#13;&#10;Function call function of VaranMaster to add a write data object to varan master and install a varan task&#13;&#10;=================================================================================================&#13;&#10;" Name="AddWrDO"/>
	FUNCTION VIRTUAL GLOBAL AddWrDO
		VAR_INPUT
			ud_dol_type 	: UDINT;
			p_ud_handle 	: ^UDINT;
			ud_address 	: UDINT;
			ud_length 	: UDINT;
			p_ud_data 	: ^UDINT;
			ud_type 	: UDINT;
			p_ud_DataAddr 	: ^HDINT := NIL;			//! <Variable Comment="here the used DPRam address of the data is given back" Name="AddWrDO.p_ud_DataAddr"/>
		END_VAR
		VAR_OUTPUT
			sd_retval 	: DINT;
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;=================================================================================================&#13;&#10;Function to add a read/write data object&#13;&#10;=================================================================================================&#13;&#10;" Name="AddRdWrDO"/>
	FUNCTION AWL VIRTUAL GLOBAL AddRdWrDO
		VAR_INPUT
			ud_dol_type 	: UDINT;
			p_ud_handle 	: ^UDINT;
			ud_address_read 	: UDINT;			//! <Variable Comment="read address of do" Name="AddRdWrDO.ud_address_read"/>
			ud_length_read 	: UDINT;			//! <Variable Comment=" Length of read data object" Name="AddRdWrDO.ud_length_read"/>
			p_ud_data_read 	: ^UDINT;			//! <Variable Comment=" pointer to variable to get pointer to data" Name="AddRdWrDO.p_ud_data_read"/>
			ud_address_write 	: UDINT;			//! <Variable Comment="write address of do" Name="AddRdWrDO.ud_address_write"/>
			ud_length_write 	: UDINT;			//! <Variable Comment=" Length of write data object" Name="AddRdWrDO.ud_length_write"/>
			p_ud_data_write 	: ^UDINT;			//! <Variable Comment=" pointer to variable to get pointer to data" Name="AddRdWrDO.p_ud_data_write"/>
			ud_type 	: UDINT;
			p_ud_DataAddr_read 	: ^HDINT := NIL;			//! <Variable Comment="here the used DPRam address of the read data is given back" Name="AddRdWrDO.p_ud_DataAddr_read"/>
			p_ud_DataAddr_write 	: ^HDINT := NIL;			//! <Variable Comment="here the used DPRam address of the write data is given back" Name="AddRdWrDO.p_ud_DataAddr_write"/>
		END_VAR
		VAR_OUTPUT
			sd_retval 	: DINT;
		END_VAR;
	
	FUNCTION AWL VIRTUAL GLOBAL AddMovDO
		VAR_INPUT
			ud_dol_type 	: UDINT;
			p_ud_handle 	: ^UDINT;
			p_ud_MovSettings 	: ^UDINT;
			ud_type 	: UDINT := 0;			//! <Variable Comment="access type is always memory, but we may want to have some priority for this access" Name="AddMovDO.ud_type"/>
		END_VAR
		VAR_OUTPUT
			sd_retval 	: DINT;
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;=================================================================================================&#13;&#10;Function to read a direct access data object&#13;&#10;=================================================================================================&#13;&#10;" Name="RdDO"/>
	FUNCTION AWL VIRTUAL GLOBAL RdDO
		VAR_INPUT
			ud_address 	: UDINT;
			ud_length 	: UDINT;
			p_ud_data 	: pVoid;
			ud_type 	: UDINT;
		END_VAR
		VAR_OUTPUT
			sd_retval 	: DINT;
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;=================================================================================================&#13;&#10;Function to write a direct access data object&#13;&#10;=================================================================================================&#13;&#10;" Name="WrDO"/>
	FUNCTION AWL VIRTUAL GLOBAL WrDO
		VAR_INPUT
			ud_address 	: UDINT;
			ud_length 	: UDINT;
			p_ud_data 	: pVoid;
			ud_type 	: UDINT;
		END_VAR
		VAR_OUTPUT
			sd_retval 	: DINT;
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;=================================================================================================&#13;&#10;Function to install a callback function&#13;&#10;=================================================================================================&#13;&#10;" Name="SetObjectCallback"/>
	FUNCTION AWL VIRTUAL GLOBAL SetObjectCallback
		VAR_INPUT
			us_place 	: USINT;			//! <Variable Comment="place of cdias module" Name="SetObjectCallback.us_place"/>
			ud_action_ptr 	: UDINT;			//! <Variable Comment="pointer to position info( first byte is length)" Name="SetObjectCallback.ud_action_ptr"/>
			ud_thisp 	: UDINT;			//! <Variable Comment="thispointer of object" Name="SetObjectCallback.ud_thisp"/>
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;=================================================================================================&#13;&#10;Function to install a varan task&#13;&#10;=================================================================================================&#13;&#10;" Name="AddVaranTask"/>
	FUNCTION AWL VIRTUAL GLOBAL AddVaranTask
		VAR_INPUT
			ud_dol_type 	: UDINT;
			p_this 	: ^void;			//! <Variable Comment=" Thispointer of connected varan class" Name="AddVaranTask.p_this"/>
			callOptions 	: USINT := CALL_OPTION_RT_PRESCAN;
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;=================================================================================================&#13;&#10;Function to reset a Data object (set default parameter)&#13;&#10;=================================================================================================&#13;&#10;" Name="ResetDO"/>
	FUNCTION VIRTUAL GLOBAL ResetDO
		VAR_INPUT
			p_data_object 	: ^DINT;			//! <Variable Comment="pointer to varan data object header" Name="ResetDO.p_data_object"/>
			us_state 	: USINT;			//! <Variable Comment="state of data object" Name="ResetDO.us_state"/>
			ud_bytes 	: UDINT;			//! <Variable Comment="bytes of cdias accesses" Name="ResetDO.ud_bytes"/>
		END_VAR
		VAR_OUTPUT
			sd_retval 	: DINT;
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;=================================================================================================&#13;&#10;Function to find out if varan is available&#13;&#10;=================================================================================================&#13;&#10;" Name="IsVaranAvailable"/>
	FUNCTION VIRTUAL GLOBAL IsVaranAvailable
		VAR_OUTPUT
			sd_varan 	: DINT;			//! <Variable Comment="0=varan not available, 1=varan available" Name="IsVaranAvailable.sd_varan"/>
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;" Name="SetNewDOAddressRd"/>
	FUNCTION AWL VIRTUAL GLOBAL SetNewDOAddressRd
		VAR_INPUT
			p_data 	: ^DINT;			//! <Variable Comment="pointer to varan write data" Name="SetNewDOAddressRd.p_data"/>
			ud_address 	: UDINT;
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;" Name="SetNewDOAddressWr"/>
	FUNCTION AWL VIRTUAL GLOBAL SetNewDOAddressWr
		VAR_INPUT
			p_data 	: ^DINT;
			ud_address 	: UDINT;
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;" Name="SetNewDOAddressRdWr"/>
	FUNCTION AWL VIRTUAL GLOBAL SetNewDOAddressRdWr
		VAR_INPUT
			p_data 	: ^DINT;
			ud_address_read 	: UDINT;
			ud_address_write 	: UDINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL I2CWriteOneByte
		VAR_INPUT
			AdressCDIAS 	: UINT;
			pData 	: ^USINT;
		END_VAR
		VAR_OUTPUT
			result 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL WriteEEData
		VAR_INPUT
			Adress 	: UDINT;
			pData 	: ^USINT;
			ui_length 	: UINT;
			ui_offset 	: UINT;
		END_VAR
		VAR_OUTPUT
			retval 	: DINT;
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;" Name="GetPointer2NodeString"/>
	FUNCTION VIRTUAL GLOBAL GetPointer2NodeString
		VAR_OUTPUT
			p_us_node 	: ^USINT;			//! <Variable Comment="pointer to node string" Name="GetPointer2NodeString.p_us_node"/>
		END_VAR;
	
	FUNCTION AWL VIRTUAL GLOBAL GetActualAddressPointer
		VAR_INPUT
			ud_dol_type 	: UDINT;
		END_VAR
		VAR_OUTPUT
			ud_add 	: UDINT;
		END_VAR;
				//! <Function Comment="returns the object path" Name="GetObjectPath"/>
	FUNCTION VIRTUAL GLOBAL GetObjectPath
		VAR_INPUT
			p_us_ObjectPath 	: ^USINT;
		END_VAR
		VAR_OUTPUT
			sd_retval 	: DINT;
		END_VAR;
				//! <Function Comment="function to save this-pointer of object in dependence of object path" Name="SetObjectThisp"/>
	FUNCTION VIRTUAL GLOBAL SetObjectThisp
		VAR_INPUT
			p_us_ObjectPath 	: ^USINT;
			ud_thisp 	: UDINT;
		END_VAR
		VAR_OUTPUT
			sd_retval 	: DINT;
		END_VAR;
				//! <Function Comment="change the order of update-calls" Name="SetTaskPriority"/>
	FUNCTION VIRTUAL GLOBAL SetTaskPriority
		VAR_INPUT
			us_place 	: USINT;
			us_priority 	: USINT;
			ud_dol_type 	: UDINT;
		END_VAR;
				//! <Function Comment="function to get this-pointer of an object with a specific object path" Name="GetObjectThisp"/>
	FUNCTION VIRTUAL GLOBAL GetObjectThisp
		VAR_INPUT
			p_us_ObjectPath 	: ^USINT;
		END_VAR
		VAR_OUTPUT
			ud_Thisp 	: UDINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL SetRetryCounterAvailability
		VAR_INPUT
			Port 	: USINT;
			p_State 	: ^IO_State;
			p_RetryCounter 	: ^DINT;
		END_VAR;
	
	FUNCTION VIRTUAL UpdateDIASRetryCounter;
	
	FUNCTION VIRTUAL GLOBAL AddRequiredObject
		VAR_INPUT
			thisp 	: ^void;
		END_VAR;
	
	FUNCTION VIRTUAL CheckforRequiredError;
	
	FUNCTION VIRTUAL GLOBAL SetRequiredError
		VAR_INPUT
			p_this 	: ^HwBase;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL GetModuleInfo
		VAR_INPUT
			us_place 	: USINT;
		END_VAR
		VAR_OUTPUT
			p_ModuleInfo 	: ^t_s_ModulInfo;
		END_VAR;
				//! <Function Name="Control.NewInst" Hidden="true"/>
	FUNCTION VIRTUAL GLOBAL Control::NewInst
		VAR_INPUT
			pPara 	: ^CmdStruct;
			pResult 	: ^results;
		END_VAR
		VAR_OUTPUT
			ret_code 	: iprStates;
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

//}}LSL_DECLARATION


FUNCTION GLOBAL TAB DiasMaster::@CT_
0$UINT,
2#0100000000000000$UINT, //TY_DIASMASTER
2$UINT, 33$UINT, (SIZEOF(::DiasMaster))$UINT, 
1$UINT, 0$UINT, 0$UINT, 
TO_UDINT(2647887450), "DiasMaster", //Class
TO_UDINT(0), 0, 0$UINT, 0$UINT, //Baseclass
//Servers:
(::DiasMaster.Control.pMeth)$UINT, _CH_CMD$UINT, 2#0000000000000000$UINT, TO_UDINT(3533623889), "Control", 
//Clients:
END_FUNCTION


#define USER_CNT_DiasMaster 63

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_DiasMaster] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION DiasMaster::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
	END_VAR

	//Command Methods
	InitCmdTable (nCmd := nSTDCMD + USER_CNT_DiasMaster, pCmd := #vmt.CmdTable);
	vmt.CmdTable.NewInstr		:= #NewInst();
	vmt.CmdTable.Write		:= #M_WR_DIRECT();
	vmt.CmdTable.Init		:= #Init();
	vmt.CmdTable.CyWork		:= #CyWork();
	vmt.CmdTable.RtWork		:= #RtWork();
#pragma warning (disable : 74)
	vmt.UserFcts[0]		:= #UpdateRtPostScan();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[1]		:= #GetPllTime();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[2]		:= #AddWait();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[3]		:= #WrCntr();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[4]		:= #AddWr8Bit();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[5]		:= #AddWr16Bit();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[6]		:= #AddRTBSync();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[7]		:= #AddRet();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[8]		:= #AddRd32Bit();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[9]		:= #AddRd16Bit();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[10]		:= #GetKennung();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[11]		:= #AddCall2Main();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[12]		:= #Rd16Bit();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[13]		:= #Rd8Bit();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[14]		:= #Wr8Bit();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[15]		:= #Wr16Bit();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[16]		:= #AddRd8Bit();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[17]		:= #GetEEState();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[18]		:= #ReadEEData();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[19]		:= #GetConnection();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[20]		:= #I2CReadOneByte();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[21]		:= #AddCall2List();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[22]		:= #GetMasterType();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[23]		:= #GetCDiasIosegment();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[24]		:= #GetDiasIosegment();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[25]		:= #AddDiasIRQ();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[26]		:= #AddCDiasIRQ();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[27]		:= #AddNOP();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[28]		:= #AddRdKenn();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[29]		:= #AddMove();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[30]		:= #GetCDiasPlaceIoSegment();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[31]		:= #AddWaitSync();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[32]		:= #AddIRQScan();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[33]		:= #IRQScan();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[34]		:= #GetRtPasses();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[35]		:= #GetUpdateState();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[36]		:= #AddRdDO();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[37]		:= #AddWrDO();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[38]		:= #AddRdWrDO();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[39]		:= #AddMovDO();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[40]		:= #RdDO();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[41]		:= #WrDO();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[42]		:= #SetObjectCallback();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[43]		:= #AddVaranTask();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[44]		:= #ResetDO();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[45]		:= #IsVaranAvailable();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[46]		:= #SetNewDOAddressRd();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[47]		:= #SetNewDOAddressWr();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[48]		:= #SetNewDOAddressRdWr();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[49]		:= #I2CWriteOneByte();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[50]		:= #WriteEEData();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[51]		:= #GetPointer2NodeString();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[52]		:= #GetActualAddressPointer();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[53]		:= #GetObjectPath();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[54]		:= #SetObjectThisp();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[55]		:= #SetTaskPriority();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[56]		:= #GetObjectThisp();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[57]		:= #SetRetryCounterAvailability();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[58]		:= #UpdateDIASRetryCounter();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[59]		:= #AddRequiredObject();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[60]		:= #CheckforRequiredError();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[61]		:= #SetRequiredError();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[62]		:= #GetModuleInfo();

#pragma warning (default : 74)
	Control.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF Control.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	ret_code	:= DiasMaster();

END_FUNCTION

#pragma usingLtd HwBase

//{{LSL_IMPLEMENTATION
//{{LSL_HIDDEN_FUNCTION
FUNCTION VIRTUAL GLOBAL DiasMaster::Control::NewInst
#pragma warning (disable:73)     
	VAR_INPUT
		pPara 	: ^CmdStruct;
		pResult 	: ^Results;
	END_VAR
#pragma warning(default:73);
  
	VAR_OUTPUT
		ret_code 	: IprStates;
	END_VAR

	ret_code := READY;
END_FUNCTION
//}}LSL_HIDDEN_FUNCTION


#pragma warning (disable:73)   
#pragma warning(disable: 76)

(************************************************************************************
*
*	Baseclass for mastercontrolling
*	Created : Sigmatek / 2003
*	Changes : 
*
*
*   FOR NEWER CHANGES SEE REVISION DOCUMENTATION IN CLASS PROPERTIES
*
*
*		2.6 => 2.7	/	29.01.2008				//#SR006
*			- [DB 713]: add Function for address manipulation with data mover for CRIF
*		2.5 => 2.6	/	04.12.2007				//#SR005
*			- [DB 713]: add Function prototype for CIV to get node string
*		2.1 => 2.5	/	16.03.2007				//#SR004
*			- [DB 421]: add Plug & Play function to CDIAS - classes
*		2.0 => 2.1	/	16.03.2007				//#SR003
*			- [DB 528]: insert functions to write to cdias eeprom
*		1.8 => 2.0	/	10.10.2006	/	Mark:	//#SR002
*			make compatible to Varan classes
*		1.7 => 1.8	/	10.02.2005	/	Mark:	//#SR001
*			add Methods GetRtPasses and GetUpdateState for intelligent master
*		1.6 => 1.7	/	31.05.2005	/	Mark:	//#SR000
*			add Methods IRQScan and AddIRQScan for intelligent master
*		0.6 => 1.6 / 23.12.2004 / no Mark / ws
*			compatibility with Lasal Class 2
*			removed visible flags from internal servers
*		0.5 => 0.6 / ?			/ ?
*		0.4 => 0.5 / 01.06.2004 / Mark: // #BS002
*			Added function AddWaitSync();
*		0.3 => 0.4 / 29.01.2003 / Mark: // #BS001
*			Added function GetPlaceIoSegment();
*		0.2 => 0.3 / 14.11.2003 / Mark: // #BS000
*			Added function AddMove
*
************************************************************************************)
// ***************************************************************
//   This Function is Called by PostScan from DiasMasterPostScan
// ***************************************************************


FUNCTION VIRTUAL GLOBAL DiasMaster::CyWork
VAR_INPUT
	EAX		: UDINT;
END_VAR
VAR_OUTPUT
	state		: UDINT;
END_VAR
END_FUNCTION //VIRTUAL GLOBAL DiasMaster::CyWork

FUNCTION VIRTUAL GLOBAL DiasMaster::Init

END_FUNCTION //VIRTUAL GLOBAL DiasMaster::Init

FUNCTION VIRTUAL GLOBAL DiasMaster::Wr16Bit
VAR_INPUT
	Adress		: UDINT;
	Data		: UINT;
END_VAR
VAR_OUTPUT
	State		: DINT;
END_VAR

END_FUNCTION //VIRTUAL GLOBAL DiasMaster::Wr16Bit

FUNCTION VIRTUAL GLOBAL DiasMaster::Wr8Bit
VAR_INPUT
	Adress		: UDINT;
	Data		: Usint;
END_VAR
VAR_OUTPUT
	State		: DINT;
END_VAR

END_FUNCTION //VIRTUAL GLOBAL DiasMaster::Wr8Bit

//[#DEUTSCH]
//Data : 0-255   Bit 31 = 1 .. Error
FUNCTION VIRTUAL GLOBAL DiasMaster::Rd8Bit
VAR_INPUT
	Adress		: UDINT;
END_VAR
VAR_OUTPUT
	Data		: DINT;
END_VAR
END_FUNCTION //VIRTUAL GLOBAL DiasMaster::Rd8Bit

//[#DEUTSCH]
//Data : 0-255   Bit 31 = 1 .. Error
FUNCTION VIRTUAL GLOBAL DiasMaster::Rd16Bit
VAR_INPUT
	Adress		: UDINT;
END_VAR
VAR_OUTPUT
	Data		: DINT;
END_VAR
END_FUNCTION //VIRTUAL GLOBAL DiasMaster::Rd16Bit

FUNCTION VIRTUAL GLOBAL DiasMaster::RtWork
VAR_INPUT
	EAX		: UDINT;
END_VAR
VAR_OUTPUT
	state		: UDINT;
END_VAR

END_FUNCTION //VIRTUAL GLOBAL DiasMaster::RtWork

FUNCTION  DiasMaster::DiasMaster
VAR_OUTPUT
	ret_code		: CONFSTATES;
END_VAR
	ret_code	:= C_OK;
   
END_FUNCTION //  DiasMaster::DiasMaster


// ***************************************
//     add a call to the main Programm
// ***************************************
//
// RTCY = 0 cyclic programm
// RTCY = constant realtime  --> realtime programm
// 
// MODE Bit 0 = continue
// 		Bit 1 = single
//		Bit 4 = block execution   !!!  (important for Analogcards 3 opcodes must be together)
//
//
FUNCTION VIRTUAL GLOBAL DiasMaster::AddCall2Main
	VAR_INPUT
		Mode 	: UINT;
		RTCY 	: DINT;
		thisp 	: ^void;
		callOptions 	: USINT;
	END_VAR
	VAR_OUTPUT
		Handle 	: DINT;
	END_VAR
END_FUNCTION //VIRTUAL GLOBAL DiasMaster::AddCall

FUNCTION VIRTUAL GLOBAL DiasMaster::GetKennung
VAR_INPUT
	Place		: UDINT;
END_VAR
VAR_OUTPUT
	Kennung		: UDINT;
END_VAR
    if place then
    end_if;
	Kennung :=16#ff;
END_FUNCTION //VIRTUAL GLOBAL DiasMaster::GetKennung
// ***************************************
//   put programm into the buffer      
// ***************************************
//  this is a 8 bit read 
//  the thispointer we need to call the update method
//
FUNCTION VIRTUAL GLOBAL DiasMaster::AddRd8Bit
	VAR_INPUT
		Adress 	: HINT;
		RTCY 	: DINT;
		thisp 	: ^void;
		callOptions 	: USINT;
	END_VAR
	VAR_OUTPUT
		Handle 	: DINT;
	END_VAR
END_FUNCTION 
// ***************************************
//   put programm into the buffer      
// ***************************************
//  this is a 16 bit read 
//  the thispointer we need to call the update method
//
FUNCTION VIRTUAL GLOBAL DiasMaster::AddRd16Bit
	VAR_INPUT
		Adress 	: HINT;
		RTCY 	: DINT;
		thisp 	: ^void;
		callOptions 	: USINT;
	END_VAR
	VAR_OUTPUT
		Handle 	: DINT;
	END_VAR

END_FUNCTION //VIRTUAL GLOBAL DiasMaster::AddRd16Bit
// ***************************************
//   put programm into the buffer      
// ***************************************
//  this is a 16 bit read 
//  the thispointer we need to call the update method
//
FUNCTION VIRTUAL GLOBAL DiasMaster::AddRd32Bit
	VAR_INPUT
		Adress 	: HINT;
		RTCY 	: DINT;
		thisp 	: ^void;
		callOptions 	: USINT;
	END_VAR
	VAR_OUTPUT
		Handle 	: DINT;
	END_VAR

END_FUNCTION //VIRTUAL GLOBAL DiasMaster::AddRd16Bit

FUNCTION VIRTUAL GLOBAL DiasMaster::AddRet
VAR_INPUT
	RTCY		: DINT;
END_VAR

END_FUNCTION //VIRTUAL GLOBAL DiasMaster::AddRet
// *************************************************
//   RTB is fixed reserved for one MODUL
// *************************************************
//
//  if FirstRTB <> 0 then this modul is the first with RTB
//  and has to do perhaps something special
//  if FirstRTB = 0 then it already exists a modul with RTBSYNC
//  
FUNCTION VIRTUAL GLOBAL DiasMaster::AddRTBSync
VAR_INPUT
	Adress		: HINT;
END_VAR
VAR_OUTPUT
	FirstRTB		: DINT;
END_VAR

END_FUNCTION //VIRTUAL GLOBAL DiasMaster::AddRTBSync

// ***************************************
//   put programm into the buffer      
// ***************************************
//  this is a 16 bit read 
//  the thispointer we need to call the update method
//
FUNCTION VIRTUAL GLOBAL DiasMaster::AddWr16Bit
	VAR_INPUT
		Adress 	: HINT;
		RTCY 	: DINT;
		thisp 	: ^void;
		data 	: UINT;
		callOptions 	: USINT;
	END_VAR
	VAR_OUTPUT
		Handle 	: DINT;
	END_VAR

END_FUNCTION //VIRTUAL GLOBAL DiasMaster::AddWr16Bit

FUNCTION VIRTUAL GLOBAL DiasMaster::AddWr8Bit
	VAR_INPUT
		adress 	: HINT;
		RTCY 	: DINT;
		thisp 	: ^void;
		data 	: USINT;
		callOptions 	: USINT;
	END_VAR
	VAR_OUTPUT
		Handle 	: DINT;
	END_VAR

END_FUNCTION //VIRTUAL GLOBAL DiasMaster::AddWr8Bit

FUNCTION VIRTUAL GLOBAL DiasMaster::WrCntr
VAR_INPUT
	adress		: DINT;
	Data		: Usint;
END_VAR
VAR_OUTPUT
	state		: DINT;
END_VAR

END_FUNCTION //VIRTUAL GLOBAL DiasMaster::WrCntr

//[#ENGLISH]
//[>Time_uSec]Time in uSec (valid from 0-255)
FUNCTION VIRTUAL GLOBAL DiasMaster::AddWait
VAR_INPUT
	RTCY		: DINT;
	Time_uSec		: DINT;
END_VAR
END_FUNCTION //VIRTUAL GLOBAL DiasMaster::AddWait

FUNCTION VIRTUAL GLOBAL DiasMaster::GetPllTime
VAR_OUTPUT
	PllTime		: DINT;
END_VAR
	PllTime := Ops.RtInterv_mSec$DINT;
END_FUNCTION //VIRTUAL GLOBAL DiasMaster::GetPllTime

FUNCTION VIRTUAL GLOBAL DiasMaster::GetEEState
VAR_OUTPUT
	State		: DINT;
END_VAR
	State :=0;
END_FUNCTION //VIRTUAL GLOBAL DiasMaster::GetEEState

FUNCTION VIRTUAL GLOBAL DiasMaster::ReadEEData
VAR_INPUT
	Adress		: UDINT;
	pData		: ^USINT;
END_VAR
VAR_OUTPUT
	retval		: DINT;
END_VAR
  retval :=-1;
END_FUNCTION //VIRTUAL GLOBAL DiasMaster::ReadEEData
//[#ENGLISH]
//0= connected direct to master
//1= connected via CIC
//
//
//-1 = fault
FUNCTION VIRTUAL GLOBAL DiasMaster::GetConnection
VAR_OUTPUT
	CType		: DINT;
END_VAR
	CType :=-1;
END_FUNCTION //VIRTUAL GLOBAL DiasMaster::GetConnection
//[#ENGLISH]
//read one Byte from C-DIAS bus on Board
FUNCTION VIRTUAL GLOBAL DiasMaster::I2CReadOneByte
VAR_INPUT
	AdressCDIAS		: UINT;
	pData		: ^USINT;
END_VAR
VAR_OUTPUT
	result		: DINT;
END_VAR
	result:=-1;
END_FUNCTION //VIRTUAL GLOBAL DiasMaster::I2CReadOneByte

FUNCTION VIRTUAL GLOBAL DiasMaster::AddCall2List
	VAR_INPUT
		Mode 	: UINT;
		RTCY 	: DINT;
		thisp 	: ^void;
		callOptions 	: USINT;
	END_VAR
	VAR_OUTPUT
		Handle 	: DINT;
	END_VAR
	
	Handle :=-1;
END_FUNCTION //VIRTUAL GLOBAL DiasMaster::AddCall2List

FUNCTION VIRTUAL GLOBAL DiasMaster::GetMasterType
VAR_OUTPUT
	MasterType		: UDINT;
END_VAR
	MasterType:=0;
END_FUNCTION //VIRTUAL GLOBAL DiasMaster::GetMasterType

FUNCTION VIRTUAL GLOBAL DiasMaster::GetCDiasIosegment
VAR_OUTPUT
	CIOSegment		: ^USINT;
END_VAR
	CIOSegment :=NIL;
END_FUNCTION //VIRTUAL GLOBAL DiasMaster::GetCDiasIosegment

FUNCTION VIRTUAL GLOBAL DiasMaster::GetDiasIosegment
VAR_OUTPUT
	IOSegment		: ^USINT;
END_VAR
	IOSegment := _IOSegment$^USINT;
END_FUNCTION //VIRTUAL GLOBAL DiasMaster::GetDiasIosegment
FUNCTION VIRTUAL GLOBAL DiasMaster::AddDiasIRQ
VAR_INPUT
	Place		: USINT;
	ActionPtr		: pVoid;
	thisptr		: pVoid;
END_VAR
VAR_OUTPUT
	ok		: USINT;
END_VAR
	ok := 0;
END_FUNCTION //VIRTUAL GLOBAL DiasMaster::AddDiasIRQ
//[#DEUTSCH]
//[>irqnr]0..IRQ I/O (IRQ PIN C3) | 1..IRQ Comunication (GP2 PIN A10)
FUNCTION VIRTUAL GLOBAL DiasMaster::AddCDiasIRQ
VAR_INPUT
	irqnr		: USINT;
	ActionPtr		: pVoid;
	thisp		: pVoid;
END_VAR
VAR_OUTPUT
	ok		: USINT;
END_VAR
	ok := 0;
END_FUNCTION //VIRTUAL GLOBAL DiasMaster::AddCDiasIRQ
FUNCTION VIRTUAL GLOBAL DiasMaster::AddNOP
VAR_INPUT
	RTCY		: DINT;
	nCount		: DINT;
END_VAR

// for old DiasModuls THR
END_FUNCTION //VIRTUAL GLOBAL DiasMaster::AddNOP
// to read the identifier of a modul
FUNCTION VIRTUAL GLOBAL DiasMaster::AddRdKenn
	VAR_INPUT
		Adress 	: HSINT;
		RTCY 	: DINT;
		thisp 	: ^void;
		callOptions 	: USINT;
	END_VAR
	VAR_OUTPUT
		Handle 	: DINT;
	END_VAR

// to keep diasbus alive
	Handle := -1;

END_FUNCTION 
FUNCTION VIRTUAL GLOBAL DiasMaster::AddMove
	VAR_INPUT
		RTCY 	: DINT;
		thisp 	: ^void;
		callOptions 	: USINT;
		SourceAddr 	: HDINT;
		DestAddr 	: HDINT;
		MoveLen 	: UDINT;
		pEnable 	: ^USINT;
		Settings 	: HDINT;
	END_VAR
	VAR_OUTPUT
		HandleMove 	: DINT;
	END_VAR

	HandleMove := -1;

END_FUNCTION //VIRTUAL GLOBAL DiasMasterMain::AddMove

FUNCTION VIRTUAL GLOBAL DiasMaster::GetCDiasPlaceIoSegment // #BS001
VAR_INPUT
	place		: UDINT;
END_VAR
VAR_OUTPUT
	IOSegment		: ^USINT;
END_VAR

	IOSegment := NIL;

END_FUNCTION //VIRTUAL GLOBAL DiasMaster::GetPlaceIoSegment

FUNCTION VIRTUAL GLOBAL DiasMaster::AddWaitSync
VAR_INPUT
	thisp			: pVoid;
	MaxWaitTime		: UDINT;
END_VAR


END_FUNCTION //VIRTUAL GLOBAL DiasMaster::AddWaitSync
//[#ENGLISH]
//[>Place]modul number
FUNCTION VIRTUAL GLOBAL DiasMaster::AddIRQScan
	VAR_INPUT
		Place 	: USINT;
		RTCY 	: DINT;
		thisp 	: ^void;
		callOptions 	: USINT;
	END_VAR
	VAR_OUTPUT
		Handle 	: DINT;
	END_VAR

	Handle := 0;

END_FUNCTION //VIRTUAL GLOBAL DiasMaster::AddIRQScan
FUNCTION VIRTUAL GLOBAL DiasMaster::IRQScan			//#SR000
VAR_INPUT
	Place		: udint;
END_VAR
VAR_OUTPUT
	Data		: DINT;
END_VAR

	Data := 0;

END_FUNCTION //VIRTUAL GLOBAL DiasMaster::IRQScan
FUNCTION VIRTUAL GLOBAL DiasMaster::GetUpdateState		//#SR001
VAR_OUTPUT
	us_update		: USINT;
END_VAR

	us_update := 1;

END_FUNCTION //VIRTUAL GLOBAL DiasMaster::GetUpdateState

FUNCTION VIRTUAL GLOBAL DiasMaster::GetRtPasses			//#SR001
VAR_OUTPUT
	us_rt_passes		: USINT;
END_VAR

	us_rt_passes := 1;

END_FUNCTION //VIRTUAL GLOBAL DiasMaster::GetRtPasses
//[#ENGLISH]
//=================================================================================================
//Function call function of VaranMaster to add a read data object to varan master and install a varan task
//=================================================================================================
//[>ud_dol_type] pointer to variable to set right handle
//[>p_ud_handle]pointer to variable to set right handle
//[>ud_address] Address of data object
//[>ud_length] Length of data object
//[>p_ud_data] pointer to variable to get pointer to data
//[>ud_type]0=control area, 1=memory area
//[<sd_retval] 0=OK, negative=error (look lsl_st_varan.h)
FUNCTION VIRTUAL GLOBAL DiasMaster::AddRdDO
	VAR_INPUT
		ud_dol_type 	: UDINT;
		p_ud_handle 	: ^UDINT;
		ud_address 	: UDINT;
		ud_length 	: UDINT;
		p_ud_data 	: ^UDINT;
		ud_type 	: UDINT;
		p_ud_DataAddr 	: ^HDINT;
	END_VAR
	VAR_OUTPUT
		sd_retval 	: DINT;
	END_VAR
	
//	l.d		sd_retval, -100
	sd_retval := -100;
	
END_FUNCTION //VIRTUAL GLOBAL DiasMaster::AddRdDO
//[#ENGLISH]
//=================================================================================================
//Function call function of VaranMaster to add a write data object to varan master and install a varan task
//=================================================================================================
//[>ud_dol_type] pointer to variable to set right handle
//[>p_ud_handle]pointer to variable to set right handle
//[>ud_address] Address of data object
//[>ud_length] Length of data object
//[>p_ud_data] pointer to variable to get pointer to data
//[>ud_type]0=control area, 1=memory area
//[<sd_retval] 0=OK, negative=error (look lsl_st_varan.h)
FUNCTION VIRTUAL GLOBAL DiasMaster::AddWrDO
	VAR_INPUT
		ud_dol_type 	: UDINT;
		p_ud_handle 	: ^UDINT;
		ud_address 	: UDINT;
		ud_length 	: UDINT;
		p_ud_data 	: ^UDINT;
		ud_type 	: UDINT;
		p_ud_DataAddr 	: ^HDINT;
	END_VAR
	VAR_OUTPUT
		sd_retval 	: DINT;
	END_VAR

//	l.d		sd_retval, -100
	sd_retval := -100;

END_FUNCTION //VIRTUAL GLOBAL DiasMaster::AddWrDO

//[#ENGLISH]
//=================================================================================================
//Function to write a direct access data object
//=================================================================================================
//[>ud_address]address to write
//[>ud_length]length of data should be written
//[>p_ud_data]pointer to data should be written
FUNCTION VIRTUAL GLOBAL DiasMaster::WrDO								//#SR002
VAR_INPUT
	ud_address		: UDINT;
	ud_length		: UDINT;
	p_ud_data		: pVoid;
	ud_type			: UDINT;
END_VAR
VAR_OUTPUT
	sd_retval		: DINT;
END_VAR

//	l.d		sd_retval, -100
	sd_retval := -100;

END_FUNCTION //VIRTUAL GLOBAL DiasMaster::WrDO
//[#ENGLISH]
//=================================================================================================
//Function to read a direct access data object
//=================================================================================================
//[>ud_address]address to read
//[>ud_length]length of data should read
//[>p_ud_data]variable to get pointer to readed data
FUNCTION VIRTUAL GLOBAL DiasMaster::RdDO								//#SR002
VAR_INPUT
	ud_address		: UDINT;
	ud_length		: UDINT;
	p_ud_data		: pVoid;
	ud_type			: UDINT;
END_VAR
VAR_OUTPUT
	sd_retval		: DINT;
END_VAR
	
//	l.d		sd_retval, -100
	sd_retval := -100;

END_FUNCTION //VIRTUAL GLOBAL DiasMaster::RdDO
//[#ENGLISH]
//=================================================================================================
//Function to add a read/write data object
//=================================================================================================
//[>ud_dol_type] type of DOL list( 1=direct access, 2=IRQ, 3=realtime, 4=cyclic )
//[>p_ud_handle] pointer to variable to set right handle
//[>ud_address_read] Address of read data object
//[>ud_length_read] Length of read data object
//[>p_ud_data_read] pointer to variable to get pointer to data
//[>ud_address_write] Address of write data object
//[>ud_length_write] Length of write data object
//[>p_ud_data_write] pointer to variable to get pointer to data
//[<sd_retval] 0=OK, negative=error (look lsl_st_varan.h)
FUNCTION VIRTUAL GLOBAL DiasMaster::AddRdWrDO
	VAR_INPUT
		ud_dol_type 	: UDINT;
		p_ud_handle 	: ^UDINT;
		ud_address_read 	: UDINT;
		ud_length_read 	: UDINT;
		p_ud_data_read 	: ^UDINT;
		ud_address_write 	: UDINT;
		ud_length_write 	: UDINT;
		p_ud_data_write 	: ^UDINT;
		ud_type 	: UDINT;
		p_ud_DataAddr_read 	: ^HDINT;
		p_ud_DataAddr_write 	: ^HDINT;
	END_VAR
	VAR_OUTPUT
		sd_retval 	: DINT;
	END_VAR

//	l.d		sd_retval, -100
	sd_retval := -100;

END_FUNCTION //VIRTUAL GLOBAL DiasMaster::AddRdWrDO
//[#ENGLISH]
//=================================================================================================
//Function to install a callback function
//=================================================================================================
//[>us_place]place of cdias module
//[>ud_action_ptr]pointer to position info( first byte is length)
//[>ud_thisp]thispointer of object
FUNCTION VIRTUAL GLOBAL DiasMaster::SetObjectCallback					//#SR002
VAR_INPUT
	us_place		: USINT;
	ud_action_ptr	: UDINT;
	ud_thisp		: UDINT;
END_VAR
END_FUNCTION //VIRTUAL GLOBAL DiasMaster::SetObjectCallback
//[#ENGLISH]
//=================================================================================================
//Function to install a varan task
//=================================================================================================
//[>ud_dol_type] type of DOL list( Realtime = 3, cyclic = 4 )
//[>p_this] Thispointer of connected varan class
FUNCTION VIRTUAL GLOBAL DiasMaster::AddVaranTask
	VAR_INPUT
		ud_dol_type 	: UDINT;
		p_this 	: ^void;
		callOptions 	: USINT;
	END_VAR
END_FUNCTION //VIRTUAL GLOBAL DiasMaster::AddVaranTask
//[#ENGLISH]
//=================================================================================================
//Function to reset a Data object (set default parameter)
//=================================================================================================
//[>p_data_object]pointer to varan data object header
//[>us_state]state of data object
//[>ud_bytes]bytes of cdias accesses
FUNCTION VIRTUAL GLOBAL DiasMaster::ResetDO
	VAR_INPUT
	p_data_object		: ^DINT;
	us_state			: USINT;
	ud_bytes			: UDINT;
	END_VAR
	VAR_OUTPUT
		sd_retval 	: DINT;
	END_VAR
  
  sd_retval := 0;
  
END_FUNCTION //VIRTUAL GLOBAL DiasMaster::ResetDO
//[#ENGLISH]
//=================================================================================================
//Function to find out if varan is available
//=================================================================================================
//[<sd_varan]0=varan not available, 1=varan available
FUNCTION VIRTUAL GLOBAL DiasMaster::IsVaranAvailable						//#SR002
VAR_OUTPUT
	sd_varan		: DINT;
END_VAR
	
	sd_varan := 0;

END_FUNCTION //VIRTUAL GLOBAL DiasMaster::IsVaranAvailable

FUNCTION VIRTUAL GLOBAL DiasMaster::I2CWriteOneByte					//#SR003
VAR_INPUT
	AdressCDIAS		: UINT;
	pData			: ^USINT;
END_VAR
VAR_OUTPUT
	result		: DINT;
END_VAR
	result := -1;
END_FUNCTION //VIRTUAL GLOBAL DiasMaster::I2CWriteOneByte
FUNCTION VIRTUAL GLOBAL DiasMaster::WriteEEData						//#SR003
VAR_INPUT
	Adress		: UDINT;
	pData		: ^USINT;
	ui_length	: UINT;
	ui_offset	: UINT;
END_VAR
VAR_OUTPUT
	retval		: DINT;
END_VAR
	retval := -1;
END_FUNCTION //VIRTUAL GLOBAL DiasMaster::WriteEEData

//[#ENGLISH]
//[>p_data]pointer to varan write data
//[>ud_address]address of do
FUNCTION VIRTUAL GLOBAL DiasMaster::SetNewDOAddressRd			//#SR004
VAR_INPUT
	p_data			: ^DINT;
	ud_address		: UDINT;
END_VAR
END_FUNCTION //VIRTUAL GLOBAL DiasMaster::SetNewDOAddress
//[#ENGLISH]
//[>p_data]pointer to varan write data
//[>ud_address]address of do
FUNCTION VIRTUAL GLOBAL DiasMaster::SetNewDOAddressWr			//#SR004
VAR_INPUT
	p_data		: ^DINT;
	ud_address		: UDINT;
END_VAR
END_FUNCTION //VIRTUAL GLOBAL DiasMaster::SetNewDOAddressWr
//[#ENGLISH]
//[>p_data]pointer to varan write data
//[>ud_address_read]read address of do
//[>ud_address_write]write address of do
FUNCTION VIRTUAL GLOBAL DiasMaster::SetNewDOAddressRdWr			//#SR004
VAR_INPUT
	p_data		: ^DINT;
	ud_address_read		: UDINT;
	ud_address_write		: UDINt;
END_VAR
END_FUNCTION //VIRTUAL GLOBAL DiasMaster::SetNewDOAddressRdWr
//[#ENGLISH]
//[<p_us_node]pointer to node string
FUNCTION VIRTUAL GLOBAL DiasMaster::GetPointer2NodeString			//#SR005
VAR_OUTPUT
	p_us_node		: ^USINT;
END_VAR

	p_us_node := NIL;

END_FUNCTION //VIRTUAL GLOBAL DiasMaster::GetPointer2NodeString
FUNCTION VIRTUAL GLOBAL DiasMaster::GetActualAddressPointer		//#SR006
VAR_INPUT
	ud_dol_type		: UDINT;
END_VAR
VAR_OUTPUT
	ud_add		: UDINT;
END_VAR
END_FUNCTION //VIRTUAL GLOBAL DiasMaster::GetActualAddressPointer

FUNCTION VIRTUAL GLOBAL DiasMaster::GetObjectPath
	VAR_INPUT
		p_us_ObjectPath 	: ^USINT;
	END_VAR
	VAR_OUTPUT
		sd_retval 	: DINT;
	END_VAR

  sd_retval := -1;
  
END_FUNCTION

FUNCTION VIRTUAL GLOBAL DiasMaster::SetObjectThisp
	VAR_INPUT
		p_us_ObjectPath 	: ^USINT;
		ud_thisp 	: UDINT;
	END_VAR
	VAR_OUTPUT
		sd_retval 	: DINT;
	END_VAR

  sd_retval := -1;
  
END_FUNCTION

FUNCTION VIRTUAL GLOBAL DiasMaster::SetTaskPriority
	VAR_INPUT
		us_place 	: USINT;
		us_priority 	: USINT;
		ud_dol_type 	: UDINT;
	END_VAR

END_FUNCTION

FUNCTION VIRTUAL GLOBAL DiasMaster::GetObjectThisp
	VAR_INPUT
		p_us_ObjectPath 	: ^USINT;
	END_VAR
	VAR_OUTPUT
		ud_Thisp 	: UDINT;
	END_VAR

  ud_Thisp := 0;
  
END_FUNCTION

FUNCTION VIRTUAL GLOBAL DiasMaster::SetRetryCounterAvailability
	VAR_INPUT
		Port 	    : USINT;
		p_State 	: ^IO_State;
    p_RetryCounter: ^DINT;
	END_VAR

END_FUNCTION

FUNCTION VIRTUAL DiasMaster::UpdateDIASRetryCounter

END_FUNCTION

FUNCTION VIRTUAL GLOBAL DiasMaster::UpdateRtPostScan

END_FUNCTION

FUNCTION VIRTUAL GLOBAL DiasMaster::AddRequiredObject
	VAR_INPUT
		thisp 	: ^void;
	END_VAR

END_FUNCTION

FUNCTION VIRTUAL DiasMaster::CheckforRequiredError

END_FUNCTION

FUNCTION VIRTUAL GLOBAL DiasMaster::SetRequiredError
	VAR_INPUT
		p_this 	: ^HWBase;
	END_VAR

END_FUNCTION

FUNCTION VIRTUAL GLOBAL DiasMaster::GetModuleInfo
	VAR_INPUT
		us_place 	: USINT;
	END_VAR
	VAR_OUTPUT
		p_ModuleInfo 	: ^t_s_ModulInfo;
	END_VAR

  p_ModuleInfo := NIL;
  
END_FUNCTION

FUNCTION VIRTUAL GLOBAL DiasMaster::AddMovDO
	VAR_INPUT
		ud_dol_type 	: UDINT;
		p_ud_handle 	: ^UDINT;
		p_ud_MovSettings 	: ^UDINT;
		ud_type 	: UDINT;
	END_VAR
	VAR_OUTPUT
		sd_retval 	: DINT;
	END_VAR

END_FUNCTION

#pragma warning(default: 76)
#pragma warning (default:73)

